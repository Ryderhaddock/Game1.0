<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Circle Combat</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Russo+One&display=swap" rel="stylesheet">
    <style>
        html, body {
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
        body { 
            background-color: #1a1a1a; 
            display: flex; 
            justify-content: center; 
            align-items: center; 
            font-family: 'Courier New', Courier, monospace;
        }
        canvas { 
            display: none; 
            background-color: #CDBA96; 
            max-width: 100vw;
            max-height: 100vh;
            object-fit: contain;
            cursor: crosshair;
        }
        #gameCanvas {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }
        #game-container { 
            position: relative; 
            width: 100%; 
            height: 100%;
        }
        #game-ui { position: absolute; top: 10px; left: 10px; right: 10px; bottom: 10px; display: none; pointer-events: none; z-index: 2;}
        #minimap-container { position: absolute; top: 10px; left: 0; pointer-events: auto; }
        #minimap { width: 150px; height: 150px; border: 2px solid #D2B48C; background-color: rgba(42, 33, 28, 0.5); display: block; cursor: pointer; }
        
        #bottom-center-hud {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            align-items: center;
            gap: 20px;
        }
        #ammo-counter {
            color: #FFF8DC;
            font-size: 28px;
            font-weight: bold;
            text-shadow: 2px 2px 4px #000;
            pointer-events: auto;
        }
        #bomb-icon-container {
            display: none;
            pointer-events: auto;
        }
        
        #plant-bomb-button {
            position: absolute;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            padding: 10px 20px;
            border-radius: 8px;
            font-size: 20px;
            font-weight: bold;
            text-shadow: 1px 1px 2px #000;
            display: none;
            pointer-events: auto;
            border: 2px solid #3a3a3a;
            background-color: #4a4a4a;
            color: #FFF8DC;
            cursor: pointer;
            transition: background 0.1s;
        }
        #plant-bomb-button:hover {
            background-color: #5a5a5a;
        }

        .top-ui-container {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            display: none;
            flex-direction: row;
            align-items: center; 
            pointer-events: auto;
            background-color: rgba(80, 70, 60, 0.8);
            border: 2px solid #D2B48C;
            border-radius: 8px;
            width: calc(100% - 380px); 
            justify-content: center;
            height: 65px; 
        }
        .team-icon-group {
            display: flex;
            gap: 10px;
            padding: 5px;
            text-align: center;
            align-items: center;
            height: 100%;
        }
        .player-portrait-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 100%;
            justify-content: center;
        }
        #blue-team-icons {
            border-right: 2px solid #D2B48C;
        }
        #red-team-icons {
             border-left: 2px solid #D2B48C;
        }
        #center-info-block {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2px;
            padding: 5px 10px;
            cursor: pointer;
        }
        #game-timer-bar {
            font-size: 18px; 
            font-weight: bold;
            color: #FFF8DC;
            text-align: center;
            white-space: nowrap;
        }
        #game-event-text {
            position: absolute;
            top: 85px; /* Below the top UI bar */
            left: 50%;
            transform: translateX(-50%);
            color: #FF4747;
            font-size: 16px;
            font-weight: bold;
            text-shadow: 1px 1px 2px #000;
            display: none; /* Hidden by default */
        }
        #team-role-display {
            font-size: 11px;
            color: #FFF8DC;
        }
        #team-score-bar {
            display: flex;
            width: 100%;
            justify-content: space-between;
        }
        .score-display {
            width: 50%;
            padding: 5px;
            font-size: 24px;
            font-weight: bold;
            text-align: center;
        }
        #blue-score-display {
            color: #E0EFFF;
        }
        #red-score-display {
            color: #FFD0D0;
        }
        .top-ui-container canvas {
            display: block;
            border-radius: 5px;
        }

        .menu-screen { 
            position: absolute; 
            top: 50%; 
            left: 50%; 
            transform: translate(-50%, -50%); 
            color: #FFF8DC; 
            text-align: center; 
            padding: 30px; 
            z-index: 10; 
            width: 80%; 
            max-width: 600px;
            overflow: hidden; 
            display: none;
            flex-direction: column;
            align-items: center;
        }
        #welcome-screen {
            background-color: #2a211c; 
            border: 2px solid #D2B48C;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            position: relative;
        }
        #creator-credit {
            position: absolute;
            bottom: 15px;
            right: 20px;
            font-size: 12px;
            color: rgba(255, 248, 220, 0.5);
            z-index: 1;
        }
        #welcome-bg-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -2;
            border-radius: 13px; /* Slightly less than parent */
            display: block;
        }
        #round-scoreboard, #game-over, #in-game-menu, #settings-menu, #matchup-screen {
             background-color: rgba(42, 33, 28, 0.95);
             border: 2px solid #D2B48C;
             border-radius: 15px;
        }
        #in-game-menu {
             width: auto;
             max-width: 300px;
             pointer-events: auto;
        }
        .menu-screen h1, .menu-screen .menu-button {
            position: relative;
            z-index: 1; /* Ensure text/buttons are above background animations */
        }
        .menu-screen h1 { 
            font-family: 'Russo One', sans-serif;
            font-size: 56px; 
            margin-top: 0; 
            margin-bottom: 20px;
            color: #FFF8DC;
            text-shadow: 0 0 10px #D2B48C, 0 0 20px #D2B48C, 3px 3px 5px rgba(0,0,0,0.5);
        }
        #welcome-screen h1, #welcome-screen .menu-button {
             opacity: 0;
            animation: fadeInUp 0.8s forwards;
        }
        #welcome-screen h1 { animation-delay: 0.2s; }
        
        @keyframes fadeInUp {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .menu-button { 
            background-color: #4a4a4a;
            border: 2px solid #3a3a3a;
            color: #FFF8DC; 
            padding: 15px 30px; 
            font-size: 20px; 
            cursor: pointer; 
            display: block; 
            width: 100%; 
            margin-bottom: 15px; 
            text-transform: uppercase;
            transition: all 0.2s ease-out;
            border-radius: 8px;
        }
        #welcome-screen .menu-button:nth-of-type(1) { animation-delay: 0.4s; }
        #welcome-screen .menu-button:nth-of-type(2) { animation-delay: 0.6s; }
        #welcome-screen .menu-button:nth-of-type(3) { animation-delay: 0.8s; }

        .menu-button:hover:not(:disabled) { 
            transform: scale(1.05); 
            box-shadow: 0 0 15px rgba(210, 180, 140, 0.6);
            background-color: #5a5a5a;
        }
        .menu-button:disabled { 
            background-color: #3a3a3a; 
            color: #6c757d; 
            cursor: not-allowed; 
            border-color: #2a2a2a;
        }
        .menu-button:disabled span {
            color: #888;
        }
        
        #dune-bg {
            position: absolute;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            z-index: -1;
            border-radius: 15px;
            overflow: hidden;
        }
        #dune-bg::before, #dune-bg::after {
            content: '';
            position: absolute;
            bottom: 0;
            width: 200%;
            height: 200px;
            background: linear-gradient(to top, rgba(160, 130, 90, 0.4), transparent);
            border-radius: 50%;
        }
        #dune-bg::before {
            left: -50%;
            animation: parallax-dunes 25s linear infinite;
        }
        #dune-bg::after {
            left: 0;
            animation: parallax-dunes 40s linear infinite reverse;
            background: linear-gradient(to top, rgba(193, 154, 107, 0.3), transparent);
        }
        @keyframes parallax-dunes {
            from { transform: translateX(-25%); }
            to { transform: translateX(25%); }
        }
        
        #in-game-menu-button {
            position: absolute;
            top: 10px;
            right: 10px;
            pointer-events: auto;
            width: auto; /* Override the 100% width from .menu-button */
            padding: 10px 15px;
            font-size: 16px;
            z-index: 5;
        }
        
        #fullscreen-map-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 20; 
            display: none; 
            justify-content: center;
            align-items: center;
            cursor: pointer;
        }
        #fullscreen-map-canvas {
            background-color: #CDBA96;
            border: 2px solid #D2B48C;
        }

        #round-winner-text {
             font-size: 32px; 
             font-family: 'Russo One', sans-serif;
             animation: none;
             opacity: 1;
        }
        .match-score { display: flex; justify-content: center; align-items: center; margin: 20px 0; gap: 5px; }
        .vs-text { font-size: 20px; font-weight: bold; margin: 0 10px; color: #FFF8DC; }
        .score-box {
            width: 20px;
            height: 20px;
            border: 2px solid #D2B48C;
            background-color: rgba(0,0,0,0.3);
            border-radius: 4px;
        }
        .score-box.blue-win {
            background-color: #a0c4ff;
        }
        .score-box.red-win {
            background-color: #ffadad;
        }
        #scoreboard-teams-container { display: flex; flex-wrap: wrap; justify-content: space-between; gap: 20px; }
        .scoreboard-team { flex: 1; min-width: 250px;}
        .scoreboard-team h2 { margin-top: 0; font-size: 24px; }
        .scoreboard-team.blue { color: #a0c4ff; }
        .scoreboard-team.red { color: #ffadad; }
        .scoreboard-header, .scoreboard-player-row { 
            display: grid; 
            grid-template-columns: 2fr 1fr 1fr 1fr 1fr 1.5fr; 
            gap: 5px; 
            padding: 5px; 
            text-align: left; 
            align-items: center;
        }
        .scoreboard-header { 
            font-weight: bold; 
            border-bottom: 1px solid #D2B48C; 
            font-size: 10px; 
        }
        .scoreboard-header > div,
        .scoreboard-player-row > div {
            text-align: center;
        }
        .scoreboard-header > div:first-child,
        .scoreboard-player-row > div:first-child {
            text-align: left;
        }
        .scoreboard-player-row { 
            background-color: rgba(255,255,255,0.05); 
            border-radius: 4px; 
            margin-bottom: 5px; 
            font-size: 14px;
        }
        #player-info-container {
            position: absolute;
            bottom: 20px;
            left: 20px;
            display: flex;
            flex-direction: column;
            gap: 5px;
            pointer-events: none;
        }
        #player-name-display {
            color: #FFF8DC;
            font-size: 16px;
            font-weight: bold;
            text-shadow: 1px 1px 2px #000;
        }
        #player-health-bar-container {
            width: 150px;
            height: 15px;
            border: 1px solid #FFF8DC;
            background-color: rgba(0,0,0,0.5);
            border-radius: 3px;
        }
        #player-health-bar {
            width: 100%;
            height: 100%;
            background-color: #4CAF50; /* Green */
            border-radius: 2px;
            transition: width 0.2s linear;
        }
        #matchup-screen {
            width: 100%;
            max-width: none;
            height: 100%;
            top: 0;
            left: 0;
            transform: none;
            border-radius: 0;
            background-color: rgba(0,0,0,0.5);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }
        #matchup-bg-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            filter: blur(5px) brightness(0.7);
            display: block;
        }
        #matchup-content {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 80%;
            max-width: 1000px;
            color: #FFF8DC;
        }
        .matchup-team {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        #matchup-blue-team {
            align-items: flex-end;
            padding-right: 40px;
        }
        #matchup-red-team {
            align-items: flex-start;
            padding-left: 40px;
        }
        .matchup-player-card {
            display: flex;
            align-items: center;
            gap: 15px;
            background-color: rgba(0,0,0,0.6);
            padding: 10px;
            border-radius: 8px;
            border: 1px solid #D2B48C;
        }
        #matchup-red-team .matchup-player-card {
            flex-direction: row-reverse;
        }
        .matchup-player-card canvas {
            width: 60px;
            height: 60px;
            display: block;
            border-radius: 5px;
        }
        .matchup-player-card .player-name {
            font-size: 20px;
            font-weight: bold;
        }
        .vs-text-large {
            font-family: 'Russo One', sans-serif;
            font-size: 80px;
            margin: 0 40px;
            text-shadow: 0 0 15px #D2B48C;
        }
        #round-countdown {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-family: 'Russo One', sans-serif;
            font-size: 100px;
            color: #FFF8DC;
            text-shadow: 0 0 20px #000;
            z-index: 100;
            display: none;
            pointer-events: none;
        }
        #spectate-controls {
            position: absolute;
            bottom: 20px;
            right: 20px;
            display: none;
            gap: 10px;
            pointer-events: auto;
        }
        .spectate-arrow {
            font-size: 30px;
            color: white;
            cursor: pointer;
            text-shadow: 1px 1px 3px black;
            user-select: none;
        }
        .spectate-arrow:hover {
            color: #D2B48C;
        }
        .setting-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            padding: 10px 0;
            font-size: 18px;
            text-transform: uppercase;
        }

        .custom-checkbox {
            position: relative;
            cursor: pointer;
            width: 28px;
            height: 28px;
            background-color: #4a4a4a;
            border: 2px solid #3a3a3a;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .custom-checkbox .checkmark {
            display: none;
            width: 8px;
            height: 14px;
            border: solid #4CAF50;
            border-width: 0 4px 4px 0;
            transform: rotate(45deg);
        }

        #joystick-toggle:checked ~ .custom-checkbox .checkmark {
            display: block;
        }
        #scoreboard-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.7);
            z-index: 15;
            display: none;
            justify-content: center;
            align-items: center;
            pointer-events: auto; /* Allow clicking on the overlay to close it */
        }
        #scoreboard-overlay > .menu-screen {
             pointer-events: auto;
             max-width: 800px;
        }
        #kill-feed {
            position: absolute;
            top: 80px; /* Adjust as needed */
            right: 20px;
            width: 300px;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 5px;
            pointer-events: none;
        }
        .kill-feed-item {
            background-color: rgba(0, 0, 0, 0.5);
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 14px;
            animation: fadeOut 5s forwards;
            white-space: nowrap;
        }
        .kill-feed-item .blue-team { color: #a0c4ff; }
        .kill-feed-item .red-team { color: #ffadad; }
        .kill-feed-item .weapon { color: #FFF8DC; }
        @keyframes fadeOut {
            0% { opacity: 1; }
            80% { opacity: 1; }
            100% { opacity: 0; }
        }

    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>

    <div id="game-ui">
        <div class="top-ui-container" id="tdm-ui">
            <div class="team-icon-group" id="blue-team-icons">
                 <!-- Portraits will be generated by JS -->
            </div>
            <div id="center-info-block">
                 <div id="game-timer-bar">2:00</div>
                 <div id="team-role-display"></div>
                 <div id="team-score-bar">
                    <div id="blue-score-display">0</div>
                    <div id="red-score-display">0</div>
                 </div>
            </div>
            <div class="team-icon-group" id="red-team-icons">
                 <!-- Portraits will be generated by JS -->
            </div>
        </div>
        <div id="game-event-text"></div>
        <div id="kill-feed"></div>
        <button class="menu-button" id="in-game-menu-button">Menu</button>
        <div id="minimap-container">
            <canvas id="minimap"></canvas>
        </div>
        
        <div id="bottom-center-hud">
            <div id="bomb-icon-container">
                <svg width="50" height="50" viewBox="0 0 100 100">
                    <rect x="20" y="35" width="60" height="30" fill="#333" stroke="black" stroke-width="2"/>
                    <rect x="45" y="25" width="10" height="10" fill="#555"/>
                    <line x1="50" y1="25" x2="50" y2="15" stroke="red" stroke-width="4"/>
                </svg>
            </div>
            <div id="ammo-counter">30 / ∞</div>
        </div>
        
        <button id="plant-bomb-button" style="display:none;">Hold to Plant</button>
        
        <div id="player-info-container">
            <div id="player-name-display"></div>
            <div id="player-health-bar-container">
                <div id="player-health-bar"></div>
            </div>
        </div>

        <div id="spectate-controls">
            <div class="spectate-arrow" id="spectate-prev">&larr;</div>
            <div class="spectate-arrow" id="spectate-next">&rarr;</div>
        </div>
    </div>
    
    <div id="welcome-screen" class="menu-screen">
        <canvas id="welcome-bg-canvas"></canvas>
        <div id="dune-bg"></div>
        <h1>Circle Combat</h1>
        <div id="main-menu-view">
            <button class="menu-button" id="show-sp-menu-button">Single Player</button>
            <button class="menu-button" id="multiplayer-button" disabled>Multiplayer <span>(Disabled)</span></button>
            <button class="menu-button" id="main-menu-settings-button">Settings</button>
        </div>
        <div id="single-player-menu-view" style="display: none; width: 100%;">
             <button class="menu-button" id="3v3-button">3v3</button>
             <button class="menu-button" id="1v1-button">1v1</button>
             <button class="menu-button" id="sp-back-button">Back</button>
        </div>
        <div id="creator-credit">Created by Ryder Haddock</div>
    </div>
    
    <div id="matchup-screen" class="menu-screen">
        <canvas id="matchup-bg-canvas"></canvas>
        <div id="matchup-content">
            <div id="matchup-blue-team" class="matchup-team">
                <!-- Blue team profiles go here -->
            </div>
            <div class="vs-text-large">VS</div>
            <div id="matchup-red-team" class="matchup-team">
                <!-- Red team profiles go here -->
            </div>
        </div>
    </div>

    <div id="in-game-menu" class="menu-screen">
        <button class="menu-button" id="resume-button">Resume</button>
        <button class="menu-button" id="leave-match-button">Leave Match</button>
    </div>

    <div id="settings-menu" class="menu-screen">
        <h1>Settings</h1>
        <div class="setting-row">
            <label for="joystick-toggle">Enable Joysticks</label>
            <input type="checkbox" id="joystick-toggle" checked style="display: none;">
            <label for="joystick-toggle" class="custom-checkbox">
                <div class="checkmark"></div>
            </label>
        </div>
        <button class="menu-button" id="back-button">Back</button>
    </div>

    <div id="scoreboard-overlay">
        <div id="round-scoreboard" class="menu-screen">
            <h1 id="round-winner-text"></h1>
            <div class="match-score" id="round-end-match-score">
                <!-- Score boxes will be generated by JS -->
            </div>
            <div id="scoreboard-teams-container">
                <div class="scoreboard-team blue">
                    <h2>Blue Team</h2>
                    <div class="scoreboard-header">
                        <div>Player</div>
                        <div class="col-stat">Kills</div>
                        <div class="col-stat">Assists</div>
                        <div class="col-stat">Plants</div>
                        <div class="col-stat">Defuses</div>
                        <div class="col-stat">Score</div>
                    </div>
                    <div id="scoreboard-blue-team"></div>
                </div>
                <div class="scoreboard-team red">
                    <h2>Red Team</h2>
                     <div class="scoreboard-header">
                        <div>Player</div>
                        <div class="col-stat">Kills</div>
                        <div class="col-stat">Assists</div>
                        <div class="col-stat">Plants</div>
                        <div class="col-stat">Defuses</div>
                        <div class="col-stat">Score</div>
                    </div>
                    <div id="scoreboard-red-team"></div>
                </div>
            </div>
        </div>
    </div>

    <div id="game-over" class="menu-screen">
        <h1 id="final-winner-title"></h1>
        <div class="match-score" id="final-match-score">
        </div>
        <button class="menu-button" id="play-again-button">Play Again</button>
    </div>
    <div id="fullscreen-map-overlay"><canvas id="fullscreen-map-canvas"></canvas></div>
    <div id="round-countdown"></div>
</div>

<script>
    document.addEventListener('DOMContentLoaded', () => {

    'use strict';

    // Get DOM elements
    const gameContainer = document.getElementById('game-container');
    const gameCanvas = document.getElementById('gameCanvas');
    const ctx = gameCanvas.getContext('2d');
    const minimapCanvas = document.getElementById('minimap');
    const minimapCtx = minimapCanvas.getContext('2d');
    const welcomeScreenElement = document.getElementById('welcome-screen');
    const welcomeBgCanvas = document.getElementById('welcome-bg-canvas');
    let welcomeBgCtx = welcomeBgCanvas.getContext('2d');
    const settingsMenuElement = document.getElementById('settings-menu');
    const inGameMenuElement = document.getElementById('in-game-menu');
    const gameOverElement = document.getElementById('game-over');
    const scoreboardOverlay = document.getElementById('scoreboard-overlay');
    const roundScoreboardElement = document.getElementById('round-scoreboard');
    const matchupScreenElement = document.getElementById('matchup-screen');
    const matchupBgCanvas = document.getElementById('matchup-bg-canvas');
    const matchupBlueTeamContainer = document.getElementById('matchup-blue-team');
    const matchupRedTeamContainer = document.getElementById('matchup-red-team');
    const gameUiElement = document.getElementById('game-ui');
    const finalWinnerTitleElement = document.getElementById('final-winner-title');
    const roundWinnerTextElement = document.getElementById('round-winner-text');
    const scoreboardBlueTeam = document.getElementById('scoreboard-blue-team');
    const scoreboardRedTeam = document.getElementById('scoreboard-red-team');
    const ammoCounterElement = document.getElementById('ammo-counter');
    const plantBombButton = document.getElementById('plant-bomb-button');
    const bombIconContainer = document.getElementById('bomb-icon-container');
    const tdmUiContainer = document.getElementById('tdm-ui');
    const centerInfoBlock = document.getElementById('center-info-block');
    const gameTimerBar = document.getElementById('game-timer-bar');
    const gameEventText = document.getElementById('game-event-text');
    const eventFeed = document.getElementById('event-feed');
    const teamRoleDisplay = document.getElementById('team-role-display');
    const blueScoreDisplay = document.getElementById('blue-score-display');
    const redScoreDisplay = document.getElementById('red-score-display');
    const blueTeamIconsContainer = document.getElementById('blue-team-icons');
    const redTeamIconsContainer = document.getElementById('red-team-icons');
    const fullscreenMapOverlay = document.getElementById('fullscreen-map-overlay');
    const fullscreenMapCanvas = document.getElementById('fullscreen-map-canvas');
    const playerInfoContainer = document.getElementById('player-info-container');
    const playerNameDisplay = document.getElementById('player-name-display');
    const playerHealthBar = document.getElementById('player-health-bar');
    const mainMenuView = document.getElementById('main-menu-view');
    const singlePlayerMenuView = document.getElementById('single-player-menu-view');
    const roundCountdownElement = document.getElementById('round-countdown');
    const spectateControls = document.getElementById('spectate-controls');
    
    // Menu Buttons
    const showSpMenuButton = document.getElementById('show-sp-menu-button');
    const spBackButton = document.getElementById('sp-back-button');
    const mainMenuSettingsButton = document.getElementById('main-menu-settings-button');
    const backButton = document.getElementById('back-button');
    const joystickToggle = document.getElementById('joystick-toggle');
    const threeVThreeButton = document.getElementById('3v3-button');
    const oneVOneButton = document.getElementById('1v1-button');
    const playAgainButton = document.getElementById('play-again-button');
    const inGameMenuButton = document.getElementById('in-game-menu-button');
    const resumeButton = document.getElementById('resume-button');
    const leaveMatchButton = document.getElementById('leave-match-button');
    const spectatePrevButton = document.getElementById('spectate-prev');
    const spectateNextButton = document.getElementById('spectate-next');

    
    // Game constants and variables
    let canvasWidth = 800;
    let canvasHeight = 600;
    const playerRadius = 15;
    const playerColor = '#4682B4';
    const moveSpeed = 220; 
    const aiMoveSpeed = 180; 
    const initialHitPoints = 100;
    const bulletRadius = 6;
    const bulletSpeed = 15.0; 
    const defaultBulletColor = '#FFD700';
    const bulletDamage = 20;
    const lightRadius = 275; 
    let cameraZoom = 1.0; 
    const BOMB_PLANT_TIME = 5;
    const BOMB_DEFUSE_TIME = 5;
    const BOMB_TIMER_DURATION = 45;
    const ASSIST_TIMER_DURATION = 5000;

    const BURST_COUNT = 3;
    const BURST_FIRE_RATE = 5; // ~0.09s delay between shots (5 frames at 60fps)
    const BURST_COOLDOWN_TIME = 25;
    
    const wallColor = '#654321'; 
    const floorColor = '#6c757d'; 
    const wallThickness = 8; 

    // Game state arrays
    let allCharacters = [];
    let bullets = [];
    let sandSpecks = [];
    let dunes = [];
    let floatingTexts = [];
    let particles = [];
    let powerUps = [];
    let obstacles = [];
    let floorTiles = [];
    let tdmSpawnPoints = [];
    let bombSites = [];
    let losSegments = []; // For line of sight calculation

    // Game state flags and timers
    let isGameOver = false;
    let inRoundTransition = false;
    let isRoundActive = false;
    let isPaused = false;
    let animationFrameId = null;
    let mapCenter;
    let gameState;
    let lastTimestamp = 0;
    let gameMode = '3v3'; 
    let spectatingId = null;
    let spectatablePlayers = [];
    let spectateTimer = 0;
    let roundState = { blueScore: 0, redScore: 0, roundNumber: 0, attackingTeam: 1 };
    let gameSettings = { useJoysticks: true };
    let mousePos = { x: 0, y: 0 };
    let bomb = {};
    let bombItem = { x: 0, y: 0, radius: 10, isCarried: false };
    let bombPlantedTextTimer = 0;
    let roundStartTextTimer = 0;
    let isPlantingButtonHeld = false;
    let previousView = 'welcome-screen';

    // Minimap and rendering state
    let isMinimapExpanded = false;
    let offscreenMinimapCanvas = null;
    let offscreenMinimapCtx = null;
    let fogCanvas = null;
    let fogCtx = null;
    
    // Welcome screen animation
    let welcomeAnimFrameId = null;
    let bgCircles = [];


    // Input state
    const keysDown = { w: false, a: false, s: false, d: false, " ": false, r: false, e: false };

    // Joystick state
    let movementJoystick = null;
    let shootingJoystick = null;

    let mapWidth, mapHeight;
    
    // Joystick class for mobile controls
    class Joystick {
        constructor(x, y, radius, handleRadius) {
            this.baseX = x; this.baseY = y;
            this.handleX = x; this.handleY = y;
            this.radius = radius;
            this.handleRadius = handleRadius;
            this.isActive = false;
            this.touchId = null;
            this.vector = { x: 0, y: 0 };
        }
        draw(g) {
            g.beginPath();
            g.arc(this.baseX, this.baseY, this.radius, 0, Math.PI * 2);
            g.fillStyle = 'rgba(128, 128, 128, 0.4)';
            g.fill();
            g.beginPath();
            g.arc(this.handleX, this.handleY, this.handleRadius, 0, Math.PI * 2);
            g.fillStyle = 'rgba(100, 100, 100, 0.6)';
            g.fill();
        }
        update(x, y) {
            const dx = x - this.baseX;
            const dy = y - this.baseY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            if (distance < this.radius) {
                this.handleX = x;
                this.handleY = y;
            } else {
                this.handleX = this.baseX + (dx / distance) * this.radius;
                this.handleY = this.baseY + (dy / distance) * this.radius;
            }
            const totalDist = this.radius;
            this.vector.x = (this.handleX - this.baseX) / totalDist;
            this.vector.y = (this.handleY - this.baseY) / totalDist;
        }
        reset() {
            this.isActive = false;
            this.touchId = null;
            this.vector = { x: 0, y: 0 };
        }
    }
    
    // Generates the map layout, obstacles, and line-of-sight segments
    function generateMapLayout() {
        obstacles = []; floorTiles = []; tdmSpawnPoints = []; powerUps = []; bombSites = []; losSegments = [];

        const color_grid = [
            "WWWWWWWWWBBBBBBBBBBBBWWWWWWWWW", "WWWWWWWWBBGGGGGGGGGGBBWWWWWWWW", "WWWWWWWWWGGGGBBBBGGGGWWWWWWWWW",
            "WWWWWWBWWGGGGGGGGGGGGWWBWWWWWW", "WWWWWWWWWBGCBBGGBBCGBWWWWWWWWW", "WWWWWWWWWBBBGGGGGGBBBWWWWWWWWW",
            "BBBBWWBWWWWBGGGGGGBWWWWBWWBBBB", "BRRWWWBWWWWWGGGGGGWWWWWBWWWRRB", "BRRWWWBWWWWWGGGGGGWWWWWBWWWRRB",
            "BBBBWWBWWWWBGGGGGGBWWWWBWWBBBB", "WWWWWWWWWBBBGGGGGGBBBWWWWWWWWW", "WWWWWWWWWBGCBBGGBBCGBWWWWWWWWW",
            "WWWWWWBWWGGGGGGGGGGGGWWBWWWWWW", "WWWWWWWWWGGGGBBBBGGGGWWWWWWWWW", "WWWWWWWWBBGGGGGGGGGGBBWWWWWWWW",
            "WWWWWWWWWBBBBBBBBBBBBWWWWWWWWW",
        ];
        
        const tileSize = 120;
        mapHeight = color_grid.length * tileSize;
        mapWidth = color_grid[0].length * tileSize;
        mapCenter = { x: mapWidth / 2, y: mapHeight / 2 };

        bombSites.push({ id: 'A', x: mapCenter.x, y: mapCenter.y, radius: 60 });
        bombSites.push({ id: 'B', x: 22 * tileSize, y: 12 * tileSize, radius: 60 });

        const wallCoordSet = new Set();
        color_grid.forEach((row, y) => { for (let x = 0; x < row.length; x++) { if (row[x] === 'B') wallCoordSet.add(`${x},${y}`); } });

        const gridCenterY = Math.floor(color_grid.length / 2);
        const gridCenterX = Math.floor(color_grid[0].length / 2);

        // Helper to add obstacle and its LOS segments
        const addObstacleWithLOS = (obs) => {
            obstacles.push(obs);
            const p1 = { x: obs.x, y: obs.y };
            const p2 = { x: obs.x + obs.w, y: obs.y };
            const p3 = { x: obs.x + obs.w, y: obs.y + obs.h };
            const p4 = { x: obs.x, y: obs.y + obs.h };
            losSegments.push({ p1, p2, ownerId: obs.id });
            losSegments.push({ p1: p2, p2: p3, ownerId: obs.id });
            losSegments.push({ p1: p3, p2: p4, ownerId: obs.id });
            losSegments.push({ p1: p4, p2: p1, ownerId: obs.id });
        };

        color_grid.forEach((row, y) => {
            for (let x = 0; x < row.length; x++) {
                const char = row[x]; const worldX = x * tileSize; const worldY = y * tileSize;
                if (char === 'B') {
                    const isEnclosed = wallCoordSet.has(`${x-1},${y}`) && wallCoordSet.has(`${x+1},${y}`) && wallCoordSet.has(`${x},${y-1}`) && wallCoordSet.has(`${x},${y+1}`);
                    const wall = { id: `wall_${x}_${y}`, type: 'wall', x: worldX, y: worldY, w: tileSize, h: tileSize, hp: Infinity, isEnclosed, borders: { top: !wallCoordSet.has(`${x},${y-1}`), bottom: !wallCoordSet.has(`${x},${y+1}`), left: !wallCoordSet.has(`${x-1},${y}`), right: !wallCoordSet.has(`${x+1},${y}`) } };
                    addObstacleWithLOS(wall);
                } else if (char === 'G') { floorTiles.push({x: worldX, y: worldY, w: tileSize, h: tileSize });
                } else if (char === 'R') { floorTiles.push({x: worldX, y: worldY, w: tileSize, h: tileSize }); tdmSpawnPoints.push({ x: worldX + tileSize / 2, y: worldY + tileSize / 2 });
                } else if (char === 'O') { floorTiles.push({x: worldX, y: worldY, w: tileSize, h: tileSize }); powerUps.push({ x: worldX + tileSize / 2, y: worldY + tileSize / 2, active: true, type: 'shotgun', radius: 10 });
                } else if (char === 'C') {
                    floorTiles.push({ x: worldX, y: worldY, w: tileSize, h: tileSize });
                    const crateSize = 25; const gap = 5; const formationWidth = crateSize*2+gap; const formationHeight = crateSize*2+gap;
                    const tileStartX = worldX + (tileSize - formationWidth)/2; const tileStartY = worldY + (tileSize - formationHeight)/2;
                    const corners = { topLeft: {x:tileStartX, y:tileStartY}, topRight: {x:tileStartX+crateSize+gap, y:tileStartY}, bottomLeft: {x:tileStartX, y:tileStartY+crateSize+gap}, bottomRight: {x:tileStartX+crateSize+gap, y:tileStartY+crateSize+gap} };
                    let positions = [];
                    if (y < gridCenterY && x < gridCenterX) positions = [corners.topRight, corners.bottomLeft, corners.bottomRight];
                    else if (y < gridCenterY && x > gridCenterX) positions = [corners.topLeft, corners.bottomLeft, corners.bottomRight];
                    else if (y > gridCenterY && x < gridCenterX) positions = [corners.topLeft, corners.topRight, corners.bottomRight];
                    else if (y > gridCenterY && x > gridCenterX) positions = [corners.topLeft, corners.topRight, corners.bottomLeft];
                    positions.forEach((pos, i) => { 
                        const crate = {id:`crate_${x}_${y}_${i}`,type:'crate',x:pos.x,y:pos.y,w:crateSize,h:crateSize,hp:100};
                        addObstacleWithLOS(crate);
                    });
                }
            }
        });
        
        const centerCrateSize = 25;
        const outerGap = 120;
        const formationSize = centerCrateSize * 2;
        const totalStructureWidth = formationSize * 2 + outerGap;
        const structureStartX = mapCenter.x - totalStructureWidth / 2;
        const structureStartY = mapCenter.y - totalStructureWidth / 2;
        const crateFormations = [
            { qx: structureStartX, qy: structureStartY, shape: [[0, 0], [1, 0], [0, 1]] },
            { qx: structureStartX + formationSize + outerGap, qy: structureStartY, shape: [[0, 0], [1, 0], [1, 1]] },
            { qx: structureStartX, qy: structureStartY + formationSize + outerGap, shape: [[0, 0], [0, 1], [1, 1]] },
            { qx: structureStartX + formationSize + outerGap, qy: structureStartY + formationSize + outerGap, shape: [[0, 1], [1, 0], [1, 1]] }
        ];
        let centerCrateCounter = 0;
        crateFormations.forEach(formation => {
            formation.shape.forEach(pos => {
                const crate = { id: `center_L_crate_${centerCrateCounter++}`, type: 'crate', x: formation.qx + pos[0] * centerCrateSize, y: formation.qy + pos[1] * centerCrateSize, w: centerCrateSize, h: centerCrateSize, hp: 100 };
                addObstacleWithLOS(crate);
            });
        });

        const siteA = bombSites.find(s => s.id === 'A');
        if (siteA) {
            const siteCrateSize = 25;
            const siteCrateHP = 150;

            const newCrateFormations = [
                { x_offset: -200, y_offset: -180, shape: [[0,0],[1,0],[0,1]] },
                { x_offset: -300, y_offset: -120, shape: [[0,0],[0,1],[-1,1]] },
                { x_offset: -200, y_offset: 155, shape: [[0,0],[1,0],[0,-1]] },
                { x_offset: -300, y_offset: 170, shape: [[0,0],[0,-1],[-1,-1]] },
            ];
            
            newCrateFormations.forEach((formation, i) => {
                // Left side
                formation.shape.forEach((pos, j) => {
                     const crate = { id: `extra_L_${i}_${j}`, type: 'crate', x: siteA.x + formation.x_offset + pos[0] * siteCrateSize, y: siteA.y + formation.y_offset + pos[1] * siteCrateSize, w: siteCrateSize, h: siteCrateSize, hp: siteCrateHP };
                     addObstacleWithLOS(crate);
                });
                // Symmetrical Right side
                formation.shape.forEach((pos, j) => {
                     const mirroredX = siteA.x - (formation.x_offset + (pos[0] * siteCrateSize)) - siteCrateSize;
                     const mirroredY = siteA.y + formation.y_offset + pos[1] * siteCrateSize;
                     const crate = { id: `extra_R_${i}_${j}`, type: 'crate', x: mirroredX, y: mirroredY, w: siteCrateSize, h: siteCrateSize, hp: siteCrateHP };
                     addObstacleWithLOS(crate);
                });
            });
        }
    }

    function generateSandPattern() { if(!mapWidth || !mapHeight) return; sandSpecks = []; dunes = []; const speckColors = ['rgba(193, 154, 107, 0.1)', 'rgba(160, 130, 90, 0.15)', 'rgba(240, 220, 170, 0.05)']; for (let i=0; i<1500; i++) { sandSpecks.push({ x:Math.random()*mapWidth, y:Math.random()*mapHeight, r:1+Math.random()*2, c: speckColors[Math.floor(Math.random() * speckColors.length)], type: Math.random() > 0.1 ? 'circle' : 'line' }); } for(let i = 0; i < 60; i++) { dunes.push({ x: Math.random() * mapWidth, y: Math.random() * mapHeight, radiusX: 100 + Math.random() * 200, radiusY: 20 + Math.random() * 40, rotation: Math.random() * Math.PI, color: `rgba(210, 180, 140, ${0.05 + Math.random() * 0.15})`, shadowColor: `rgba(139, 115, 85, ${0.04 + Math.random() * 0.1})` }); } }
    
    function createCharacter(details) { 
        const base = { 
            hp: initialHitPoints,
            fireCooldown: 0,
            radius: playerRadius,
            score: 0,
            powerUp: null, 
            powerUpDuration: 0,
            showOnMinimapTimer: 0,
            aimAngle: 0,
            hasBomb: false,
            isPlanting: false, 
            plantTimer: 0,
            isDefusing: false,
            defuseTimer: 0,
            target: null,
            isBursting: false,
            burstsLeft: 0,
            burstCooldown: 0,
            kills: 0,
            assists: 0,
            plants: 0,
            defuses: 0,
            damageDealtTo: {},
            isAvoiding: false,
            avoidAngle: 0,
            avoidTimer: 0,
            stuckTimer: 0,
            lastPosition: {x:0, y:0},
            clipSize: 22, 
            ammo: 22, 
            isReloading: false, 
            reloadTime: 2, 
            reloadTimer: 0,
            isStrafing: false,
            strafeDirection: 1,
            strafeTimer: 0,
            strafeDecisionTimer: 0
        }; 
        const newChar = {...base, ...details}; 
        newChar.lastPosition = {x: newChar.x, y: newChar.y};
        return newChar; 
    }
    function createParticles(x, y, count, color) { for (let i = 0; i < count; i++) { const angle = Math.random() * Math.PI * 2; const speed = 2 + Math.random() * 3; particles.push({ x, y, dx: Math.cos(angle) * speed, dy: Math.sin(angle) * speed, radius: 1 + Math.random() * 2, color: color, lifetime: 20 + Math.random() * 20, alpha: 1 }); } }
    
    function createBullet(x, y, targetX, targetY, ownerId, ownerTeam, spread = 0) {
        const shooter = allCharacters.find(c => c.id === ownerId);
        const color = shooter ? shooter.color : defaultBulletColor;
        const baseAngle = Math.atan2(targetY - y, targetX - x);
        
        if (spread > 0) {
            for (let i = 0; i < 5; i++) {
                const angle = baseAngle + (i - 2) * spread;
                const dx = Math.cos(angle) * bulletSpeed;
                const dy = Math.sin(angle) * bulletSpeed;
                bullets.push({ x, y, dx, dy, owner: ownerId, team: ownerTeam, color: color });
            }
        } else {
            const dx = Math.cos(baseAngle) * bulletSpeed;
            const dy = Math.sin(baseAngle) * bulletSpeed;
            bullets.push({ x, y, dx, dy, owner: ownerId, team: ownerTeam, color: color });
        }
        
        if (shooter) {
            shooter.showOnMinimapTimer = 90;
        }
    }
    
    function distSq(x1, y1, x2, y2) { const dx = x1 - x2; const dy = y1 - y2; return dx * dx + dy * dy; }
    function nearActiveBombSite(character) { return bombSites.find(site => distSq(character.x, character.y, site.x, site.y) < site.radius * site.radius); }
    function nearBomb(character) { return bomb.planted && distSq(character.x, character.y, bomb.x, bomb.y) < 100 * 100; }
    
    function plantBomb(character, site) { 
        bomb.x = character.x; bomb.y = character.y; bomb.planted = true; bomb.active = true; 
        bomb.plantedByTeam = character.team; bomb.plantedById = character.id;
        bomb.timer = 0; bomb.siteId = site.id; 
        bombPlantedTextTimer = 3; // Start the 3-second timer for the text
        character.hasBomb = false; character.isPlanting = false; character.plantTimer = 0; 
        character.plants++; 
        character.score += 100;
    }
    function defuseBomb(character) { 
        bomb.active = false; character.isDefusing = false; 
        character.defuses++;
        character.score += 100;
        declareRoundWinner(character.team, "Bomb Defused"); 
    }
    
    function declareRoundWinner(winningTeam, reason) {
        if (inRoundTransition) return;
        inRoundTransition = true;
        isRoundActive = false;

        let roundWinnerText = '';
        const winnerTeamName = winningTeam === 1 ? 'Blue Team' : 'Red Team';
        
        switch(reason) {
            case "Bomb Detonated":
                roundWinnerText = "Target Destroyed";
                break;
            case "Bomb Defused":
                roundWinnerText = "Bomb Defused";
                break;
            default:
                roundWinnerText = `${winnerTeamName} Won`;
                break;
        }
        
        if (winningTeam === 1) roundState.blueScore++; else roundState.redScore++;
        
        if (reason === "Bomb Detonated") {
            const planter = allCharacters.find(c => c.id === bomb.plantedById);
            if (planter) {
                planter.score += 400;
            }
        }

        setTimeout(() => {
            showRoundScoreboard(roundWinnerText);
        }, 1000); // Delay scoreboard to let the action sink in
        

        setTimeout(() => {
            scoreboardOverlay.style.display = 'none'; // Hide scoreboard after delay
            const roundsToWin = gameMode === '1v1' ? 3 : 3;
            if (roundState.blueScore >= roundsToWin || roundState.redScore >= roundsToWin) {
                let finalWinnerText = roundState.blueScore > roundState.redScore ? "Blue Team" : "Red Team";
                 if(gameMode === '1v1'){
                    finalWinnerText = roundState.blueScore > roundState.redScore ? "Player 1" : "Player 2";
                }
                endGame(finalWinnerText);
            } else {
                startRound();
            }
        }, 5000);
    }
    
    function hasLineOfSight(p1, p2) {
        const ray = { p1, p2 };
        const distToTargetSq = distSq(p1.x, p1.y, p2.x, p2.y);

        for (const segment of losSegments) {
            // Do not check for intersection with the segments of the object the point is on
            if(p2.ownerId && p2.ownerId === segment.ownerId) continue;
            
            const intersection = getIntersection(ray, segment);
            if (intersection) {
                const distToIntersectionSq = distSq(p1.x, p1.y, intersection.x, intersection.y);
                if (distToIntersectionSq < distToTargetSq - 0.01) { 
                    return false; // View is blocked
                }
            }
        }
        return true; // Clear line of sight
    }

    function applyDamageAndHandleKill(target, shooter, damage) {
        target.hp -= damage;
        
        if (shooter) {
            target.damageDealtTo[shooter.id] = Date.now();
        }
        
        createParticles(target.x, target.y, 8, 'red');

        if (target.hp <= 0) {
            if (shooter) {
                shooter.kills++;
                shooter.score += 100;
            }

            const now = Date.now();
            for (const damagerId in target.damageDealtTo) {
                if (damagerId !== shooter?.id && (now - target.damageDealtTo[damagerId] < ASSIST_TIMER_DURATION)) {
                    const assister = allCharacters.find(c => c.id === damagerId);
                    if (assister) {
                        assister.assists++;
                        assister.score += 25;
                    }
                }
            }

            if (target.hasBomb) {
                target.hasBomb = false;
                bombItem.isCarried = false;
                bombItem.x = target.x;
                bombItem.y = target.y;
            }
        }
    }

    function updateCharacters(deltaTime) {
        if (!isRoundActive) return; // Prevent updates during countdowns

        const player = allCharacters.find(c => c.id === 'player');
        
        // Update spectating list if needed
        if (player.hp <= 0 && !spectatingId) {
            updateSpectateList(player);
        } else if(spectatingId){
            const currentSpectateTarget = allCharacters.find(c => c.id === spectatingId);
            if(!currentSpectateTarget || currentSpectateTarget.hp <= 0){
                updateSpectateList(player);
            }
        }
        

        allCharacters.forEach(character => {
            if (character.hp <= 0) return;
            
            if (character.showOnMinimapTimer > 0) {
                character.showOnMinimapTimer--;
            }

            let dx=0, dy=0;
            let isShooting = false; 

            if (character.id === 'player') {
                if(character.isPlanting || character.isDefusing) {
                    dx=0; dy=0;
                } else {
                    if (gameSettings.useJoysticks && movementJoystick?.isActive) { dx += movementJoystick.vector.x; dy += movementJoystick.vector.y; }
                    if (keysDown.a) dx -= 1; if (keysDown.d) dx += 1;
                    if (keysDown.w) dy -= 1; if (keysDown.s) dy += 1;
                }
                
                let fireKeyPressed = keysDown[' ']; 
                let joystickActive = gameSettings.useJoysticks && shootingJoystick?.isActive && (shootingJoystick.vector.x !== 0 || shootingJoystick.vector.y !== 0);
                isShooting = fireKeyPressed || joystickActive;
            } else {
                // --- AI LOGIC REWORKED ---
                if (!character.target || character.target.hp <= 0 || !hasLineOfSight(character, character.target)) {
                    const visibleEnemies = allCharacters.filter(c => c.team !== character.team && c.hp > 0 && hasLineOfSight(character, c));
                    character.target = visibleEnemies.length > 0 ? visibleEnemies[0] : null;
                }
                
                if (character.target) { // Has a visible target
                    const targetAngle = Math.atan2(character.target.y - character.y, character.target.x - character.x);
                    character.aimAngle = targetAngle;
                    isShooting = true;
                } else { // No visible target, move towards an objective
                    const objective = bombSites[character.team % bombSites.length]; // Simple objective
                    const objectiveAngle = Math.atan2(objective.y - character.y, objective.x - character.x);
                    character.aimAngle = objectiveAngle;
                    dx = Math.cos(objectiveAngle);
                    dy = Math.sin(objectiveAngle);
                    isShooting = false;
                }

                // Unstuck logic
                if (distSq(character.x, character.y, character.lastPosition.x, character.lastPosition.y) < 1) {
                    character.stuckTimer++;
                } else {
                    character.stuckTimer = 0;
                    character.isAvoiding = false;
                }
                
                if (character.stuckTimer > 30) { // If stuck for 0.5s
                    character.isAvoiding = true;
                    character.avoidAngle = character.aimAngle + (Math.PI / 2) * (Math.random() < 0.5 ? 1 : -1);
                    character.avoidTimer = 60; // Avoid for 1 second
                    character.stuckTimer = 0;
                }

                if (character.isAvoiding && character.avoidTimer > 0) {
                    dx = Math.cos(character.avoidAngle);
                    dy = Math.sin(character.avoidAngle);
                    character.avoidTimer--;
                }
                character.lastPosition = {x: character.x, y: character.y};
            }
            const speed = character.id === 'player' ? moveSpeed : aiMoveSpeed;
            const mag = Math.sqrt(dx*dx + dy*dy);
            if (mag > 0) resolveMovementWithCollision(character, dx/mag*speed*deltaTime, dy/mag*speed*deltaTime);

            if (character.id === 'player') {
                if (gameSettings.useJoysticks && shootingJoystick?.isActive && (shootingJoystick.vector.x !== 0 || shootingJoystick.vector.y !== 0)) { 
                    character.aimAngle = Math.atan2(shootingJoystick.vector.y, shootingJoystick.vector.x); 
                } else { 
                    const camX = allCharacters.find(c => c.id === 'player')?.x || mapCenter.x; 
                    const camY = allCharacters.find(c => c.id === 'player')?.y || mapCenter.y; 
                    const worldX = (mousePos.x - canvasWidth / 2) / cameraZoom + camX; 
                    const worldY = (mousePos.y - canvasHeight / 2) / cameraZoom + camY; 
                    character.aimAngle = Math.atan2(worldY - character.y, worldX - character.x); 
                }
            }
            
            if(character.fireCooldown > 0) character.fireCooldown--;
            if(character.burstCooldown > 0) character.burstCooldown--;

            if (character.isReloading) {
                character.reloadTimer -= deltaTime;
                if (character.reloadTimer <= 0) {
                    character.isReloading = false;
                    character.ammo = character.clipSize;
                }
            } else if ((character.id === 'player' && keysDown['r'] && character.ammo < character.clipSize) || character.ammo <= 0) {
                 character.isReloading = true; 
                 character.reloadTime = 2; 
                 character.reloadTimer = character.reloadTime;
            }

            if (character.isBursting && character.fireCooldown <= 0 && character.burstsLeft > 0) {
                const targetX = character.x + Math.cos(character.aimAngle) * 100;
                const targetY = character.y + Math.sin(character.aimAngle) * 100;
                createBullet(character.x, character.y, targetX, targetY, character.id, character.team);
                character.fireCooldown = BURST_FIRE_RATE;
                character.burstsLeft--;
                character.ammo--;
                if (character.burstsLeft === 0) {
                    character.isBursting = false;
                    character.burstCooldown = BURST_COOLDOWN_TIME;
                }
            } else if (isShooting && !character.isBursting && character.burstCooldown <= 0 && !character.isReloading && character.ammo > 0) {
                let didPointBlankDamage = false;
                for (const otherChar of allCharacters) {
                    if (otherChar.id === character.id || otherChar.team === character.team || otherChar.hp <= 0) continue;

                    if (distSq(character.x, character.y, otherChar.x, otherChar.y) < (character.radius + otherChar.radius) ** 2) {
                        applyDamageAndHandleKill(otherChar, character, bulletDamage);
                        didPointBlankDamage = true;
                        character.fireCooldown = BURST_COOLDOWN_TIME;
                        character.ammo--;
                         if(character.ammo <= 0) {
                            character.isReloading = true;
                            character.reloadTimer = character.reloadTime;
                        }
                        break;
                    }
                }

                if (!didPointBlankDamage) {
                    character.isBursting = true;
                    character.burstsLeft = Math.min(BURST_COUNT, character.ammo);
                    character.fireCooldown = 0; 
                }
            }
            
            if (gameMode === '3v3' || gameMode === '1v1') {
                if (!bombItem.isCarried && character.team === roundState.attackingTeam && distSq(character.x, character.y, bombItem.x, bombItem.y) < (character.radius + bombItem.radius)**2) {
                    bombItem.isCarried = true;
                    character.hasBomb = true;
                }
                if (character.id === 'player' && character.hasBomb && !bomb.planted) {
                    const site = nearActiveBombSite(character);
                    if (site && (isPlantingButtonHeld || keysDown['e'])) {
                        character.isPlanting = true;
                        character.plantTimer += deltaTime;
                        if (character.plantTimer >= BOMB_PLANT_TIME) plantBomb(character, site);
                    } else {
                        character.isPlanting = false;
                        character.plantTimer = 0;
                    }
                }
            }
        });
    }
    
    function updateGameTimers(deltaTime) {
        if (gameMode === '3v3' || gameMode === '1v1') {
            if (!inRoundTransition && isRoundActive && !bomb.planted) {
                if (gameState.gameTimer > 0) {
                    gameState.gameTimer -= deltaTime;
                } else {
                    const defendingTeam = roundState.attackingTeam === 1 ? 2 : 1;
                    declareRoundWinner(defendingTeam, "Time Expired");
                    return;
                }
            }
            if (bomb.planted && bomb.active) { 
                bomb.timer += deltaTime; 
                if (bomb.timer >= BOMB_TIMER_DURATION) { 
                    bomb.active = false; 
                    createParticles(bomb.x, bomb.y, 200, 'orange'); 
                    declareRoundWinner(bomb.plantedByTeam, "Bomb Detonated"); 
                } 
            }
            if (bombPlantedTextTimer > 0) {
                bombPlantedTextTimer -= deltaTime;
            }
            if (roundStartTextTimer > 0) {
                roundStartTextTimer -= deltaTime;
            }
        }
    }
    
    function checkWinCondition() {
        if (isGameOver || inRoundTransition || !isRoundActive) return;
        if (gameMode === '3v3' || gameMode === '1v1') {
            const attackersAlive = allCharacters.some(c => c.team === roundState.attackingTeam && c.hp > 0);
            const defendersAlive = allCharacters.some(c => c.team !== roundState.attackingTeam && c.hp > 0);
            if (!defendersAlive) {
                declareRoundWinner(roundState.attackingTeam, "Defenders Eliminated");
            } else if (!attackersAlive && !bomb.planted) {
                declareRoundWinner(roundState.attackingTeam === 1 ? 2 : 1, "Attackers Eliminated");
            }
        }
    }
    
    function showRoundScoreboard(winnerText) {
        roundWinnerTextElement.textContent = winnerText;
        
        const roundScoreContainer = document.getElementById('round-end-match-score');
        roundScoreContainer.innerHTML = ''; 
        
        for (let i = 1; i <= 3; i++) {
            const scoreBox = document.createElement('div');
            scoreBox.className = roundState.blueScore >= i ? 'score-box blue-win' : 'score-box';
            roundScoreContainer.appendChild(scoreBox);
        }
        
        const vs = document.createElement('span');
        vs.className = 'vs-text';
        vs.textContent = 'VS';
        roundScoreContainer.appendChild(vs);

        for (let i = 1; i <= 3; i++) {
            const scoreBox = document.createElement('div');
            scoreBox.className = roundState.redScore >= i ? 'score-box red-win' : 'score-box';
            roundScoreContainer.appendChild(scoreBox);
        }
        
        scoreboardBlueTeam.innerHTML = '';
        scoreboardRedTeam.innerHTML = '';

        const sortedPlayers = [...allCharacters].sort((a, b) => b.score - a.score);

        sortedPlayers.forEach(p => {
            const playerRow = document.createElement('div');
            playerRow.className = 'scoreboard-player-row';
            playerRow.innerHTML = `
                <div>${p.name}</div>
                <div class="col-stat">${p.kills}</div>
                <div class="col-stat">${p.assists}</div>
                <div class="col-stat">${p.plants}</div>
                <div class="col-stat">${p.defuses}</div>
                <div class="col-stat">${p.score}</div>
            `;
            if (p.team === 1) {
                scoreboardBlueTeam.appendChild(playerRow);
            } else {
                scoreboardRedTeam.appendChild(playerRow);
            }
        });
        showScreen('scoreboard-overlay');
    }
    
    function drawBombSites(g = ctx) { bombSites.forEach(site => { g.save(); g.beginPath(); g.arc(site.x, site.y, site.radius, 0, Math.PI * 2); g.strokeStyle = bomb.siteId === site.id && bomb.active ? 'rgba(255, 80, 80, 0.9)' : 'rgba(255,255,255,0.4)'; g.lineWidth = 4; g.setLineDash([10, 10]); g.stroke(); g.fillStyle = bomb.siteId === site.id && bomb.active ? 'rgba(255, 80, 80, 0.2)' : 'rgba(255,255,255,0.1)'; g.fill(); g.fillStyle = 'rgba(255,255,255,0.8)'; g.font = 'bold 48px Courier New'; g.textAlign = 'center'; g.textBaseline = 'middle'; g.fillText(site.id, site.x, site.y); g.restore(); }); }
    function drawBomb(x, y, isPlanted, isFlashing, g = ctx) { const color = isPlanted && isFlashing ? 'red' : '#333'; g.fillStyle = color; g.fillRect(x - 10, y - 5, 20, 10); g.fillStyle = '#555'; g.fillRect(x - 2, y - 8, 4, 3); }
    
    function isObjectVisible(rect, polygon) {
        if (!polygon || polygon.length === 0) return false;
        
        // Check if any corner of the rectangle is inside the polygon
        const corners = [
            { x: rect.x, y: rect.y },
            { x: rect.x + rect.w, y: rect.y },
            { x: rect.x, y: rect.y + rect.h },
            { x: rect.x + rect.w, y: rect.y + rect.h }
        ];

        for (const corner of corners) {
            if (isPointInPolygon(corner, polygon)) return true;
        }

        // Check if any polygon vertex is inside the rectangle
        for (const vertex of polygon) {
            if (vertex.x >= rect.x && vertex.x <= rect.x + rect.w &&
                vertex.y >= rect.y && vertex.y <= rect.y + rect.h) {
                return true;
            }
        }
        
        return false;
    }
    
    function drawBombItem(g = ctx, visibilityPolygon) {
        if (bombItem.isCarried || bomb.planted || !isObjectVisible({x: bombItem.x - 10, y: bombItem.y - 5, w: 20, h: 10}, visibilityPolygon)) return;
        drawBomb(bombItem.x, bombItem.y, false, false, g);
    }

    function drawBombObject(g = ctx, visibilityPolygon) {
        if (!bomb.planted || !bomb.active || !isObjectVisible({x: bomb.x - 10, y: bomb.y - 5, w: 20, h: 10}, visibilityPolygon)) return;
        const isFlashing = Math.floor(performance.now() / (500 - bomb.timer * 8)) % 2 === 0;
        drawBomb(bomb.x, bomb.y, true, isFlashing, g);
    }
    function drawDesertBackground(g = ctx) { if(!mapWidth || !mapHeight) return; const baseGradient = g.createRadialGradient(mapCenter.x, mapCenter.y, mapHeight * 0.1, mapCenter.x, mapCenter.y, mapHeight); baseGradient.addColorStop(0, '#E7D3A1'); baseGradient.addColorStop(1, '#CDBA96'); g.fillStyle = baseGradient; g.fillRect(0,0,mapWidth, mapHeight); dunes.forEach(dune => { g.save(); g.translate(dune.x + 8, dune.y + 6); g.rotate(dune.rotation); g.scale(dune.radiusX, dune.radiusY); g.beginPath(); g.arc(0, 0, 1, 0, Math.PI * 2); g.fillStyle = dune.shadowColor; g.fill(); g.restore(); }); dunes.forEach(dune => { g.save(); g.beginPath(); g.translate(dune.x, dune.y); g.rotate(dune.rotation); g.scale(dune.radiusX, dune.radiusY); g.arc(0, 0, 1, 0, Math.PI * 2); g.fillStyle = dune.color; g.fill(); g.restore(); }); sandSpecks.forEach(s => { if (s.type === 'circle') { drawCircle(s.x, s.y, s.r, s.c, g) } else { g.beginPath(); g.moveTo(s.x, s.y); g.lineTo(s.x + 1 + Math.random() * 2, s.y); g.strokeStyle = s.c; g.stroke(); } }); const lightGradient = g.createRadialGradient(mapCenter.x, mapCenter.y, mapHeight * 0.2, mapCenter.x, mapCenter.y, mapHeight * 1.5); lightGradient.addColorStop(0, 'rgba(255, 245, 230, 0.02)'); lightGradient.addColorStop(1, 'rgba(0, 0, 0, 0.05)'); g.fillStyle = lightGradient; g.fillRect(0, 0, mapWidth, mapHeight); }
    
    function drawGame(timestamp) {
        let cameraTarget = allCharacters.find(c => c.id === spectatingId || (c.id === 'player' && !spectatingId)) || { x: mapCenter.x, y: mapCenter.y };
        const player = allCharacters.find(c => c.id === 'player');
        
        // Define all boundaries for LOS calculation
        const allSegments = losSegments.concat([
            { p1: {x:0, y:0}, p2: {x:mapWidth, y:0} },
            { p1: {x:mapWidth, y:0}, p2: {x:mapWidth, y:mapHeight} },
            { p1: {x:mapWidth, y:mapHeight}, p2: {x:0, y:mapHeight} },
            { p1: {x:0, y:mapHeight}, p2: {x:0, y:0} }
        ]);

        // Calculate the polygon of visibility from the character's perspective
        const visibilityPolygon = calculateVisibility(cameraTarget, allSegments);
        
        // Find all crates that are touched by the light and have line of sight
        const visibleCrates = [];
        const lightCircle = { x: cameraTarget.x, y: cameraTarget.y, radius: lightRadius };
        for (const obs of obstacles) {
            if (obs.type === 'crate') {
                if (intersectsCircle(obs, lightCircle)) {
                    const corners = [
                        { x: obs.x, y: obs.y, ownerId: obs.id },
                        { x: obs.x + obs.w, y: obs.y, ownerId: obs.id },
                        { x: obs.x, y: obs.y + obs.h, ownerId: obs.id },
                        { x: obs.x + obs.w, y: obs.y + obs.h, ownerId: obs.id }
                    ];
                    let hasLosToCorner = false;
                    for(const corner of corners) {
                        if(hasLineOfSight(cameraTarget, corner)) {
                            hasLosToCorner = true;
                            break;
                        }
                    }
                    if(hasLosToCorner) {
                        visibleCrates.push(obs);
                    }
                }
            }
        }
        
        // --- STEP 1: Draw the full scene to the main canvas ---
        ctx.save();
        ctx.fillStyle = 'black'; // A black background ensures no gaps if canvas is larger than map
        ctx.fillRect(0, 0, canvasWidth, canvasHeight);
        ctx.translate(canvasWidth / 2, canvasHeight / 2);
        ctx.scale(cameraZoom, cameraZoom);
        ctx.translate(-cameraTarget.x, -cameraTarget.y);
        
        // Draw all game world elements
        drawDesertBackground(ctx);
        drawFloors(ctx);
        drawWalls(ctx);
        drawBombSites(ctx);
        obstacles.forEach(obs => {
            if (obs.type === 'crate') drawCrate(obs, ctx);
        });
        drawBombItem(ctx, visibilityPolygon);
        drawBombObject(ctx, visibilityPolygon);
        
        allCharacters.forEach(char => drawCharacter(char, ctx, cameraTarget, player));
        bullets.forEach(b => drawCircle(b.x, b.y, bulletRadius, b.color, ctx));
        particles.forEach(p => { 
            ctx.globalAlpha = p.alpha; 
            drawCircle(p.x, p.y, p.radius, p.color, ctx); 
            ctx.globalAlpha = 1;
        });
        ctx.restore(); // Restore main canvas transformations

        // --- STEP 2: Prepare the fog/light layer on the off-screen canvas ---
        
        // Start with a clean fog canvas
        fogCtx.clearRect(0, 0, canvasWidth, canvasHeight);
        
        // Fill the entire fog canvas with a semi-transparent black. This will be the "dimmed" area.
        fogCtx.fillStyle = 'rgba(0,0,0,0.6)';
        fogCtx.fillRect(0, 0, canvasWidth, canvasHeight);
        
        // Erase the main visibility polygon from the fog
        if (visibilityPolygon.length > 0) {
            fogCtx.save();
            fogCtx.translate(canvasWidth / 2, canvasHeight / 2);
            fogCtx.scale(cameraZoom, cameraZoom);
            fogCtx.translate(-cameraTarget.x, -cameraTarget.y);
            fogCtx.globalCompositeOperation = 'destination-out';
            fogCtx.beginPath();
            fogCtx.moveTo(visibilityPolygon[0].x, visibilityPolygon[0].y);
            for (let i = 1; i < visibilityPolygon.length; i++) {
                fogCtx.lineTo(visibilityPolygon[i].x, visibilityPolygon[i].y);
            }
            fogCtx.closePath();
            fogCtx.fillStyle = 'white';
            fogCtx.fill();
            fogCtx.restore();
        }

        // Now, also erase the full rectangles for any visible crates
        if (visibleCrates.length > 0) {
            fogCtx.save();
            fogCtx.translate(canvasWidth / 2, canvasHeight / 2);
            fogCtx.scale(cameraZoom, cameraZoom);
            fogCtx.translate(-cameraTarget.x, -cameraTarget.y);
            fogCtx.globalCompositeOperation = 'destination-out';
            visibleCrates.forEach(crate => {
                fogCtx.fillRect(crate.x, crate.y, crate.w, crate.h);
            });
            fogCtx.restore();
        }

        // --- STEP 3: Draw the prepared fog layer onto the main canvas ---
        ctx.drawImage(fogCanvas, 0, 0);

        // --- STEP 4: Draw UI on top of everything ---
        if (gameSettings.useJoysticks) { 
            if (movementJoystick && movementJoystick.isActive) movementJoystick.draw(ctx);
            if (shootingJoystick && shootingJoystick.isActive) shootingJoystick.draw(ctx);
        }
        updateUI();
        drawMinimap();
    }
    
    function updateUI() {
        const player = allCharacters.find(c => c.id === 'player');
        if (player) {
            ammoCounterElement.textContent = `${player.isReloading ? 'Reloading...' : player.ammo + ' / ' + player.clipSize}`;
            
            // Update Player Info Panel
            playerNameDisplay.textContent = player.name;
            const hpPercent = Math.max(0, player.hp / initialHitPoints) * 100;
            playerHealthBar.style.width = `${hpPercent}%`;

        }
        
        tdmUiContainer.style.display = (gameMode === '3v3' || gameMode === '1v1') ? 'flex' : 'none';
        
        if (plantBombButton) plantBombButton.style.display = 'none';

        if (gameMode === '3v3' || gameMode === '1v1') {
            updateTeamStatusUI();

            if (bomb.planted && bomb.active) {
                // Bomb is planted, show bomb countdown in the main timer bar
                const timeLeft = BOMB_TIMER_DURATION - bomb.timer;
                gameTimerBar.style.color = '#FF4747'; // Red color
                gameTimerBar.textContent = Math.ceil(timeLeft);
            } else {
                // No bomb planted, show normal round timer
                gameTimerBar.style.color = '#FFF8DC'; // Default color
                const minutes = Math.floor(Math.max(0, gameState.gameTimer) / 60);
                const seconds = Math.floor(Math.max(0, gameState.gameTimer) % 60);
                gameTimerBar.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
            }

            // Show or hide "Bomb Planted" text based on its timer
            if (roundStartTextTimer > 0 && player) {
                gameEventText.style.display = 'block';
                gameEventText.style.color = '#FFF8DC'; // White
                gameEventText.textContent = player.team === roundState.attackingTeam ? 'Destroy The Objectives' : 'Defend The Objectives';
            } else if (bombPlantedTextTimer > 0) {
                gameEventText.style.display = 'block';
                gameEventText.style.color = '#FF4747'; // Red
                gameEventText.textContent = 'Bomb Planted';
            } else {
                gameEventText.style.display = 'none';
            }


            blueScoreDisplay.textContent = roundState.blueScore;
            redScoreDisplay.textContent = roundState.redScore;
            
            const playerTeamRole = roundState.attackingTeam === player?.team ? 'ATTACKER' : 'DEFENDER';
            teamRoleDisplay.textContent = playerTeamRole;
            
            if(player?.hasBomb) {
                if(bombIconContainer) bombIconContainer.style.display = 'block';
                const site = nearActiveBombSite(player);
                if (site) {
                    if(plantBombButton) plantBombButton.style.display = 'block';
                    if (player.isPlanting) {
                        const plantProgress = (player.plantTimer / BOMB_PLANT_TIME) * 100;
                        plantBombButton.style.background = `linear-gradient(to right, #6c757d ${plantProgress}%, #4a4a4a ${plantProgress}%)`;
                        plantBombButton.textContent = 'Planting...';
                    } else {
                        plantBombButton.style.background = '#4a4a4a';
                        plantBombButton.textContent = 'Hold to Plant';
                    }
                }
            } else {
                if (bombIconContainer) bombIconContainer.style.display = 'none';
            }
        }
        spectateControls.style.display = spectatingId ? 'flex' : 'none';
    }

    function initializeCharacters() {
        allCharacters = [];
        let aiCounter = 1;
        const team1Colors = ['#4682B4', '#6495ED', '#87CEEB'];
        const team2Colors = ['#DC143C', '#B22222', '#8B0000'];
        
        const leftSpawns = tdmSpawnPoints.filter(p => p.x < mapCenter.x);
        const rightSpawns = tdmSpawnPoints.filter(p => p.x > mapCenter.x);
        
        const getUniqueSpawn = (spawnList) => {
            if (spawnList.length === 0) return { x: mapCenter.x, y: mapCenter.y };
            return spawnList.splice(Math.floor(Math.random() * spawnList.length), 1)[0];
        };

        const team1IsAttacker = roundState.attackingTeam === 1;

        const team1SpawnList = [...(team1IsAttacker ? leftSpawns : rightSpawns)];
        const team2SpawnList = [...(team1IsAttacker ? rightSpawns : leftSpawns)];
        
        if (gameMode === '1v1') {
            allCharacters.push(createCharacter({id:'player', name:'You', team:1, color:team1Colors[0], ...getUniqueSpawn(team1SpawnList)}));
            allCharacters.push(createCharacter({id:'enemy1', name: `AI ${aiCounter++}`, team:2, color:team2Colors[0], ...getUniqueSpawn(team2SpawnList)}));
        } else { // 3v3
            allCharacters.push(createCharacter({id:'player', name:'You', team:1, color:team1Colors[0], ...getUniqueSpawn(team1SpawnList)}));
            allCharacters.push(createCharacter({id:'ally1',  name:`AI ${aiCounter++}`, team:1, color:team1Colors[1], ...getUniqueSpawn(team1SpawnList)}));
            allCharacters.push(createCharacter({id:'ally2',  name:`AI ${aiCounter++}`, team:1, color:team1Colors[2], ...getUniqueSpawn(team1SpawnList)}));
            
            allCharacters.push(createCharacter({id:'enemy1', name:`AI ${aiCounter++}`, team:2, color:team2Colors[0], ...getUniqueSpawn(team2SpawnList)}));
            allCharacters.push(createCharacter({id:'enemy2', name:`AI ${aiCounter++}`, team:2, color:team2Colors[1], ...getUniqueSpawn(team2SpawnList)}));
            allCharacters.push(createCharacter({id:'enemy3', name:`AI ${aiCounter++}`, team:2, color:team2Colors[2], ...getUniqueSpawn(team2SpawnList)}));
        }
    }
    
    function startRound() {
        inRoundTransition = false;
        spectatingId = null;
        spectatablePlayers = [];
        isRoundActive = false;
        bullets = [];
        floatingTexts = [];
        particles = [];
        bomb = { active: false, planted: false, timer: 0, siteId: null, plantedByTeam: null, plantedById: null };
        bombItem.isCarried = false;
        bombPlantedTextTimer = 0;
        roundStartTextTimer = 5; 
        if (gameState) gameState.gameTimer = 120; 

        roundState.roundNumber++;
        roundState.attackingTeam = (roundState.roundNumber % 2 === 1) ? 1 : 2; 

        const playerStats = allCharacters.map(p => ({ id: p.id, kills: p.kills, assists: p.assists, plants: p.plants, defuses: p.defuses, score: p.score }));

        initializeCharacters();

        allCharacters.forEach(p => {
            const stats = playerStats.find(s => s.id === p.id);
            if (stats) {
                p.kills = stats.kills;
                p.assists = stats.assists;
                p.plants = p.plants;
                p.defuses = stats.defuses;
                p.score = stats.score;
            }
        });
        
        ammoCounterElement.style.color = '#FFF8DC';

        const attackers = allCharacters.filter(p => p.team === roundState.attackingTeam);
        if(attackers.length > 0) {
            const attackerSpawnX = attackers.reduce((sum, p) => sum + p.x, 0) / attackers.length;
            const attackerSpawnY = attackers.reduce((sum, p) => sum + p.y, 0) / attackers.length;
            const offset = (attackerSpawnX < mapCenter.x) ? 120 : -120;
            bombItem.x = attackerSpawnX + offset;
            bombItem.y = attackerSpawnY;
        }
        
        if (roundState.roundNumber === 1) {
            displayMatchupScreen();
        } else {
            displayRoundCountdown();
        }
    }

    function displayMatchupScreen() {
        showScreen('matchup-screen');
        const matchupBgCtx = matchupBgCanvas.getContext('2d');
        matchupBgCanvas.width = window.innerWidth;
        matchupBgCanvas.height = window.innerHeight;
        matchupBgCtx.drawImage(offscreenMinimapCanvas, 0, 0, matchupBgCanvas.width, matchupBgCanvas.height);

        matchupBlueTeamContainer.innerHTML = '';
        matchupRedTeamContainer.innerHTML = '';

        const createPlayerCard = (character) => {
            const card = document.createElement('div');
            card.className = 'matchup-player-card';

            const portraitCanvas = document.createElement('canvas');
            portraitCanvas.width = 60;
            portraitCanvas.height = 60;
            drawPlayerPortrait(portraitCanvas, character);

            const nameDiv = document.createElement('div');
            nameDiv.className = 'player-name';
            nameDiv.textContent = character.name;

            card.appendChild(portraitCanvas);
            card.appendChild(nameDiv);
            return card;
        };

        allCharacters.forEach(char => {
            if (char.team === 1) {
                matchupBlueTeamContainer.appendChild(createPlayerCard(char));
            } else {
                matchupRedTeamContainer.appendChild(createPlayerCard(char));
            }
        });

        setTimeout(() => {
            displayRoundCountdown();
        }, 4000); 
    }
    
    function displayRoundCountdown() {
        showScreen('game'); 
        
        let count = 2;
        roundCountdownElement.style.display = 'block';
        roundCountdownElement.textContent = count;
        
        const countdownInterval = setInterval(() => {
            count--;
            if (count > 0) {
                roundCountdownElement.textContent = count;
            } else {
                clearInterval(countdownInterval);
                roundCountdownElement.style.display = 'none';
                isRoundActive = true;
                lastTimestamp = performance.now(); // Reset timer to start of active play
            }
        }, 1000);
        
        // Start drawing the game immediately, even during countdown
        lastTimestamp = performance.now();
        if (animationFrameId) cancelAnimationFrame(animationFrameId);
        animationFrameId = requestAnimationFrame(gameLoop);
    }


    function drawFullMapToOffscreenCanvas() {
        if (!mapWidth || !mapHeight) return;
        offscreenMinimapCanvas = document.createElement('canvas');
        offscreenMinimapCanvas.width = mapWidth;
        offscreenMinimapCanvas.height = mapHeight;
        offscreenMinimapCtx = offscreenMinimapCanvas.getContext('2d');
        
        drawDesertBackground(offscreenMinimapCtx);
        drawFloors(offscreenMinimapCtx);
        drawWalls(offscreenMinimapCtx);
        obstacles.forEach(obs => { if (obs.type === 'crate') drawCrate(obs, offscreenMinimapCtx); });
        drawBombSites(offscreenMinimapCtx);
    }

    function startGame(mode) {
        isGameOver = false;
        gameMode = mode;
        
        generateMapLayout();
        generateSandPattern();
        drawFullMapToOffscreenCanvas(); 

        roundState = { blueScore: 0, redScore: 0, roundNumber: 0 };
        gameState = { gameMode: mode, gameTimer: 120, currentRadius: Infinity };
        
        startRound();
    }
    
    function endGame(winner) {
        if (isGameOver) return;
        isGameOver = true;
        
        finalWinnerTitleElement.textContent = `${winner} Wins!`;
        const finalScoreContainer = document.getElementById('final-match-score');
        finalScoreContainer.innerHTML = ''; // Clear previous content
        finalScoreContainer.style.display = 'flex';
        
        const roundsToWin = gameMode === '1v1' ? 3 : 3;

        // Blue Score
        for(let i=1; i<=roundsToWin; i++){
            const scoreBox = document.createElement('div');
            scoreBox.className = roundState.blueScore >= i ? 'score-box blue-win' : 'score-box';
            finalScoreContainer.appendChild(scoreBox);
        }

        const vs = document.createElement('span');
        vs.className = 'vs-text';
        vs.textContent = 'VS';
        finalScoreContainer.appendChild(vs);

        // Red Score
        for(let i=1; i<=roundsToWin; i++){
            const scoreBox = document.createElement('div');
            scoreBox.className = roundState.redScore >= i ? 'score-box red-win' : 'score-box';
            finalScoreContainer.appendChild(scoreBox);
        }
        
        showScreen('game-over');
    }
    
    function leaveMatch() {
        isGameOver = true;
        isPaused = false;
        inGameMenuElement.style.display = 'none';
        if (animationFrameId) {
            cancelAnimationFrame(animationFrameId);
            animationFrameId = null;
        }
        showScreen('welcome-screen');
        mainMenuView.style.display = 'block';
        singlePlayerMenuView.style.display = 'none';
    }
    
    const allScreenElements = {
        'welcome-screen': welcomeScreenElement,
        'settings-menu': settingsMenuElement,
        'in-game-menu': inGameMenuElement,
        'scoreboard-overlay': scoreboardOverlay,
        'game-over': gameOverElement,
        'game': gameUiElement,
        'matchup-screen': matchupScreenElement
    };

    function showScreen(screenId) {
        // Special handling for overlays
        if(screenId === 'scoreboard-overlay' || screenId === 'in-game-menu'){
            allScreenElements[screenId].style.display = 'flex';
            if (screenId === 'in-game-menu') isPaused = true;
            return;
        }

        Object.values(allScreenElements).forEach(el => { if(el) el.style.display = 'none'; });
        gameCanvas.style.display = 'none';

        stopWelcomeAnimation();
        
        if (screenId === 'game') {
            gameUiElement.style.display = 'block';
            gameCanvas.style.display = 'block';
        } else if (allScreenElements[screenId]) {
            allScreenElements[screenId].style.display = 'flex';
             if (screenId === 'welcome-screen') {
                 allScreenElements[screenId].style.flexDirection = 'column';
                 allScreenElements[screenId].style.alignItems = 'center';
                 allScreenElements[screenId].style.justifyContent = 'center';
                 startWelcomeAnimation();
             }
        }
    }

    function gameLoop(timestamp) {
        if (isGameOver || inRoundTransition || isPaused) {
             if(isGameOver && animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
            return; 
        }

        const now = performance.now();
        const deltaTime = isRoundActive ? (now - (lastTimestamp || now)) / 1000 : 0;
        lastTimestamp = now;

        try {
            if(isRoundActive) {
                updateCharacters(deltaTime);
                updateBullets(deltaTime);
                updateGameTimers(deltaTime);
                updateParticles(deltaTime);
                checkWinCondition();
            }
            drawGame(timestamp);
            if (!inRoundTransition && !isGameOver) animationFrameId = requestAnimationFrame(gameLoop);
        } catch(e) {
            console.error("CRITICAL Error in game loop:", e);
            isGameOver = true;
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
        }
    }

    function updateBullets(deltaTime) {
        const cameraTarget = allCharacters.find(c => c.id === spectatingId || (c.id === 'player' && !spectatingId)) || { x: mapCenter.x, y: mapCenter.y };

        for (let i = bullets.length - 1; i >= 0; i--) {
            const b = bullets[i];
            b.x += b.dx;
            b.y += b.dy;

            let hit = false;

            // Remove bullets that go outside the light radius
            if (distSq(cameraTarget.x, cameraTarget.y, b.x, b.y) > lightRadius * lightRadius) {
                bullets.splice(i, 1);
                continue;
            }

            for(const obs of obstacles) {
                if(b.x > obs.x && b.x < obs.x + obs.w && b.y > obs.y && b.y < obs.y + obs.h) {
                    hit = true;
                    createParticles(b.x, b.y, 5, '#888');
                    obs.hp -= bulletDamage;
                    if (obs.hp <= 0) {
                        // When an obstacle is destroyed, remove it and its line-of-sight segments
                        obstacles = obstacles.filter(o => o.id !== obs.id);
                        losSegments = losSegments.filter(w => w.ownerId !== obs.id);
                    }
                    break;
                }
            }
            if(hit) { bullets.splice(i, 1); continue; }

            for (const target of allCharacters) {
                if (target.hp > 0 && target.team !== b.team && distSq(b.x, b.y, target.x, target.y) < playerRadius * playerRadius) {
                    const shooter = allCharacters.find(c => c.id === b.owner);
                    applyDamageAndHandleKill(target, shooter, bulletDamage);
                    hit = true;
                    break;
                }
            }
            if (hit || b.x < 0 || b.x > mapWidth || b.y < 0 || b.y > mapHeight) {
                bullets.splice(i, 1);
            }
        }
    }

    function updateFloatingTexts() {}
    function updatePowerUps() {}
    function updateParticles(deltaTime) {
        for (let i = particles.length - 1; i >= 0; i--) {
            const p = particles[i];
            p.x += p.dx; p.y += p.dy;
            p.lifetime--;
            p.alpha = p.lifetime / 40;
            if (p.lifetime <= 0) particles.splice(i, 1);
        }
    }
    
    function resolveMovementWithCollision(character, dx, dy) {
        // Move on X axis
        character.x += dx;

        // Check for X-axis collisions
        obstacles.forEach(obs => {
            if (character.x + character.radius > obs.x &&
                character.x - character.radius < obs.x + obs.w &&
                character.y + character.radius > obs.y &&
                character.y - character.radius < obs.y + obs.h) {
                if (dx > 0) { // Moving right
                    character.x = obs.x - character.radius;
                } else if (dx < 0) { // Moving left
                    character.x = obs.x + obs.w + character.radius;
                }
            }
        });

        // Move on Y axis
        character.y += dy;

        // Check for Y-axis collisions
        obstacles.forEach(obs => {
            if (character.x + character.radius > obs.x &&
                character.x - character.radius < obs.x + obs.w &&
                character.y + character.radius > obs.y &&
                character.y - character.radius < obs.y + obs.h) {
                if (dy > 0) { // Moving down
                    character.y = obs.y - character.radius;
                } else if (dy < 0) { // Moving up
                    character.y = obs.y + obs.h + character.radius;
                }
            }
        });

        character.x = Math.max(character.radius, Math.min(mapWidth - character.radius, character.x));
        character.y = Math.max(character.radius, Math.min(mapHeight - character.radius, character.y));
    }
    
    function drawCrate(crate, g = ctx) {
        const x = crate.x;
        const y = crate.y;
        const w = crate.w;
        const h = crate.h;

        const baseColor = '#9A6A42';
        const shadowColor = '#6F4E2F';
        const highlightColor = '#B58A5F';
        
        g.fillStyle = baseColor;
        g.fillRect(x, y, w, h);

        g.fillStyle = shadowColor;
        g.beginPath();
        g.moveTo(x, y + h);
        g.lineTo(x + 5, y + h - 5);
        g.lineTo(x + w, y + h - 5);
        g.lineTo(x + w, y + h);
        g.closePath();
        g.fill();

        g.beginPath();
        g.moveTo(x + w, y);
        g.lineTo(x + w - 5, y + 5);
        g.lineTo(x + w - 5, y + h);
        g.lineTo(x + w, y + h);
        g.closePath();
        g.fill();
        
        g.strokeStyle = shadowColor;
        g.lineWidth = 2;
        g.beginPath();
        g.moveTo(x, y + h / 2);
        g.lineTo(x + w, y + h / 2);
        g.stroke();

        g.strokeStyle = highlightColor;
        g.lineWidth = 1;
        g.beginPath();
        g.moveTo(x, y + 1);
        g.lineTo(x + w, y + 1);
        g.stroke();
    }
    
    function drawWalls(g = ctx){obstacles.forEach(obs=>{if(obs.type==='wall'){g.fillStyle='black';g.fillRect(obs.x,obs.y,obs.w,obs.h);if(!obs.isEnclosed){g.strokeStyle='black';g.lineWidth=wallThickness;g.beginPath();if(obs.borders.top)g.moveTo(obs.x,obs.y),g.lineTo(obs.x+obs.w,obs.y);if(obs.borders.bottom)g.moveTo(obs.x,obs.y+obs.h),g.lineTo(obs.x+obs.w,obs.y+obs.h);if(obs.borders.left)g.moveTo(obs.x,obs.y),g.lineTo(obs.x,obs.y+obs.h);if(obs.borders.right)g.moveTo(obs.x+obs.w,obs.y),g.lineTo(obs.x+obs.w,obs.y+obs.h);g.stroke();g.strokeStyle=wallColor;g.lineWidth=wallThickness-4;g.beginPath();if(obs.borders.top)g.moveTo(obs.x,obs.y),g.lineTo(obs.x+obs.w,obs.y);if(obs.borders.bottom)g.moveTo(obs.x,obs.y+obs.h),g.lineTo(obs.x+obs.w,obs.y+obs.h);if(obs.borders.left)g.moveTo(obs.x,obs.y),g.lineTo(obs.x,obs.y+obs.h);if(obs.borders.right)g.moveTo(obs.x+obs.w,obs.y),g.lineTo(obs.x+obs.w,obs.y+obs.h);g.stroke();}}});}

    function drawFloors(g = ctx){if(floorTiles.length===0)return;g.fillStyle=floorColor;floorTiles.forEach(tile=>g.fillRect(tile.x,tile.y,tile.w,tile.h));}
    
    function drawCharacter(character, g = ctx, cameraTarget, player) {
        if (character.hp <= 0) return;

        let isVisible = false;
        
        if (distSq(cameraTarget.x, cameraTarget.y, character.x, character.y) <= lightRadius * lightRadius) {
            if (hasLineOfSight(cameraTarget, character)) {
                isVisible = true;
            }
        }

        if(isVisible){
            drawCircle(character.x+3,character.y+3,character.radius,'rgba(0,0,0,0.2)', g);
            g.save();
            g.translate(character.x,character.y);
            g.rotate(character.aimAngle);
            g.fillStyle='#222';
            g.fillRect(character.radius, -3, 8, 6);
            g.restore();
            drawCircle(character.x,character.y,character.radius,character.color, g);
            
            // Only draw HP bar for teammates (and not the player)
            if (player && character.id !== player.id && character.team === player.team) {
                drawHPBar(character.x,character.y,character.hp,initialHitPoints,'#4CAF50', g);
            }
            
            g.fillStyle = 'white';
            g.textAlign = 'center';
            g.font = '12px Courier New';
            g.fillText(character.name, character.x, character.y + character.radius + 12);
        }
    }

    function drawHPBar(x, y, currentHP, maxHP, radius, color, g = ctx) { const barWidth = radius*2; const barHeight = 5; const barX = x - radius; const barY = y - radius - barHeight - 5; g.fillStyle = '#555'; g.fillRect(barX, barY, barWidth, barHeight); const hpRatio = Math.max(0, currentHP/maxHP); g.fillStyle = color; g.fillRect(barX, barY, barWidth*hpRatio, barHeight);}
    function drawCircle(x, y, radius, color, g = ctx) { g.fillStyle = color; g.beginPath(); g.arc(x, y, radius, 0, Math.PI * 2); g.fill(); }
    
    function initialize() {
        threeVThreeButton.onclick = () => startGame('3v3');
        oneVOneButton.onclick = () => startGame('1v1');
        mainMenuSettingsButton.onclick = () => {
             previousView = 'welcome-screen';
             showScreen('settings-menu');
        };
        showSpMenuButton.onclick = () => {
            mainMenuView.style.display = 'none';
            singlePlayerMenuView.style.display = 'block';
        };
        spBackButton.onclick = () => {
            singlePlayerMenuView.style.display = 'none';
            mainMenuView.style.display = 'block';
        };
        backButton.onclick = () => { 
            settingsMenuElement.style.display = 'none';
            if (previousView === 'in-game-menu') {
                inGameMenuElement.style.display = 'flex';
            } else {
                showScreen('welcome-screen');
                mainMenuView.style.display = 'block';
                singlePlayerMenuView.style.display = 'none';
            }
        };
        joystickToggle.onchange = () => { gameSettings.useJoysticks = joystickToggle.checked; };
        playAgainButton.onclick = () => { showScreen('welcome-screen'); };
        
        inGameMenuButton.onclick = () => {
             inGameMenuElement.style.display = inGameMenuElement.style.display === 'flex' ? 'none' : 'flex';
        };
        resumeButton.onclick = () => {
            inGameMenuElement.style.display = 'none';
        };
        leaveMatchButton.onclick = leaveMatch;
        spectatePrevButton.onclick = () => cycleSpectator(-1);
        spectateNextButton.onclick = () => cycleSpectator(1);
        centerInfoBlock.onclick = () => {
            if(isRoundActive && !inRoundTransition){
                scoreboardOverlay.style.display = 'flex';
                showRoundScoreboard("Scoreboard");
            }
        };
        scoreboardOverlay.onclick = (e) => {
            if(e.target === scoreboardOverlay && !inRoundTransition) {
                 scoreboardOverlay.style.display = 'none';
            }
        };


        document.addEventListener('keydown', (event) => { 
            const key=event.key.toLowerCase(); 
            if(key in keysDown) keysDown[key]=true; 
            if(key===' ') event.preventDefault(); 
            if(key === 'escape' && !isGameOver && gameCanvas.style.display === 'block') {
                if (inGameMenuElement.style.display === 'flex') {
                    inGameMenuElement.style.display = 'none';
                }
            }
        });
        document.addEventListener('keyup', (event) => { const key=event.key.toLowerCase(); if(key in keysDown)keysDown[key]=false; });
        gameCanvas.addEventListener('mousedown', (e) => handlePointerDown(e));
        document.addEventListener('mousemove', (e) => handlePointerMove(e));
        document.addEventListener('mouseup', (e) => handlePointerUp(e));
        gameCanvas.addEventListener('touchstart', (e) => handlePointerDown(e));
        gameCanvas.addEventListener('touchmove', (e) => handlePointerMove(e));
        gameCanvas.addEventListener('touchend', (e) => handlePointerUp(e));
        gameCanvas.addEventListener('touchcancel', (e) => handlePointerUp(e));
        
        if (plantBombButton) {
            plantBombButton.addEventListener('mousedown', () => { isPlantingButtonHeld = true; });
            plantBombButton.addEventListener('mouseup', () => { isPlantingButtonHeld = false; });
            plantBombButton.addEventListener('mouseleave', () => { isPlantingButtonHeld = false; });
            plantBombButton.addEventListener('touchstart', (e) => { e.preventDefault(); isPlantingButtonHeld = true; });
            plantBombButton.addEventListener('touchend', (e) => { e.preventDefault(); isPlantingButtonHeld = false; });
        }
        
        // Initialize canvases
        gameCanvas.width = 800; gameCanvas.height = 600; 
        minimapCanvas.width = 150; minimapCanvas.height = 150;
        
        fogCanvas = document.createElement('canvas');
        fogCanvas.width = gameCanvas.width;
        fogCanvas.height = gameCanvas.height;
        fogCtx = fogCanvas.getContext('2d');

        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();
        showScreen('welcome-screen');
    }

    function handlePointerDown(e) {
        if (!gameSettings.useJoysticks) return;
        e.preventDefault();
        const touches = e.changedTouches || [e];
        const rect = gameCanvas.getBoundingClientRect();
        for(let i=0; i<touches.length; i++) {
            const touch = touches[i];
            const touchX = touch.clientX - rect.left;
            const touchY = touch.clientY - rect.top;
            if (touchX < canvasWidth / 2) {
                if(!movementJoystick) movementJoystick = new Joystick(touchX, touchY, 50, 25);
                movementJoystick.baseX = touchX; movementJoystick.baseY = touchY;
                movementJoystick.isActive = true; movementJoystick.touchId = touch.identifier; movementJoystick.update(touchX, touchY);
            } else {
                 if(!shootingJoystick) shootingJoystick = new Joystick(touchX, touchY, 50, 25);
                shootingJoystick.baseX = touchX; shootingJoystick.baseY = touchY;
                shootingJoystick.isActive = true; shootingJoystick.touchId = touch.identifier; shootingJoystick.update(touchX, touchY);
            }
        }
    }
    function handlePointerMove(e) {
        e.preventDefault();
        const rect = gameCanvas.getBoundingClientRect();
        const touches = e.changedTouches || [e];
        if (touches.length > 0) {
            mousePos.x = touches[0].clientX - rect.left;
            mousePos.y = touches[0].clientY - rect.top;
        }
        if (!gameSettings.useJoysticks) return;
        for(let i=0; i<touches.length; i++) {
            const touch = touches[i];
            const touchX = touch.clientX - rect.left;
            const touchY = touch.clientY - rect.top;
            if (movementJoystick && movementJoystick.isActive && movementJoystick.touchId === touch.identifier) {
                movementJoystick.update(touchX, touchY);
            }
            if (shootingJoystick && shootingJoystick.isActive && shootingJoystick.touchId === touch.identifier) {
                shootingJoystick.update(touchX, touchY);
            }
        }
    }
    function handlePointerUp(e) {
        if (!gameSettings.useJoysticks) return;
        e.preventDefault();
        const touches = e.changedTouches || [e];
        for(let i=0; i<touches.length; i++) {
            const touch = touches[i];
            if (movementJoystick && movementJoystick.touchId === touch.identifier) {
                movementJoystick.reset();
            }
            if (shootingJoystick && shootingJoystick.touchId === touch.identifier) {
                shootingJoystick.reset();
            }
        }
    }
    function resizeCanvas() {
        const containerRect = gameContainer.getBoundingClientRect();
        const aspectRatio = 800 / 600;
        let newWidth = containerRect.width;
        let newHeight = containerRect.width / aspectRatio;
        if (newHeight > containerRect.height) { newHeight = containerRect.height; newWidth = newHeight * aspectRatio; }
        gameCanvas.style.width = `${newWidth}px`; gameCanvas.style.height = `${newHeight}px`;
        canvasWidth = gameCanvas.width; canvasHeight = gameCanvas.height;

        if (fogCanvas) {
            fogCanvas.width = canvasWidth;
            fogCanvas.height = canvasHeight;
        }

        if (welcomeBgCanvas && welcomeScreenElement.style.display !== 'none') {
            const welcomeRect = welcomeScreenElement.getBoundingClientRect();
            welcomeBgCanvas.width = welcomeRect.width;
            welcomeBgCanvas.height = welcomeRect.height;
        }
    }

    // ---- START: Welcome Screen Animation ----
    function startWelcomeAnimation() {
        if (welcomeAnimFrameId) return; // Already running
        
        const welcomeRect = welcomeScreenElement.getBoundingClientRect();
        welcomeBgCanvas.width = welcomeRect.width;
        welcomeBgCanvas.height = welcomeRect.height;

        bgCircles = [];
        const team1Colors = ['#4682B4', '#6495ED', '#87CEEB'];
        const team2Colors = ['#DC143C', '#B22222', '#8B0000'];
        const allColors = team1Colors.concat(team2Colors);

        for (let i = 0; i < 10; i++) {
            bgCircles.push({
                x: Math.random() * welcomeBgCanvas.width,
                y: Math.random() * welcomeBgCanvas.height,
                radius: 10 + Math.random() * 10,
                color: allColors[i % allColors.length],
                dx: (Math.random() - 0.5) * 2,
                dy: (Math.random() - 0.5) * 2
            });
        }
        
        welcomeAnimationLoop();
    }
    
    function stopWelcomeAnimation() {
        if (welcomeAnimFrameId) {
            cancelAnimationFrame(welcomeAnimFrameId);
            welcomeAnimFrameId = null;
        }
    }
    
    function welcomeAnimationLoop() {
        welcomeBgCtx.clearRect(0, 0, welcomeBgCanvas.width, welcomeBgCanvas.height);
        
        bgCircles.forEach(circle => {
            // Move circle
            circle.x += circle.dx;
            circle.y += circle.dy;
            
            // Bounce off edges
            if (circle.x + circle.radius > welcomeBgCanvas.width || circle.x - circle.radius < 0) {
                circle.dx *= -1;
            }
            if (circle.y + circle.radius > welcomeBgCanvas.height || circle.y - circle.radius < 0) {
                circle.dy *= -1;
            }
            
            // Draw circle
            welcomeBgCtx.beginPath();
            welcomeBgCtx.arc(circle.x, circle.y, circle.radius, 0, Math.PI * 2);
            welcomeBgCtx.fillStyle = circle.color;
            welcomeBgCtx.globalAlpha = 0.5;
            welcomeBgCtx.fill();
            welcomeBgCtx.globalAlpha = 1;
        });
        
        welcomeAnimFrameId = requestAnimationFrame(welcomeAnimationLoop);
    }
    // ---- END: Welcome Screen Animation ----


    // ---- START: Line of Sight and Visibility Calculation Functions ----
    
    function intersectsCircle(rect, circle) {
        // Find the closest point on the rect to the circle's center
        const closestX = Math.max(rect.x, Math.min(circle.x, rect.x + rect.w));
        const closestY = Math.max(rect.y, Math.min(circle.y, rect.y + rect.h));

        // Calculate the distance between the closest point and the circle's center
        const distanceSq = distSq(circle.x, circle.y, closestX, closestY);

        // If the distance is less than the circle's radius squared, they intersect
        return distanceSq < (circle.radius * circle.radius);
    }
    
    function isPointInPolygon(point, polygon) {
        if (!polygon || polygon.length === 0) return false;
        let isInside = false;
        const x = point.x, y = point.y;
        for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
            const xi = polygon[i].x, yi = polygon[i].y;
            const xj = polygon[j].x, yj = polygon[j].y;
            const intersect = ((yi > y) !== (yj > y))
                && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
            if (intersect) isInside = !isInside;
        }
        return isInside;
    }
    
    function getIntersection(ray, segment) {
        const x1 = ray.p1.x, y1 = ray.p1.y;
        const x2 = ray.p2.x, y2 = ray.p2.y;
        const x3 = segment.p1.x, y3 = segment.p1.y;
        const x4 = segment.p2.x, y4 = segment.p2.y;

        const den = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
        if (den === 0) return null;

        const t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / den;
        const u = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / den;

        if (t > 0.00001 && u >= 0 && u <= 1) { 
            return {
                x: x1 + t * (x2 - x1),
                y: y1 + t * (y2 - y1)
            };
        }
        return null;
    }

    function calculateVisibility(origin, segments) {
        if (!origin || typeof origin.x !== 'number' || typeof origin.y !== 'number') return [];
        
        const allPoints = [];
        segments.forEach(seg => {
            allPoints.push(seg.p1, seg.p2);
        });

        const uniquePoints = allPoints.filter((p, i) =>
            allPoints.findIndex(a => a.x === p.x && a.y === p.y) === i
        );
        
        let allAngles = [];
        uniquePoints.forEach(point => {
            const angle = Math.atan2(point.y - origin.y, point.x - origin.x);
            allAngles.push(angle - 0.0001, angle, angle + 0.0001);
        });
        
        for (let i = 0; i < 360; i++) {
             allAngles.push(i * Math.PI / 180);
        }

        const visibilityPolygonPoints = [];
        allAngles.forEach(angle => {
            const ray = {
                p1: origin,
                p2: { x: origin.x + Math.cos(angle) * (lightRadius + 10), y: origin.y + Math.sin(angle) * (lightRadius + 10) }
            };

            let closestIntersection = null;
            let closestDistSq = Infinity;

            for (const segment of segments) {
                const intersection = getIntersection(ray, segment);
                if (intersection) {
                    const distSq = (intersection.x - origin.x)**2 + (intersection.y - origin.y)**2;
                    if (distSq < closestDistSq) {
                        closestDistSq = distSq;
                        closestIntersection = intersection;
                    }
                }
            }
            
            if (closestIntersection && closestDistSq <= lightRadius * lightRadius) {
                 visibilityPolygonPoints.push({x: closestIntersection.x, y: closestIntersection.y, angle: angle});
            } else {
                 visibilityPolygonPoints.push({
                    x: origin.x + Math.cos(angle) * lightRadius,
                    y: origin.y + Math.sin(angle) * lightRadius,
                    angle: angle
                 });
            }
        });

        visibilityPolygonPoints.sort((a, b) => a.angle - b.angle);
        
        return visibilityPolygonPoints;
    }
    // ---- END: Line of Sight and Visibility Functions ----

    function drawMinimap() {
        const cameraTarget = allCharacters.find(c => c.id === spectatingId || (c.id === 'player' && !spectatingId)) || null;
        if (!cameraTarget || !offscreenMinimapCanvas) return;

        const mmWidth = minimapCanvas.width;
        const mmHeight = minimapCanvas.height;
        minimapCtx.clearRect(0, 0, mmWidth, mmHeight);

        
        const zoomFactor = 4;
        const sourceViewWidth = mapWidth / zoomFactor;
        const sourceViewHeight = mapHeight / zoomFactor;
        let sx = cameraTarget.x - sourceViewWidth / 2;
        let sy = cameraTarget.y - sourceViewHeight / 2;

        sx = Math.max(0, Math.min(mapWidth - sourceViewWidth, sx));
        sy = Math.max(0, Math.min(mapHeight - sourceViewHeight, sy));

        minimapCtx.drawImage(offscreenMinimapCanvas, sx, sy, sourceViewWidth, sourceViewHeight, 0, 0, mmWidth, mmHeight);

        allCharacters.forEach(c => {
                if (c.hp <= 0) return;
            const isPlayerOrAlly = c.team === cameraTarget.team;
            const isVisibleEnemy = c.team !== cameraTarget.team && c.showOnMinimapTimer > 0;

            if (isPlayerOrAlly || isVisibleEnemy) {
                if (c.x >= sx && c.x <= sx + sourceViewWidth && c.y >= sy && c.y <= sy + sourceViewHeight) {
                    const drawX = (c.x - sx) * (mmWidth / sourceViewWidth);
                    const drawY = (c.y - sy) * (mmHeight / sourceViewHeight);

                    minimapCtx.fillStyle = c.id === 'player' ? 'lime' : (c.team === cameraTarget.team ? 'cyan' : 'red');
                    minimapCtx.beginPath();
                    minimapCtx.arc(drawX, drawY, 4, 0, 2 * Math.PI);
                    minimapCtx.fill();
                }
            }
        });
        
    }

    function showFullscreenMap() {
        if (isPaused || inRoundTransition || isGameOver || !offscreenMinimapCanvas) return;
        fullscreenMapOverlay.style.display = 'flex';
        drawFullscreenMap();
    }
    
    function hideFullscreenMap() {
        fullscreenMapOverlay.style.display = 'none';
    }

    function drawFullscreenMap() {
        if (!offscreenMinimapCanvas) return;
        const fullMapCtx = fullscreenMapCanvas.getContext('2d');
        const mapAspectRatio = mapWidth / mapHeight;
        
        let newWidth = window.innerWidth * 0.9;
        let newHeight = newWidth / mapAspectRatio;

        if (newHeight > window.innerHeight * 0.9) {
            newHeight = window.innerHeight * 0.9;
            newWidth = newHeight * mapAspectRatio;
        }

        fullscreenMapCanvas.width = newWidth;
        fullscreenMapCanvas.height = newHeight;

        fullMapCtx.drawImage(offscreenMinimapCanvas, 0, 0, newWidth, newHeight);

        const scaleX = newWidth / mapWidth;
        const scaleY = newHeight / mapHeight;

        allCharacters.forEach(c => {
            if (c.hp <= 0) return;
            fullMapCtx.fillStyle = c.id === 'player' ? 'lime' : (c.team === 1 ? 'cyan' : 'red');
            fullMapCtx.beginPath();
            fullMapCtx.arc(c.x * scaleX, c.y * scaleY, 5, 0, 2 * Math.PI);
            fullMapCtx.fill();
        });
    }

    function updateTeamStatusUI() {
        const player = allCharacters.find(c => c.id === 'player');
        if (!player) return;

        const blueTeam = allCharacters.filter(c => c.team === 1).sort((a,b) => a.id.localeCompare(b.id));
        const redTeam = allCharacters.filter(c => c.team === 2).sort((a,b) => a.id.localeCompare(b.id));

        const playerIsOnAttackingTeam = player.team === roundState.attackingTeam;
        
        blueTeamIconsContainer.innerHTML = '';
        redTeamIconsContainer.innerHTML = '';
        
        const createPortraitElement = (character, container, showBomb) => {
            if (!character) return;
            const wrapper = document.createElement('div');
            wrapper.className = 'player-portrait-wrapper';
            const canvas = document.createElement('canvas');
            const portraitSize = 40; // Adjusted size to prevent overflow
            canvas.width = portraitSize; 
            canvas.height = portraitSize;
            canvas.style.width = `${portraitSize}px`;
            canvas.style.height = `${portraitSize}px`;

            const bombText = document.createElement('div');
            bombText.style.color = 'orange';
            bombText.style.fontSize = '8px';
            bombText.style.fontWeight = 'bold';
            bombText.style.height = '10px'; 
            
            if (showBomb && character.hasBomb) {
                bombText.textContent = 'BOMB';
            }
            
            drawPlayerPortrait(canvas, character);
            wrapper.appendChild(canvas);
            wrapper.appendChild(bombText);
            container.appendChild(wrapper);
        };

        blueTeam.forEach(char => createPortraitElement(char, blueTeamIconsContainer, player.team === 1 && playerIsOnAttackingTeam));
        redTeam.forEach(char => createPortraitElement(char, redTeamIconsContainer, player.team === 2 && playerIsOnAttackingTeam));
    }
    
    function drawPlayerPortrait(canvas, player) {
        if (!canvas) return;
        const g = canvas.getContext('2d');
        g.clearRect(0, 0, canvas.width, canvas.height);
        
        if (!player) return;
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;
        const radius = canvas.width / 3;
        
        // Draw glow
        g.beginPath();
        g.arc(centerX, centerY, radius + 2, 0, 2 * Math.PI);
        g.fillStyle = player.team === 1 ? 'rgba(0, 150, 255, 0.3)' : 'rgba(255, 0, 0, 0.3)';
        g.fill();

        g.fillStyle = player.color;
        g.beginPath();
        g.arc(centerX, centerY, radius, 0, Math.PI * 2);
        g.fill();
        
        g.save();
        g.translate(centerX, centerY);
        g.rotate(0);
        const barrelLength = radius + 4;
        const barrelWidth = 3;
        g.fillStyle = '#222';
        
        g.fillRect(radius, -barrelWidth / 2, barrelLength, barrelWidth);

        g.restore();

        if (player.hp <= 0) {
            g.fillStyle = 'rgba(0,0,0,0.7)';
            g.fillRect(0,0,canvas.width,canvas.height);
        }
    }
   
    function updateSpectateList(player) {
        spectatablePlayers = []; // Reset the list
        const attackersAlive = allCharacters.some(c => c.team === roundState.attackingTeam && c.hp > 0);
        
        // Special case: Player is an attacker, whole team is dead, bomb is planted
        if (player.team === roundState.attackingTeam && !attackersAlive && bomb.planted) {
            spectatablePlayers = allCharacters.filter(c => c.team !== roundState.attackingTeam && c.hp > 0);
        } else {
            // Normal case: spectate your own living teammates
            spectatablePlayers = allCharacters.filter(c => c.team === player.team && c.hp > 0);
        }
        
        if (spectatablePlayers.length > 0) {
            spectatingId = spectatablePlayers[0].id;
        } else {
            // If no one is left to spectate on either team (e.g. last defender dies while you are spectating them)
            spectatingId = null;
        }
    }

    function cycleSpectator(direction) {
        if (!spectatingId || spectatablePlayers.length <= 1) return;

        const currentIndex = spectatablePlayers.findIndex(p => p.id === spectatingId);
        if (currentIndex === -1) return; // Should not happen

        let nextIndex = (currentIndex + direction + spectatablePlayers.length) % spectatablePlayers.length;
        spectatingId = spectatablePlayers[nextIndex].id;
    }
    initialize();
    
    });
</script>
</body>
</html>
