<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Circle Combat</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Russo+One&display=swap" rel="stylesheet">
    <style>
        /* General page styling */
        html, body {
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #1a1a1a;
            font-family: 'Russo One', sans-serif;
        }
        /* Container for the game canvas */
        #game-container { 
            position: relative; 
            width: 100%; 
            height: 100%;
        }
        /* General canvas styling */
        canvas { 
            display: none; 
            background-color: #CDBA96; 
            max-width: 100vw;
            max-height: 100vh;
            cursor: crosshair;
        }
        /* Styling for the main game canvas. Uses absolute positioning and transform for perfect centering. */
        #gameCanvas {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 1;
        }
        /* In-game UI overlay */
        #game-ui { position: absolute; top: 10px; left: 10px; right: 10px; bottom: 10px; display: none; pointer-events: none; z-index: 2; font-family: 'Courier New', Courier, monospace;}
        #minimap-container { position: absolute; top: 10px; left: 0; pointer-events: auto; }
        #minimap { width: 150px; height: 150px; border: 2px solid #D2B48C; background-color: rgba(42, 33, 28, 0.5); display: block; cursor: pointer; }
        
        #bottom-center-hud {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            align-items: center;
            gap: 20px;
        }
        #ammo-counter {
            color: #FFF8DC;
            font-size: 28px;
            font-weight: bold;
            text-shadow: 2px 2px 4px #000;
            pointer-events: auto;
            cursor: pointer;
        }
        #bomb-icon-container {
            display: none;
            pointer-events: auto;
        }
        
        #plant-bomb-button {
            position: absolute;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            padding: 10px 20px;
            border-radius: 8px;
            font-size: 20px;
            font-weight: bold;
            text-shadow: 1px 1px 2px #000;
            display: none;
            pointer-events: auto;
            border: 2px solid #3a3a3a;
            background-color: #4a4a4a;
            color: #FFF8DC;
            cursor: pointer;
            transition: background 0.1s;
        }
        #plant-bomb-button:hover {
            background-color: #5a5a5a;
        }

        .top-ui-container {
            position: absolute;
            top: 10px;
            left: 160px; 
            right: 160px;
            display: flex;
            flex-direction: row;
            align-items: center;
            justify-content: center; /* Center the middle block */
            pointer-events: auto;
            background-color: rgba(80, 70, 60, 0.8);
            border: 2px solid #D2B48C;
            border-radius: 8px;
            height: 65px;
            padding: 0 10px;
            cursor: pointer;
        }
        .team-icon-group {
            display: flex;
            gap: 10px;
            padding: 5px;
            text-align: center;
            align-items: center;
            height: 100%;
            flex: 1; /* Allow groups to take up space */
        }
        .player-portrait-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 100%;
            justify-content: center;
        }
        #blue-team-icons {
            justify-content: flex-end; /* Align to the right of the container */
            margin-right: 15px; /* Space from center */
        }
        #red-team-icons {
             justify-content: flex-start; /* Align to the left of the container */
             margin-left: 15px; /* Space from center */
        }
        #center-info-block {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2px;
            padding: 5px 10px;
            flex-shrink: 0; /* Prevent this block from shrinking */
        }
        #game-timer-bar {
            font-size: 18px; 
            font-weight: bold;
            color: #FFF8DC;
            text-align: center;
            white-space: nowrap;
        }
        #game-event-text {
            position: absolute;
            top: 85px; /* Below the top UI bar */
            left: 50%;
            transform: translateX(-50%);
            color: #FF4747;
            font-size: 16px;
            font-weight: bold;
            text-shadow: 1px 1px 2px #000;
            display: none; /* Hidden by default */
        }
        #team-role-display {
            font-size: 11px;
            color: #FFF8DC;
        }
        #team-score-bar {
            display: flex;
            width: 100%;
            justify-content: space-between;
        }
        .score-display {
            width: 50%;
            padding: 5px;
            font-size: 24px;
            font-weight: bold;
            text-align: center;
        }
        #blue-score-display {
            color: #E0EFFF;
        }
        #red-score-display {
            color: #FFD0D0;
        }
        .top-ui-container canvas {
            display: block;
            border-radius: 5px;
        }

        .menu-screen { 
            position: absolute; 
            top: 50%; 
            left: 50%; 
            transform: translate(-50%, -50%); 
            color: #FFF8DC; 
            text-align: center; 
            padding: 30px; 
            z-index: 10; 
            width: 80%; 
            max-width: 600px;
            overflow: hidden; 
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            box-sizing: border-box;
        }
        #welcome-screen {
            width: 100%;
            height: 100%;
            max-width: none;
            top: 0;
            left: 0;
            transform: none;
            border-radius: 0;
            padding: 0;
            background-color: #2a211c; 
            border: none;
            box-shadow: none;
        }
        #welcome-screen-content {
             width: 90%;
             max-width: 500px;
        }

        #round-scoreboard, #game-over, #in-game-menu, #settings-menu, #matchup-screen {
             background-color: rgba(42, 33, 28, 0.95);
             border: 2px solid #D2B48C;
             border-radius: 15px;
             height: auto;
             width: auto;
        }
        #matchup-screen {
            width: 100%;
            max-width: none;
            height: 100%;
            border-radius: 0;
            background-color: rgba(0,0,0,0.5);
        }

        #in-game-menu {
             max-width: 300px;
             pointer-events: auto;
        }
        .menu-screen h1, .menu-screen .menu-button {
            position: relative;
            z-index: 1; /* Ensure text/buttons are above background animations */
        }
        .menu-screen h1 { 
            font-family: 'Russo One', sans-serif;
            font-size: 56px; 
            margin-top: 0; 
            margin-bottom: 20px;
            color: #FFF8DC;
            text-shadow: 0 0 10px #D2B48C, 0 0 20px #D2B48C, 3px 3px 5px rgba(0,0,0,0.5);
        }
        #welcome-screen h1, #welcome-screen .menu-button {
             opacity: 0;
            animation: fadeInUp 0.8s forwards;
        }
        #welcome-screen h1 { animation-delay: 0.2s; }
        
        @keyframes fadeInUp {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .menu-button { 
            background-color: #4a4a4a;
            border: 2px solid #3a3a3a;
            color: #FFF8DC; 
            padding: 15px 30px; 
            font-size: 20px; 
            cursor: pointer; 
            display: block; 
            width: 100%; 
            margin-bottom: 15px; 
            text-transform: uppercase;
            transition: all 0.2s ease-out;
            border-radius: 8px;
            font-family: 'Russo One', sans-serif;
        }
        #welcome-screen .menu-button:nth-of-type(1) { animation-delay: 0.4s; }
        #welcome-screen .menu-button:nth-of-type(2) { animation-delay: 0.6s; }
        #welcome-screen .menu-button:nth-of-type(3) { animation-delay: 0.8s; }

        .menu-button:hover:not(:disabled) { 
            transform: scale(1.05); 
            box-shadow: 0 0 15px rgba(210, 180, 140, 0.6);
            background-color: #5a5a5a;
        }
        .menu-button:disabled { 
            background-color: #3a3a3a; 
            color: #6c757d; 
            cursor: not-allowed; 
            border-color: #2a2a2a;
        }
        .menu-button:disabled span {
            color: #888;
        }
        
        #dune-bg {
            position: absolute;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            z-index: -1;
            border-radius: 15px;
            overflow: hidden;
        }
        #dune-bg::before, #dune-bg::after {
            content: '';
            position: absolute;
            bottom: 0;
            width: 200%;
            height: 200px;
            background: linear-gradient(to top, rgba(160, 130, 90, 0.4), transparent);
            border-radius: 50%;
        }
        #dune-bg::before {
            left: -50%;
            animation: parallax-dunes 25s linear infinite;
        }
        #dune-bg::after {
            left: 0;
            animation: parallax-dunes 40s linear infinite reverse;
            background: linear-gradient(to top, rgba(193, 154, 107, 0.3), transparent);
        }
        @keyframes parallax-dunes {
            from { transform: translateX(-25%); }
            to { transform: translateX(25%); }
        }
        
        #in-game-menu-button {
            position: absolute;
            top: 10px;
            right: 0;
            pointer-events: auto;
            width: 150px;
            padding: 10px 15px;
            font-size: 16px;
            z-index: 5;
            box-sizing: border-box;
        }
        
        .icon-button {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 44px;
            height: 44px;
            padding: 0;
            margin: 0;
            background-color: rgba(74, 74, 74, 0.5);
            border: 2px solid #3a3a3a;
            border-radius: 8px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            transition: all 0.2s ease-out;
            z-index: 10;
        }
        .icon-button:hover {
            background-color: #5a5a5a;
            transform: scale(1.1);
        }
        .icon-button svg {
            width: 24px;
            height: 24px;
            stroke: #FFF8DC;
        }
        
        #fullscreen-map-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 20; 
            display: none; 
            justify-content: center;
            align-items: center;
            cursor: pointer;
        }
        #fullscreen-map-canvas {
            background-color: #CDBA96;
            border: 2px solid #D2B48C;
        }

        #round-winner-text {
             font-size: 32px; 
             font-family: 'Russo One', sans-serif;
             animation: none;
             opacity: 1;
        }
        .match-score { display: flex; justify-content: center; align-items: center; margin: 20px 0; gap: 5px; }
        .vs-text { font-size: 20px; font-weight: bold; margin: 0 10px; color: #FFF8DC; }
        .score-box {
            width: 20px;
            height: 20px;
            border: 2px solid #D2B48C;
            background-color: rgba(0,0,0,0.3);
            border-radius: 4px;
        }
        .score-box.blue-win {
            background-color: #a0c4ff;
        }
        .score-box.red-win {
            background-color: #ffadad;
        }
        #scoreboard-teams-container { 
            display: flex; 
            justify-content: space-around; 
            gap: 20px;
            width: 100%;
            flex-wrap: nowrap;
        }
        .scoreboard-team { 
            flex: 1; 
            max-width: 48%;
        }
        .scoreboard-team h2 { margin-top: 0; font-size: 24px; }
        .scoreboard-team.blue { color: #a0c4ff; }
        .scoreboard-team.red { color: #ffadad; }
        .scoreboard-header, .scoreboard-player-row { 
            display: grid; 
            grid-template-columns: 2.5fr 1fr 1fr 1fr 1fr 1.5fr; 
            gap: 5px; 
            padding: 5px; 
            text-align: left; 
            align-items: center;
            font-family: 'Courier New', Courier, monospace;
        }
        .scoreboard-header { 
            font-weight: bold; 
            border-bottom: 1px solid #D2B48C; 
            font-size: 10px; 
        }
        
        .scoreboard-player-row { 
            background-color: rgba(255,255,255,0.05); 
            border-radius: 4px; 
            margin-bottom: 5px; 
            font-size: 14px;
        }

        .player-name-cell {
            display: flex;
            align-items: center;
        }
        
        .mvp-sticker {
            display: inline-block;
            background-color: #FFD700; /* Gold color */
            color: #333;
            padding: 2px 6px;
            font-size: 10px;
            font-weight: bold;
            border-radius: 4px;
            transform: rotate(-15deg);
            margin-left: 10px;
            text-shadow: none;
            line-height: 1;
        }

        #player-info-container {
            position: absolute;
            bottom: 20px;
            left: 20px;
            display: flex;
            flex-direction: column;
            gap: 5px;
            pointer-events: none;
        }
        #player-name-display {
            color: #FFF8DC;
            font-size: 16px;
            font-weight: bold;
            text-shadow: 1px 1px 2px #000;
        }
        #player-health-bar-container {
            width: 150px;
            height: 15px;
            border: 1px solid #FFF8DC;
            border-radius: 3px;
        }
        #player-health-bar {
            width: 100%;
            height: 100%;
            background-color: #4CAF50; /* Green */
            border-radius: 2px;
            transition: width 0.2s linear;
        }
        #matchup-screen {
            width: 100%;
            max-width: none;
            height: 100%;
            top: 0;
            left: 0;
            transform: none;
            border-radius: 0;
            background-color: rgba(0,0,0,0.5);
        }
        #matchup-bg-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            display: block;
        }
        #matchup-content {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 80%;
            max-width: 1000px;
            color: #FFF8DC;
        }
        .matchup-team {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        #matchup-blue-team {
            align-items: flex-end;
            padding-right: 40px;
        }
        #matchup-red-team {
            align-items: flex-start;
            padding-left: 40px;
        }
        .matchup-player-card {
            display: flex;
            align-items: center;
            gap: 15px;
            background-color: rgba(0,0,0,0.6);
            padding: 10px;
            border-radius: 8px;
            border: 1px solid #D2B48C;
        }
        #matchup-red-team .matchup-player-card {
            flex-direction: row-reverse;
        }
        .matchup-player-card canvas {
            width: 60px;
            height: 60px;
            display: block;
            border-radius: 5px;
        }
        .matchup-player-card .player-name {
            font-size: 20px;
            font-weight: bold;
        }
        .vs-text-large {
            font-family: 'Russo One', sans-serif;
            font-size: 80px;
            margin: 0 40px;
            text-shadow: 0 0 15px #D2B48C;
        }
        #round-countdown {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-family: 'Russo One', sans-serif;
            font-size: 100px;
            color: #FFF8DC;
            text-shadow: 0 0 20px #000;
            z-index: 100;
            display: none;
            pointer-events: none;
        }
        #spectate-controls {
            position: absolute;
            bottom: 20px;
            right: 20px;
            display: none;
            gap: 10px;
            pointer-events: auto;
        }
        .spectate-arrow {
            font-size: 30px;
            color: white;
            cursor: pointer;
            text-shadow: 1px 1px 3px black;
            user-select: none;
        }
        .spectate-arrow:hover {
            color: #D2B48C;
        }
        .setting-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            padding: 10px 0;
            font-size: 18px;
            text-transform: uppercase;
        }

        .custom-checkbox {
            position: relative;
            cursor: pointer;
            width: 28px;
            height: 28px;
            background-color: #4a4a4a;
            border: 2px solid #3a3a3a;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .custom-checkbox .checkmark {
            display: none;
            width: 8px;
            height: 14px;
            border: solid #4CAF50;
            border-width: 0 4px 4px 0;
            transform: rotate(45deg);
        }

        #joystick-toggle:checked ~ .custom-checkbox .checkmark {
            display: block;
        }
        #scoreboard-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.7);
            z-index: 15;
            display: none;
            justify-content: center;
            align-items: center;
            pointer-events: auto; /* Allow clicking on the overlay to close it */
        }
        #scoreboard-overlay > .menu-screen {
             pointer-events: auto;
             max-width: 800px;
        }
        #kill-feed {
            position: absolute;
            top: 80px; /* Adjust as needed */
            right: 20px;
            width: 300px;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 5px;
            pointer-events: none;
        }
        .kill-feed-item {
            background-color: rgba(0, 0, 0, 0.5);
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 14px;
            animation: fadeOut 5s forwards;
            white-space: nowrap;
        }
        .kill-feed-item .blue-team { color: #a0c4ff; }
        .kill-feed-item .red-team { color: #ffadad; }
        .kill-feed-item .weapon { color: #FFF8DC; }
        @keyframes fadeOut {
            0% { opacity: 1; }
            80% { opacity: 1; }
            100% { opacity: 0; }
        }

        /* Kill Cam UI styles */
        #kill-cam-overlay {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 101; /* Above everything */
            color: #FFF8DC;
            text-align: center;
            display: none; /* Hidden by default */
            flex-direction: column;
            align-items: center;
            gap: 10px;
            pointer-events: none;
        }
        #kill-cam-overlay h1 {
            font-family: 'Russo One', sans-serif;
            font-size: 48px;
            margin: 0;
            text-shadow: 2px 2px 4px #000;
        }
        #kill-cam-portrait {
            width: 80px;
            height: 80px;
            border: 2px solid #D2B48C;
            border-radius: 8px;
            background-color: rgba(42, 33, 28, 0.8);
            display: block;
        }
        #kill-cam-killer-name {
            font-size: 24px;
            font-weight: bold;
            text-shadow: 1px 1px 2px #000;
        }
        
        /* Mobile adjustments */
        @media (max-width: 768px), (max-height: 500px) {
            .menu-screen {
                width: 90%;
                padding: 15px;
            }
            #welcome-screen {
                width: 100%;
                height: 100%;
                border-radius: 0;
            }
             .menu-screen h1 {
                font-size: 36px; /* Smaller title on mobile */
            }
            .menu-button {
                padding: 10px 18px;
                font-size: 16px;
            }

            #minimap {
                width: 80px;
                height: 80px;
            }
             #in-game-menu-button {
                width: 80px;
                padding: 10px 5px;
            }
            #ammo-counter {
                font-size: 20px;
            }
            .top-ui-container {
                left: 90px;
                right: 90px;
                height: 50px;
                padding: 2px 5px;
                gap: 5px;
            }
             .score-display {
                font-size: 18px;
            }
            #game-timer-bar {
                font-size: 14px;
            }
            .team-icon-group {
                gap: 2px;
            }
             #blue-team-icons {
                margin-right: 5px;
            }
            #red-team-icons {
                margin-left: 5px;
            }
            .player-portrait-wrapper canvas {
                width: 20px;
                height: 20px;
            }
        }

    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>

    <div id="game-ui">
        <div class="top-ui-container" id="tdm-ui">
            <div class="team-icon-group" id="blue-team-icons">
            </div>
            <div id="center-info-block">
                 <div id="game-timer-bar">2:00</div>
                 <div id="team-role-display"></div>
                 <div id="team-score-bar">
                    <div id="blue-score-display">0</div>
                    <div id="red-score-display">0</div>
                 </div>
            </div>
            <div class="team-icon-group" id="red-team-icons">
            </div>
        </div>
        <div id="game-event-text"></div>
        <div id="kill-feed"></div>
        <button class="menu-button" id="in-game-menu-button">Menu</button>
        <div id="minimap-container">
            <canvas id="minimap"></canvas>
        </div>
        
        <div id="bottom-center-hud">
            <div id="bomb-icon-container">
                <svg width="50" height="50" viewBox="0 0 100 100">
                    <rect x="20" y="35" width="60" height="30" fill="#333" stroke="black" stroke-width="2"/>
                    <rect x="45" y="25" width="10" height="10" fill="#555"/>
                    <line x1="50" y1="25" x2="50" y2="15" stroke="red" stroke-width="4"/>
                </svg>
            </div>
            <div id="ammo-counter">30 / ∞</div>
        </div>
        
        <button id="plant-bomb-button" style="display:none;">Hold to Plant</button>
        
        <div id="player-info-container">
            <div id="player-name-display"></div>
            <div id="player-health-bar-container">
                <div id="player-health-bar"></div>
            </div>
        </div>

        <div id="spectate-controls">
            <div class="spectate-arrow" id="spectate-prev">&larr;</div>
            <div class="spectate-arrow" id="spectate-next">&rarr;</div>
        </div>
    </div>
    
    <div id="welcome-screen" class="menu-screen">
        <canvas id="welcome-bg-canvas"></canvas>
        <div id="dune-bg"></div>
        <div id="welcome-screen-content">
            <h1>Circle Combat</h1>
            <div id="main-menu-view">
                <button class="menu-button" id="show-sp-menu-button">Single Player</button>
                <button class="menu-button" id="multiplayer-button" disabled>Multiplayer <span>(Disabled)</span></button>
                <button class="menu-button" id="main-menu-settings-button">Settings</button>
            </div>
            <div id="single-player-menu-view" style="display: none; width: 100%;">
                 <button class="menu-button" id="3v3-button">3v3</button>
                 <button class="menu-button" id="2v2-button">2v2</button>
                 <button class="menu-button" id="1v1-button">1v1</button>
                 <button class="menu-button" id="sp-back-button">Back</button>
            </div>
        </div>
        <div id="creator-credit">Created by Ryder Haddock</div>
    </div>
    
    <div id="matchup-screen" class="menu-screen">
        <canvas id="matchup-bg-canvas"></canvas>
        <div id="matchup-content">
            <div id="matchup-blue-team" class="matchup-team">
                </div>
            <div class="vs-text-large">VS</div>
            <div id="matchup-red-team" class="matchup-team">
                </div>
        </div>
    </div>

    <div id="in-game-menu" class="menu-screen">
        <button class="menu-button" id="resume-button">Resume</button>
        <button class="menu-button" id="leave-match-button">Leave Match</button>
    </div>

    <div id="settings-menu" class="menu-screen">
        <h1>Settings</h1>
        <div class="setting-row">
            <label for="joystick-toggle">Enable Joysticks</label>
            <input type="checkbox" id="joystick-toggle" checked style="display: none;">
            <label for="joystick-toggle" class="custom-checkbox">
                <div class="checkmark"></div>
            </label>
        </div>
        <button class="menu-button" id="back-button">Back</button>
    </div>

    <div id="scoreboard-overlay">
        <div id="round-scoreboard" class="menu-screen">
            <h1 id="round-winner-text"></h1>
            <div class="match-score" id="round-end-match-score">
                </div>
            <div id="scoreboard-teams-container">
                <div class="scoreboard-team blue">
                    <h2>Blue Team</h2>
                    <div class="scoreboard-header">
                        <div>Player</div>
                        <div class="col-stat">Kills</div>
                        <div class="col-stat">Assists</div>
                        <div class="col-stat">Plants</div>
                        <div class="col-stat">Defuses</div>
                        <div class="col-stat">Score</div>
                    </div>
                    <div id="scoreboard-blue-team"></div>
                </div>
                <div class="scoreboard-team red">
                    <h2>Red Team</h2>
                     <div class="scoreboard-header">
                        <div>Player</div>
                        <div class="col-stat">Kills</div>
                        <div class="col-stat">Assists</div>
                        <div class="col-stat">Plants</div>
                        <div class="col-stat">Defuses</div>
                        <div class="col-stat">Score</div>
                    </div>
                    <div id="scoreboard-red-team"></div>
                </div>
            </div>
        </div>
    </div>

    <div id="game-over" class="menu-screen">
        <h1 id="final-winner-title"></h1>
        <div class="match-score" id="final-match-score">
        </div>
        <button class="menu-button" id="play-again-button">Play Again</button>
    </div>
    <div id="fullscreen-map-overlay"><canvas id="fullscreen-map-canvas"></canvas></div>
    <div id="round-countdown"></div>
    <div id="kill-cam-overlay">
        <h1>Final Kill</h1>
        <canvas id="kill-cam-portrait"></canvas>
        <div id="kill-cam-killer-name"></div>
    </div>
</div>

<script>
    document.addEventListener('DOMContentLoaded', () => {

    'use strict';

    // Get DOM elements
    const gameContainer = document.getElementById('game-container');
    const gameCanvas = document.getElementById('gameCanvas');
    const ctx = gameCanvas.getContext('2d');
    const minimapCanvas = document.getElementById('minimap');
    const minimapCtx = minimapCanvas.getContext('2d');
    const welcomeScreenElement = document.getElementById('welcome-screen');
    const welcomeBgCanvas = document.getElementById('welcome-bg-canvas');
    let welcomeBgCtx = welcomeBgCanvas.getContext('2d');
    const settingsMenuElement = document.getElementById('settings-menu');
    const inGameMenuElement = document.getElementById('in-game-menu');
    const gameOverElement = document.getElementById('game-over');
    const scoreboardOverlay = document.getElementById('scoreboard-overlay');
    const roundScoreboardElement = document.getElementById('round-scoreboard');
    const matchupScreenElement = document.getElementById('matchup-screen');
    const matchupBgCanvas = document.getElementById('matchup-bg-canvas');
    const matchupBlueTeamContainer = document.getElementById('matchup-blue-team');
    const matchupRedTeamContainer = document.getElementById('matchup-red-team');
    const gameUiElement = document.getElementById('game-ui');
    const finalWinnerTitleElement = document.getElementById('final-winner-title');
    const roundWinnerTextElement = document.getElementById('round-winner-text');
    const scoreboardBlueTeam = document.getElementById('scoreboard-blue-team');
    const scoreboardRedTeam = document.getElementById('scoreboard-red-team');
    const ammoCounterElement = document.getElementById('ammo-counter');
    const plantBombButton = document.getElementById('plant-bomb-button');
    const bombIconContainer = document.getElementById('bomb-icon-container');
    const tdmUiContainer = document.getElementById('tdm-ui');
    const centerInfoBlock = document.getElementById('center-info-block');
    const gameTimerBar = document.getElementById('game-timer-bar');
    const gameEventText = document.getElementById('game-event-text');
    const killFeed = document.getElementById('kill-feed');
    const teamRoleDisplay = document.getElementById('team-role-display');
    const blueScoreDisplay = document.getElementById('blue-score-display');
    const redScoreDisplay = document.getElementById('red-score-display');
    const blueTeamIconsContainer = document.getElementById('blue-team-icons');
    const redTeamIconsContainer = document.getElementById('red-team-icons');
    const fullscreenMapOverlay = document.getElementById('fullscreen-map-overlay');
    const fullscreenMapCanvas = document.getElementById('fullscreen-map-canvas');
    const playerInfoContainer = document.getElementById('player-info-container');
    const playerNameDisplay = document.getElementById('player-name-display');
    const playerHealthBar = document.getElementById('player-health-bar');
    const mainMenuView = document.getElementById('main-menu-view');
    const singlePlayerMenuView = document.getElementById('single-player-menu-view');
    const roundCountdownElement = document.getElementById('round-countdown');
    const spectateControls = document.getElementById('spectate-controls');
    const killCamOverlay = document.getElementById('kill-cam-overlay');
    const killCamPortraitCanvas = document.getElementById('kill-cam-portrait');
    const killCamKillerName = document.getElementById('kill-cam-killer-name');
    
    // Menu Buttons
    const showSpMenuButton = document.getElementById('show-sp-menu-button');
    const spBackButton = document.getElementById('sp-back-button');
    const mainMenuSettingsButton = document.getElementById('main-menu-settings-button');
    const backButton = document.getElementById('back-button');
    const joystickToggle = document.getElementById('joystick-toggle');
    const threeVThreeButton = document.getElementById('3v3-button');
    const twoVTwoButton = document.getElementById('2v2-button');
    const oneVOneButton = document.getElementById('1v1-button');
    const playAgainButton = document.getElementById('play-again-button');
    const inGameMenuButton = document.getElementById('in-game-menu-button');
    const resumeButton = document.getElementById('resume-button');
    const leaveMatchButton = document.getElementById('leave-match-button');
    const spectatePrevButton = document.getElementById('spectate-prev');
    const spectateNextButton = document.getElementById('spectate-next');

    
    // Game constants and variables
    let canvasWidth = 800;
    let canvasHeight = 600;
    const playerRadius = 20;
    const playerColor = '#4682B4';
    const moveSpeed = 220; 
    const aiMoveSpeed = 180; 
    const initialHitPoints = 100;
    const bulletRadius = 6;
    const bulletSpeed = 15.0; 
    const defaultBulletColor = '#FFD700';
    const bulletDamage = 20;
    const lightRadius = 275; 
    let cameraZoom = 1.0; 
    const BOMB_PLANT_TIME = 5;
    const BOMB_DEFUSE_TIME = 5;
    const BOMB_TIMER_DURATION = 45;
    const ASSIST_TIMER_DURATION = 5000;

    const BURST_COUNT = 3;
    const BURST_FIRE_RATE = 5; 
    const BURST_COOLDOWN_TIME = 25;
    
    const wallColor = '#654321'; 
    const floorColor = '#6c757d'; 
    const wallThickness = 8; 

    // Game state arrays
    let allCharacters = [];
    let bullets = [];
    let sandSpecks = [];
    let dunes = [];
    let floatingTexts = [];
    let particles = [];
    let powerUps = [];
    let obstacles = [];
    let floorTiles = [];
    let tdmSpawnPoints = [];
    let bombSites = [];
    let losSegments = []; 

    // Kill Cam & History Recording
    let historyBuffer = [];
    const KILL_CAM_HISTORY_SECONDS = 5;
    const KILL_CAM_AFTERMATH_SECONDS = 3; // Increased to 3 for a 2-second view of the body
    const MAX_HISTORY_FRAMES = 60 * (KILL_CAM_HISTORY_SECONDS + KILL_CAM_AFTERMATH_SECONDS);
    let lastKillInfo = null;
    let isKillCamActive = false;
    let killCamReplayStartTime = 0;
    let killCamReplayClock = 0;
    let killCamReplayBuffer = [];
    let finalKillerId = null;
    let postKillCamReason = ''; 
    let postKillCamWinningTeam = 0;

    // Game effects
    let screenShake = { intensity: 0, duration: 0 };

    // Game state flags and timers
    let isGameOver = false;
    let inRoundTransition = false;
    let isRoundActive = false;
    let isPaused = false;
    let animationFrameId = null;
    let mapCenter;
    let gameState;
    let lastTimestamp = 0;
    let gameMode = '3v3'; 
    let spectatingId = null;
    let spectatablePlayers = [];
    let spectateTimer = 0;
    let roundState = { blueScore: 0, redScore: 0, roundNumber: 0, attackingTeam: 1 };
    let gameSettings = { useJoysticks: true };
    let mousePos = { x: 0, y: 0 };
    let bomb = {};
    let bombItem = { x: 0, y: 0, radius: 10, isCarried: false };
    let bombPlantedTextTimer = 0;
    let roundStartTextTimer = 0;
    let isPlantingButtonHeld = false;
    let previousView = 'welcome-screen';
    let isDetonationSequenceActive = false;
    let detonationCameraTarget = null;

    // Minimap and rendering state
    let isMinimapExpanded = false;
    let offscreenMinimapCanvas = null;
    let offscreenMinimapCtx = null;
    let fogCanvas = null;
    let fogCtx = null;
    
    // Welcome screen animation
    let welcomeAnimFrameId = null;
    let bgCircles = [];
    let bgCharacters = [];

    // Input state
    const keysDown = { w: false, a: false, s: false, d: false, " ": false, r: false, e: false };

    // Joystick state
    let movementJoystick = null;
    let shootingJoystick = null;

    let mapWidth, mapHeight;
    let pathfindingGrid = [];
    const GRID_SCALE = 30; // 1 node per 30 pixels

    // Joystick class for mobile controls
    class Joystick {
        constructor(x, y, radius, handleRadius) {
            this.baseX = x; this.baseY = y;
            this.handleX = x; this.handleY = y;
            this.radius = radius;
            this.handleRadius = handleRadius;
            this.isActive = false;
            this.touchId = null;
            this.vector = { x: 0, y: 0 };
        }
        draw(g) {
            g.beginPath();
            g.arc(this.baseX, this.baseY, this.radius, 0, Math.PI * 2);
            g.fillStyle = 'rgba(128, 128, 128, 0.4)';
            g.fill();
            g.beginPath();
            g.arc(this.handleX, this.handleY, this.handleRadius, 0, Math.PI * 2);
            g.fillStyle = 'rgba(100, 100, 100, 0.6)';
            g.fill();
        }
        update(x, y) {
            const dx = x - this.baseX;
            const dy = y - this.baseY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            if (distance < this.radius) {
                this.handleX = x;
                this.handleY = y;
            } else {
                this.handleX = this.baseX + (dx / distance) * this.radius;
                this.handleY = this.baseY + (dy / distance) * this.radius;
            }
            const totalDist = this.radius;
            this.vector.x = (this.handleX - this.baseX) / totalDist;
            this.vector.y = (this.handleY - this.baseY) / totalDist;
        }
        reset() {
            this.isActive = false;
            this.touchId = null;
            this.vector = { x: 0, y: 0 };
        }
    }
    
    function generateMapLayout() {
        obstacles = []; floorTiles = []; tdmSpawnPoints = []; powerUps = []; bombSites = []; losSegments = [];

        const color_grid = [
            "WWWWWWWWWBBBBBBBBBBBBWWWWWWWWW", "WWWWWWWWBBGGGGGGGGGGBBWWWWWWWW", "WWWWWWWWWGGGGBBBBGGGGWWWWWWWWW",
            "WWWWWWBWWGGGGGGGGGGGGWWBWWWWWW", "WWWWWWWWWBGCBBGGBBCGBWWWWWWWWW", "WWWWWWWWWBBBGGGGGGBBBWWWWWWWWW",
            "BBBBWWBWWWWBGGGGGGBWWWWBWWBBBB", "BRRWWWBWWWWWGGGGGGWWWWWBWWWRRB", "BRRWWWBWWWWWGGGGGGWWWWWBWWWRRB",
            "BBBBWWBWWWWBGGGGGGBWWWWBWWBBBB", "WWWWWWWWWBBBGGGGGGBBBWWWWWWWWW", "WWWWWWWWWBGCBBGGBBCGBWWWWWWWWW",
            "WWWWWWBWWGGGGGGGGGGGGWWBWWWWWW", "WWWWWWWWWGGGGBBBBGGGGWWWWWWWWW", "WWWWWWWWBBGGGGGGGGGGBBWWWWWWWW",
            "WWWWWWWWWBBBBBBBBBBBBWWWWWWWWW",
        ];
        
        const tileSize = 120;
        const crateSize = 25;
        mapHeight = color_grid.length * tileSize;
        mapWidth = color_grid[0].length * tileSize;
        mapCenter = { x: mapWidth / 2, y: mapHeight / 2 };

        bombSites.push({ id: 'A', x: mapCenter.x, y: mapCenter.y, radius: 60 });
        bombSites.push({ id: 'B', x: 22 * tileSize, y: 12 * tileSize, radius: 60 });

        const wallCoordSet = new Set();
        color_grid.forEach((row, y) => { for (let x = 0; x < row.length; x++) { if (row[x] === 'B') wallCoordSet.add(`${x},${y}`); } });

        const gridCenterY = Math.floor(color_grid.length / 2);
        const gridCenterX = Math.floor(color_grid[0].length / 2);

        const addObstacleWithLOS = (obs) => {
            obstacles.push(obs);
            const p1 = { x: obs.x, y: obs.y };
            const p2 = { x: obs.x + obs.w, y: obs.y };
            const p3 = { x: obs.x + obs.w, y: obs.y + obs.h };
            const p4 = { x: obs.x, y: obs.y + obs.h };
            losSegments.push({ p1, p2, ownerId: obs.id });
            losSegments.push({ p1: p2, p2: p3, ownerId: obs.id });
            losSegments.push({ p1: p3, p2: p4, ownerId: obs.id });
            losSegments.push({ p1: p4, p2: p1, ownerId: obs.id });
        };

        color_grid.forEach((row, y) => {
            for (let x = 0; x < row.length; x++) {
                const char = row[x]; const worldX = x * tileSize; const worldY = y * tileSize;
                if (char === 'B') {
                    const isEnclosed = wallCoordSet.has(`${x-1},${y}`) && wallCoordSet.has(`${x+1},${y}`) && wallCoordSet.has(`${x},${y-1}`) && wallCoordSet.has(`${x},${y+1}`);
                    const wall = { id: `wall_${x}_${y}`, type: 'wall', x: worldX, y: worldY, w: tileSize, h: tileSize, hp: Infinity, isEnclosed, borders: { top: !wallCoordSet.has(`${x},${y-1}`), bottom: !wallCoordSet.has(`${x},${y+1}`), left: !wallCoordSet.has(`${x-1},${y}`), right: !wallCoordSet.has(`${x+1},${y}`) } };
                    addObstacleWithLOS(wall);
                } else if (char === 'G') { floorTiles.push({x: worldX, y: worldY, w: tileSize, h: tileSize });
                } else if (char === 'R') { floorTiles.push({x: worldX, y: worldY, w: tileSize, h: tileSize }); tdmSpawnPoints.push({ x: worldX + tileSize / 2, y: worldY + tileSize / 2 });
                } else if (char === 'O') { floorTiles.push({x: worldX, y: worldY, w: tileSize, h: tileSize }); powerUps.push({ x: worldX + tileSize / 2, y: worldY + tileSize / 2, active: true, type: 'shotgun', radius: 10 });
                } else if (char === 'C') {
                    floorTiles.push({ x: worldX, y: worldY, w: tileSize, h: tileSize });
                    const gap = 5; const formationWidth = crateSize*2+gap; const formationHeight = crateSize*2+gap;
                    const tileStartX = worldX + (tileSize - formationWidth)/2; const tileStartY = worldY + (tileSize - formationHeight)/2;
                    const corners = { topLeft: {x:tileStartX, y:tileStartY}, topRight: {x:tileStartX+crateSize+gap, y:tileStartY}, bottomLeft: {x:tileStartX, y:tileStartY+crateSize+gap}, bottomRight: {x:tileStartX+crateSize+gap, y:tileStartY+crateSize+gap} };
                    let positions = [];
                    if (y < gridCenterY && x < gridCenterX) positions = [corners.topRight, corners.bottomLeft, corners.bottomRight];
                    else if (y < gridCenterY && x > gridCenterX) positions = [corners.topLeft, corners.bottomLeft, corners.bottomRight];
                    else if (y > gridCenterY && x < gridCenterX) positions = [corners.topLeft, corners.topRight, corners.bottomRight];
                    else if (y > gridCenterY && x > gridCenterX) positions = [corners.topLeft, corners.topRight, corners.bottomLeft];
                    positions.forEach((pos, i) => { 
                        const crate = {id:`crate_${x}_${y}_${i}`,type:'crate',x:pos.x,y:pos.y,w:crateSize,h:crateSize,hp:100};
                        addObstacleWithLOS(crate);
                    });
                }
            }
        });
        
        // Restore original Bomb Site A crates
        const siteA = bombSites.find(s => s.id === 'A');
        if (siteA) {
            const siteCrateSize = 25;
            const siteCrateHP = 150;
            const LformationsA = [
                { x_offset: -200, y_offset: -180, shape: [[0,0],[1,0],[0,1]] },
                { x_offset: -300, y_offset: -120, shape: [[0,0],[0,1],[-1,1]] },
                { x_offset: -200, y_offset: 155, shape: [[0,0],[1,0],[0,-1]] },
                { x_offset: -300, y_offset: 170, shape: [[0,0],[0,-1],[-1,-1]] }
            ];
            LformationsA.forEach((formation, i) => {
                formation.shape.forEach((pos, j) => {
                     const crate = { id: `extra_A_L_${i}_${j}`, type: 'crate', x: siteA.x + formation.x_offset + pos[0] * siteCrateSize, y: siteA.y + formation.y_offset + pos[1] * siteCrateSize, w: siteCrateSize, h: siteCrateSize, hp: siteCrateHP };
                     addObstacleWithLOS(crate);
                });
                formation.shape.forEach((pos, j) => {
                     const mirroredX = siteA.x - (formation.x_offset + (pos[0] * siteCrateSize)) - siteCrateSize;
                     const mirroredY = siteA.y + formation.y_offset + pos[1] * siteCrateSize;
                     const crate = { id: `extra_A_R_${i}_${j}`, type: 'crate', x: mirroredX, y: mirroredY, w: crateSize, h: siteCrateSize, hp: siteCrateHP };
                     addObstacleWithLOS(crate);
                });
            });
        }
        createPathfindingGrid();
    }

    function createPathfindingGrid() {
        const gridW = Math.ceil(mapWidth / GRID_SCALE);
        const gridH = Math.ceil(mapHeight / GRID_SCALE);
        pathfindingGrid = [];
        for (let y = 0; y < gridH; y++) {
            const row = [];
            for (let x = 0; x < gridW; x++) {
                const worldX = x * GRID_SCALE + GRID_SCALE / 2;
                const worldY = y * GRID_SCALE + GRID_SCALE / 2;
                let isWall = false;
                for (const obs of obstacles) {
                    if (worldX > obs.x && worldX < obs.x + obs.w && worldY > obs.y && worldY < obs.y + obs.h) {
                        isWall = true;
                        break;
                    }
                }
                row.push(isWall ? 1 : 0); // 1 is wall, 0 is walkable
            }
            pathfindingGrid.push(row);
        }
    }

    function findPath(startPos, endPos) {
        const gridW = pathfindingGrid[0].length;
        const gridH = pathfindingGrid.length;

        const startNode = {
            x: Math.floor(startPos.x / GRID_SCALE),
            y: Math.floor(startPos.y / GRID_SCALE),
            g: 0, h: 0, f: 0, parent: null
        };
        const endNode = {
            x: Math.floor(endPos.x / GRID_SCALE),
            y: Math.floor(endPos.y / GRID_SCALE)
        };
        
        if (startNode.x === endNode.x && startNode.y === endNode.y) return [];
        if (endNode.x < 0 || endNode.x >= gridW || endNode.y < 0 || endNode.y >= gridH || pathfindingGrid[endNode.y][endNode.x] === 1) {
             return []; // end position is not valid
        }


        const openList = [startNode];
        const closedList = new Set();

        while (openList.length > 0) {
            let lowestIndex = 0;
            for (let i = 1; i < openList.length; i++) {
                if (openList[i].f < openList[lowestIndex].f) {
                    lowestIndex = i;
                }
            }

            let currentNode = openList[lowestIndex];
            openList.splice(lowestIndex, 1);
            closedList.add(`${currentNode.x},${currentNode.y}`);

            if (currentNode.x === endNode.x && currentNode.y === endNode.y) {
                let path = [];
                let curr = currentNode;
                while (curr.parent) {
                    path.push({ x: curr.x * GRID_SCALE + GRID_SCALE / 2, y: curr.y * GRID_SCALE + GRID_SCALE / 2 });
                    curr = curr.parent;
                }
                return path.reverse();
            }

            const neighbors = [];
            const { x, y } = currentNode;
            if (y > 0) neighbors.push({ x, y: y - 1 });
            if (y < gridH - 1) neighbors.push({ x, y: y + 1 });
            if (x > 0) neighbors.push({ x: x - 1, y });
            if (x < gridW - 1) neighbors.push({ x: x + 1, y });

            for (const neighbor of neighbors) {
                if (closedList.has(`${neighbor.x},${neighbor.y}`) || pathfindingGrid[neighbor.y][neighbor.x] === 1) {
                    continue;
                }

                const gScore = currentNode.g + 1;
                let gScoreIsBest = false;

                const neighborNodeInOpen = openList.find(n => n.x === neighbor.x && n.y === neighbor.y);
                if (!neighborNodeInOpen) {
                    gScoreIsBest = true;
                    neighbor.h = Math.abs(neighbor.x - endNode.x) + Math.abs(neighbor.y - endNode.y);
                    openList.push({ ...neighbor, g: gScore, f: gScore + neighbor.h, parent: currentNode });
                } else if (gScore < neighborNodeInOpen.g) {
                    gScoreIsBest = true;
                }

                if (gScoreIsBest) {
                    if(neighborNodeInOpen){
                       neighborNodeInOpen.parent = currentNode;
                       neighborNodeInOpen.g = gScore;
                       neighborNodeInOpen.f = gScore + neighborNodeInOpen.h;
                    }
                }
            }
        }
        return []; // No path found
    }

    function generateSandPattern() { if(!mapWidth || !mapHeight) return; sandSpecks = []; dunes = []; const speckColors = ['rgba(193, 154, 107, 0.1)', 'rgba(160, 130, 90, 0.15)', 'rgba(240, 220, 170, 0.05)']; for (let i=0; i<1500; i++) { sandSpecks.push({ x:Math.random()*mapWidth, y:Math.random()*mapHeight, r:1+Math.random()*2, c: speckColors[Math.floor(Math.random() * speckColors.length)], type: Math.random() > 0.1 ? 'circle' : 'line' }); } for(let i = 0; i < 60; i++) { dunes.push({ x: Math.random() * mapWidth, y: Math.random() * mapHeight, radiusX: 100 + Math.random() * 200, radiusY: 20 + Math.random() * 40, rotation: Math.random() * Math.PI, color: `rgba(210, 180, 140, ${0.05 + Math.random() * 0.15})`, shadowColor: `rgba(139, 115, 85, ${0.04 + Math.random() * 0.1})` }); } }
    
    function createCharacter(details) { 
        const base = { 
            hp: initialHitPoints, fireCooldown: 0, radius: playerRadius, score: 0, powerUp: null, powerUpDuration: 0,
            showOnMinimapTimer: 0, aimAngle: 0, hasBomb: false, isPlanting: false, plantTimer: 0, isDefusing: false,
            defuseTimer: 0, target: null, isBursting: false, burstsLeft: 0, burstCooldown: 0, kills: 0, assists: 0,
            plants: 0, defuses: 0, damageDealtTo: {}, isAvoiding: false, avoidAngle: 0, avoidTimer: 0, stuckTimer: 0,
            lastPosition: {x:0, y:0}, clipSize: 22, ammo: 22, isReloading: false, reloadTime: 2, reloadTimer: 0,
            isStrafing: false, strafeDirection: 1, strafeTimer: 0, strafeDecisionTimer: 0,
            path: [], pathfindingCooldown: 0, objectiveSite: null,
        }; 
        const newChar = {...base, ...details}; 
        newChar.lastPosition = {x: newChar.x, y: newChar.y};
        return newChar; 
    }
    
    function createParticles(x, y, count, color) { for (let i = 0; i < count; i++) { const angle = Math.random() * Math.PI * 2; const speed = 2 + Math.random() * 3; particles.push({ x, y, dx: Math.cos(angle) * speed, dy: Math.sin(angle) * speed, radius: 1 + Math.random() * 2, color: color, lifetime: 20 + Math.random() * 20, alpha: 1 }); } }
    
    function createBullet(x, y, targetX, targetY, ownerId, ownerTeam, spread = 0) {
        const shooter = allCharacters.find(c => c.id === ownerId);
        const color = shooter ? shooter.color : defaultBulletColor;
        const baseAngle = Math.atan2(targetY - y, targetX - x);
        
        if (spread > 0) {
            for (let i = 0; i < 5; i++) {
                const angle = baseAngle + (i - 2) * spread;
                const dx = Math.cos(angle) * bulletSpeed;
                const dy = Math.sin(angle) * bulletSpeed;
                bullets.push({ x, y, dx, dy, owner: ownerId, team: ownerTeam, color: color });
            }
        } else {
            const dx = Math.cos(baseAngle) * bulletSpeed;
            const dy = Math.sin(baseAngle) * bulletSpeed;
            bullets.push({ x, y, dx, dy, owner: ownerId, team: ownerTeam, color: color });
        }
        
        if (shooter) shooter.showOnMinimapTimer = 90;
    }
    
    function distSq(x1, y1, x2, y2) { const dx = x1 - x2; const dy = y1 - y2; return dx * dx + dy * dy; }
    function nearActiveBombSite(character) { return bombSites.find(site => distSq(character.x, character.y, site.x, site.y) < site.radius * site.radius); }
    function nearBomb(character) { return bomb.planted && distSq(character.x, character.y, bomb.x, bomb.y) < 100 * 100; }
    
    function plantBomb(character, site) { 
        bomb.x = character.x; bomb.y = character.y; bomb.planted = true; bomb.active = true; 
        bomb.plantedByTeam = character.team; bomb.plantedById = character.id;
        bomb.timer = 0; bomb.siteId = site.id; 
        bombPlantedTextTimer = 3; 
        character.hasBomb = false; character.isPlanting = false; character.plantTimer = 0; 
        character.plants++; 
        character.score += 100;
    }
    function defuseBomb(character) { 
        bomb.active = false; character.isDefusing = false; 
        character.defuses++;
        character.score += 100;
        declareRoundWinner(character.team, "Bomb Defused"); 
    }
    
    function declareRoundWinner(winningTeam, reason) {
        if (inRoundTransition) return;
        isRoundActive = false;
        inRoundTransition = true;

        const roundEndAction = () => {
            if (lastKillInfo && reason !== "Bomb Detonated") {
                startKillCam(winningTeam, reason);
            } else {
                proceedToScoreboard(winningTeam, reason);
            }
        };

        if (reason === "Bomb Detonated") {
            setTimeout(roundEndAction, 3000);
        } else {
            roundEndAction();
        }
    }
    
    function startKillCam(winningTeam, reason) {
        isKillCamActive = true;
        postKillCamReason = reason;
        postKillCamWinningTeam = winningTeam;
        finalKillerId = lastKillInfo.killerId;
        const killTimestamp = lastKillInfo.timestamp;
        const startTime = killTimestamp - (KILL_CAM_HISTORY_SECONDS * 1000);
        const endTime = killTimestamp + (KILL_CAM_AFTERMATH_SECONDS * 1000);
        killCamReplayBuffer = historyBuffer.filter(frame => frame.timestamp >= startTime && frame.timestamp <= endTime);
        if (killCamReplayBuffer.length > 0) {
            killCamReplayStartTime = performance.now();
            killCamReplayClock = 0;
            killCamOverlay.style.display = 'flex';
            killCamPortraitCanvas.width = 80;
            killCamPortraitCanvas.height = 80;
            const killer = allCharacters.find(c => c.id === finalKillerId);
            if (killer) {
                killCamKillerName.textContent = killer.name;
                drawPlayerPortrait(killCamPortraitCanvas, killer);
            }
        } else {
            isKillCamActive = false;
            proceedToScoreboard(winningTeam, reason);
        }
    }

    function proceedToScoreboard(winningTeam, reason) {
        killCamOverlay.style.display = 'none';
        
        let roundWinnerText = '';
        const winnerTeamName = winningTeam === 1 ? 'Blue Team' : 'Red Team';
        
        switch(reason) {
            case "Bomb Detonated": roundWinnerText = "Target Destroyed"; break;
            case "Bomb Defused": roundWinnerText = "Bomb Defused"; break;
            default: roundWinnerText = `${winnerTeamName} Won`; break;
        }
        
        const showScoreboardAndContinue = () => {
            if (winningTeam === 1) roundState.blueScore++; else roundState.redScore++;

            const roundsToWin = gameMode === '1v1' ? 3 : 3;
            const isGameOver = roundState.blueScore >= roundsToWin || roundState.redScore >= roundsToWin;
            
            let mvpPlayerId = null;
            if (isGameOver) {
                 const winnerTeamNum = roundState.blueScore > roundState.redScore ? 1 : 2;
                 const winningPlayers = allCharacters.filter(p => p.team === winnerTeamNum);
                 if(winningPlayers.length > 0) {
                    mvpPlayerId = winningPlayers.sort((a, b) => b.score - a.score)[0].id;
                 }
            }
            
            showRoundScoreboard(roundWinnerText, mvpPlayerId);

            setTimeout(() => {
                scoreboardOverlay.style.display = 'none';
                roundScoreboardElement.style.display = 'none';
                if (isGameOver) {
                    let finalWinnerText = roundState.blueScore > roundState.redScore ? "Blue Team" : "Red Team";
                    if(gameMode === '1v1') finalWinnerText = roundState.blueScore > roundState.redScore ? "Player 1" : "Player 2";
                    endGame(finalWinnerText);
                } else {
                    startRound();
                }
            }, 5000); // 5 seconds on scoreboard
        };
        
        const planter = allCharacters.find(c => c.id === bomb.plantedById);
        if (planter) planter.score += 400;
        showScoreboardAndContinue();
    }
    
    function hasLineOfSight(p1, p2, ignoreOwnerId = null) {
        const ray = { p1, p2 };
        const distToTargetSq = distSq(p1.x, p1.y, p2.x, p2.y);

        for (const segment of losSegments) {
            if (ignoreOwnerId && segment.ownerId === ignoreOwnerId) {
                continue; 
            }
            
            const intersection = getIntersection(ray, segment);
            if (intersection) {
                const distToIntersectionSq = distSq(p1.x, p1.y, intersection.x, intersection.y);
                if (distToIntersectionSq < distToTargetSq - 0.01) { 
                    return false;
                }
            }
        }
        return true;
    }

    function addKillFeedEntry(killer, victim) {
        const item = document.createElement('div');
        item.className = 'kill-feed-item';
        const killerSpan = `<span class="${killer.team === 1 ? 'blue-team' : 'red-team'}">${killer.name}</span>`;
        const victimSpan = `<span class="${victim.team === 1 ? 'blue-team' : 'red-team'}">${victim.name}</span>`;
        item.innerHTML = `${killerSpan} <span class="weapon">eliminated</span> ${victimSpan}`;
        killFeed.appendChild(item);
        setTimeout(() => {
            if (killFeed.contains(item)) {
                killFeed.removeChild(item);
            }
        }, 5000);
    }
    
    function applyDamageAndHandleKill(target, shooter, damage) {
        target.hp -= damage;
        if (shooter) target.damageDealtTo[shooter.id] = Date.now();
        createParticles(target.x, target.y, 8, 'red');

        if (target.hp <= 0) {
            if (shooter) {
                shooter.kills++;
                shooter.score += 100;
                lastKillInfo = { killerId: shooter.id, victimId: target.id, timestamp: performance.now() };
                addKillFeedEntry(shooter, target);
            }

            const now = Date.now();
            for (const damagerId in target.damageDealtTo) {
                if (damagerId !== shooter?.id && (now - target.damageDealtTo[damagerId] < ASSIST_TIMER_DURATION)) {
                    const assister = allCharacters.find(c => c.id === damagerId);
                    if (assister) { assister.assists++; assister.score += 25; }
                }
            }

            if (target.hasBomb) {
                target.hasBomb = false;
                bombItem.isCarried = false;
                bombItem.x = target.x;
                bombItem.y = target.y;
            }
        }
    }

    function updateCharacters(deltaTime) {
        if (!isRoundActive || isDetonationSequenceActive) return;

        const player = allCharacters.find(c => c.id === 'player');
        
        if (player.hp <= 0 && !spectatingId) updateSpectateList(player);
        else if(spectatingId){
            const currentSpectateTarget = allCharacters.find(c => c.id === spectatingId);
            if(!currentSpectateTarget || currentSpectateTarget.hp <= 0) updateSpectateList(player);
        }
        
        allCharacters.forEach(character => {
            if (character.hp <= 0) return;
            
            if (character.showOnMinimapTimer > 0) character.showOnMinimapTimer--;
            if (character.pathfindingCooldown > 0) character.pathfindingCooldown -= deltaTime;

            let dx=0, dy=0, isShooting = false; 

            if (character.id === 'player') {
                if(character.isPlanting || character.isDefusing) { dx=0; dy=0; }
                else {
                    if (gameSettings.useJoysticks && movementJoystick?.isActive) { dx += movementJoystick.vector.x; dy += movementJoystick.vector.y; }
                    if (keysDown.a) dx -= 1; if (keysDown.d) dx += 1;
                    if (keysDown.w) dy -= 1; if (keysDown.s) dy += 1;
                }
                isShooting = keysDown[' '] || (gameSettings.useJoysticks && shootingJoystick?.isActive && (shootingJoystick.vector.x !== 0 || shootingJoystick.vector.y !== 0));
            } else {
                // AI Logic
                let objectivePos = null;
                if (character.team === roundState.attackingTeam) { // Attacker AI
                    const bombCarrier = allCharacters.find(c => c.hasBomb);
                    if (character.hasBomb) {
                        if (!character.objectiveSite) {
                            character.objectiveSite = bombSites.sort((a,b) => distSq(character.x, character.y, a.x, a.y) - distSq(character.x, character.y, b.x, b.y))[0];
                        }
                        objectivePos = character.objectiveSite;
                        if(nearActiveBombSite(character)) {
                            character.isPlanting = true;
                            character.plantTimer += deltaTime;
                            if (character.plantTimer >= BOMB_PLANT_TIME) plantBomb(character, character.objectiveSite);
                        }
                    } else if (bombCarrier) {
                        objectivePos = bombCarrier; // Follow the bomb carrier
                    } else {
                        objectivePos = bombItem; // Go for the dropped bomb
                    }
                } else { // Defender AI
                    if (bomb.planted) {
                        objectivePos = bomb;
                        if(nearBomb(character)) {
                             character.isDefusing = true;
                             character.defuseTimer += deltaTime;
                             if(character.defuseTimer >= BOMB_DEFUSE_TIME) defuseBomb(character);
                        }
                    } else {
                         if (!character.objectiveSite || distSq(character.x, character.y, character.objectiveSite.x, character.objectiveSite.y) < 20000) {
                             character.objectiveSite = bombSites[Math.floor(Math.random() * bombSites.length)];
                         }
                         objectivePos = character.objectiveSite;
                    }
                }

                 if (!character.target || character.target.hp <= 0 || !hasLineOfSight(character, character.target)) {
                    const visibleEnemies = allCharacters.filter(c => c.team !== character.team && c.hp > 0 && hasLineOfSight(character, c));
                    character.target = visibleEnemies.length > 0 ? visibleEnemies.sort((a,b) => distSq(character.x, character.y, a.x, a.y) - distSq(character.x, character.y, b.x, b.y))[0] : null;
                }

                if (character.target) {
                    const targetAngle = Math.atan2(character.target.y - character.y, character.target.x - character.x);
                    character.aimAngle = targetAngle;
                    isShooting = true;
                    character.path = []; // Stop pathing when enemy is seen
                } else if (objectivePos && character.path.length === 0 && character.pathfindingCooldown <= 0) {
                    character.path = findPath(character, objectivePos);
                    character.pathfindingCooldown = 1.0; // Recalculate path every second
                }
                
                // --- NEW AI Movement Logic ---
                // Stuck detection
                if (distSq(character.x, character.y, character.lastPosition.x, character.lastPosition.y) < (1 * 1)) { // Hasn't moved 1 pixel
                    character.stuckTimer += deltaTime;
                } else {
                    character.stuckTimer = 0;
                    character.lastPosition = { x: character.x, y: character.y };
                }

                if (character.stuckTimer > 0.5) { // Stuck for half a second
                    character.path = []; // Clear path
                    character.pathfindingCooldown = 0; // Force repath
                    character.stuckTimer = 0;
                }

                // Path following and smoothing
                if (character.path.length > 0) {
                    // Path Smoothing: Check if we can see the *next* node after the current one.
                    if (character.path.length > 1 && hasLineOfSight(character, character.path[1])) {
                        character.path.shift(); // If so, skip the current node. This "pulls the string" tight.
                    }

                    const nextPoint = character.path[0];
                    const angleToNextPoint = Math.atan2(nextPoint.y - character.y, nextPoint.x - character.x);
                    dx = Math.cos(angleToNextPoint);
                    dy = Math.sin(angleToNextPoint);
                    character.aimAngle = angleToNextPoint; // Aim where we are going

                    // Check if we are close enough to the current waypoint to move to the next one.
                    if (distSq(character.x, character.y, nextPoint.x, nextPoint.y) < 900) { // Increased radius to 30*30
                        character.path.shift();
                    }
                }
                // --- END NEW AI Movement Logic ---
            }
            
            const speed = character.id === 'player' ? moveSpeed : aiMoveSpeed;
            const mag = Math.sqrt(dx*dx + dy*dy);
            if (mag > 0) resolveMovementWithCollision(character, dx/mag*speed*deltaTime, dy/mag*speed*deltaTime);

            if (character.id === 'player') {
                if (gameSettings.useJoysticks && shootingJoystick?.isActive && (shootingJoystick.vector.x !== 0 || shootingJoystick.vector.y !== 0)) { 
                    character.aimAngle = Math.atan2(shootingJoystick.vector.y, shootingJoystick.vector.x); 
                } else { 
                    const camX = allCharacters.find(c => c.id === 'player')?.x || mapCenter.x; 
                    const camY = allCharacters.find(c => c.id === 'player')?.y || mapCenter.y; 
                    const worldX = (mousePos.x - canvasWidth / 2) / cameraZoom + camX; 
                    const worldY = (mousePos.y - canvasHeight / 2) / cameraZoom + camY; 
                    character.aimAngle = Math.atan2(worldY - character.y, worldX - character.x); 
                }
            }
            
            if(character.fireCooldown > 0) character.fireCooldown--;
            if(character.burstCooldown > 0) character.burstCooldown--;

            if (character.isReloading) {
                character.reloadTimer -= deltaTime;
                if (character.reloadTimer <= 0) {
                    character.isReloading = false;
                    character.ammo = character.clipSize;
                }
            } else if ((character.id === 'player' && keysDown['r'] && character.ammo < character.clipSize) || character.ammo <= 0) {
                 character.isReloading = true; 
                 character.reloadTime = 2; 
                 character.reloadTimer = character.reloadTime;
            }

            if (character.isBursting && character.fireCooldown <= 0 && character.burstsLeft > 0) {
                const targetX = character.x + Math.cos(character.aimAngle) * 100;
                const targetY = character.y + Math.sin(character.aimAngle) * 100;
                createBullet(character.x, character.y, targetX, targetY, character.id, character.team);
                character.fireCooldown = BURST_FIRE_RATE;
                character.burstsLeft--;
                character.ammo--;
                if (character.burstsLeft === 0) {
                    character.isBursting = false;
                    character.burstCooldown = BURST_COOLDOWN_TIME;
                }
            } else if (isShooting && !character.isBursting && character.burstCooldown <= 0 && !character.isReloading && character.ammo > 0) {
                character.isBursting = true;
                character.burstsLeft = Math.min(BURST_COUNT, character.ammo);
                character.fireCooldown = 0;
            }
            
            if (gameMode === '3v3' || gameMode === '2v2' || gameMode === '1v1') {
                if (!bombItem.isCarried && character.team === roundState.attackingTeam && distSq(character.x, character.y, bombItem.x, bombItem.y) < (character.radius + bombItem.radius)**2) {
                    bombItem.isCarried = true; character.hasBomb = true;
                }
                if (character.id === 'player' && character.hasBomb && !bomb.planted) {
                    const site = nearActiveBombSite(character);
                    if (site && (isPlantingButtonHeld || keysDown['e'])) {
                        character.isPlanting = true; character.plantTimer += deltaTime;
                        if (character.plantTimer >= BOMB_PLANT_TIME) plantBomb(character, site);
                    } else {
                        character.isPlanting = false; character.plantTimer = 0;
                    }
                }
            }
        });
    }
    
    function updateGameTimers(deltaTime) {
        if (gameMode === '3v3' || gameMode === '2v2' || gameMode === '1v1') {
            if (!inRoundTransition && isRoundActive && !bomb.planted) {
                if (gameState.gameTimer > 0) gameState.gameTimer -= deltaTime;
                else {
                    const defendingTeam = roundState.attackingTeam === 1 ? 2 : 1;
                    declareRoundWinner(defendingTeam, "Time Expired");
                    return;
                }
            }
            if (bomb.planted && bomb.active) { 
                bomb.timer += deltaTime; 
                if (bomb.timer >= BOMB_TIMER_DURATION) { 
                    bomb.active = false;
                    bomb.isExploded = true; 
                    gameTimerBar.textContent = '0';
                    isDetonationSequenceActive = true;
                    detonationCameraTarget = { x: bomb.x, y: bomb.y };
                    screenShake = { intensity: 20, duration: 3.0 };
                    setTimeout(() => {
                        declareRoundWinner(bomb.plantedByTeam, "Bomb Detonated"); 
                        isDetonationSequenceActive = false;
                        detonationCameraTarget = null;
                    }, 3000);
                } 
            }
            if (bombPlantedTextTimer > 0) bombPlantedTextTimer -= deltaTime;
            if (roundStartTextTimer > 0) roundStartTextTimer -= deltaTime;
        }
    }
    
    function checkWinCondition() {
        if (isGameOver || inRoundTransition || !isRoundActive) return;
        if (gameMode === '3v3' || gameMode === '2v2' || gameMode === '1v1') {
            const attackersAlive = allCharacters.some(c => c.team === roundState.attackingTeam && c.hp > 0);
            const defendersAlive = allCharacters.some(c => c.team !== roundState.attackingTeam && c.hp > 0);
            const defendingTeam = roundState.attackingTeam === 1 ? 2 : 1;

            if (!attackersAlive && !defendersAlive) {
                if (bomb.planted) {
                    declareRoundWinner(roundState.attackingTeam, "All players eliminated");
                } else {
                    declareRoundWinner(defendingTeam, "All players eliminated");
                }
                return; 
            }

            if (!defendersAlive) {
                declareRoundWinner(roundState.attackingTeam, "Defenders Eliminated");
            } else if (!attackersAlive && !bomb.planted) {
                declareRoundWinner(defendingTeam, "Attackers Eliminated");
            }
        }
    }
    
    function showRoundScoreboard(winnerText, mvpId = null) {
        roundScoreboardElement.style.display = 'flex';
        roundWinnerTextElement.textContent = winnerText;
        const roundScoreContainer = document.getElementById('round-end-match-score');
        roundScoreContainer.innerHTML = '';
        
        const roundsToWin = gameMode === '1v1' ? 3 : 3;
        for (let i = 1; i <= roundsToWin; i++) {
            const scoreBox = document.createElement('div');
            scoreBox.className = roundState.blueScore >= i ? 'score-box blue-win' : 'score-box';
            roundScoreContainer.appendChild(scoreBox);
        }
        
        const vs = document.createElement('span');
        vs.className = 'vs-text';
        vs.textContent = 'VS';
        roundScoreContainer.appendChild(vs);

        for (let i = 1; i <= roundsToWin; i++) {
            const scoreBox = document.createElement('div');
            scoreBox.className = roundState.redScore >= i ? 'score-box red-win' : 'score-box';
            roundScoreContainer.appendChild(scoreBox);
        }
        
        scoreboardBlueTeam.innerHTML = '';
        scoreboardRedTeam.innerHTML = '';
        const sortedPlayers = [...allCharacters].sort((a, b) => b.score - a.score);

        sortedPlayers.forEach(p => {
            const playerRow = document.createElement('div');
            playerRow.className = 'scoreboard-player-row';
            
            let nameHTML = `<div class="player-name-cell">${p.name}`;
            if (p.id === mvpId) {
                nameHTML += `<span class="mvp-sticker">MVP</span>`;
            }
            nameHTML += `</div>`;

            playerRow.innerHTML = `
                ${nameHTML}
                <div class="col-stat">${p.kills}</div>
                <div class="col-stat">${p.assists}</div>
                <div class="col-stat">${p.plants}</div>
                <div class="col-stat">${p.defuses}</div>
                <div class="col-stat">${p.score}</div>
            `;

            if (p.team === 1) scoreboardBlueTeam.appendChild(playerRow);
            else scoreboardRedTeam.appendChild(playerRow);
        });
        showScreen('scoreboard-overlay');
    }
    
    function drawBombSites(g = ctx) { bombSites.forEach(site => { g.save(); g.beginPath(); g.arc(site.x, site.y, site.radius, 0, Math.PI * 2); g.strokeStyle = bomb.siteId === site.id && bomb.active ? 'rgba(255, 80, 80, 0.9)' : 'rgba(255,255,255,0.4)'; g.lineWidth = 4; g.setLineDash([10, 10]); g.stroke(); g.fillStyle = bomb.siteId === site.id && bomb.active ? 'rgba(255, 80, 80, 0.2)' : 'rgba(255,255,255,0.1)'; g.fill(); g.fillStyle = 'rgba(255,255,255,0.8)'; g.font = 'bold 48px Courier New'; g.textAlign = 'center'; g.textBaseline = 'middle'; g.fillText(site.id, site.x, site.y); g.restore(); }); }
    function drawBomb(x, y, isPlanted, isFlashing, g = ctx) { const color = isPlanted && isFlashing ? 'red' : '#333'; g.fillStyle = color; g.fillRect(x - 10, y - 5, 20, 10); g.fillStyle = '#555'; g.fillRect(x - 2, y - 8, 4, 3); }
    
    
    function isObjectVisible(rect, cameraTarget) {
        if(!cameraTarget) return false;
        const corners = [{ x: rect.x, y: rect.y }, { x: rect.x + rect.w, y: rect.y }, { x: rect.x, y: rect.y + rect.h }, { x: rect.x + rect.w, y: rect.y + rect.h }];
        for (const corner of corners) {
            if (distSq(cameraTarget.x, cameraTarget.y, corner.x, corner.y) <= lightRadius * lightRadius && hasLineOfSight(cameraTarget, corner, rect.id)) {
                return true;
            }
        }
        return false;
    }
    
    function drawBombItem(g = ctx, visibilityPolygon, itemToDraw, cameraTarget) {
        if (itemToDraw.isCarried || bomb.planted) return;
        const rect = {id: 'bomb', x: itemToDraw.x - 10, y: itemToDraw.y - 5, w: 20, h: 10};
        if (isObjectVisible(rect, cameraTarget)) {
            drawBomb(itemToDraw.x, itemToDraw.y, false, false, g);
        }
    }

    function drawBombObject(g = ctx, visibilityPolygon, bombToDraw, cameraTarget) {
        if (!bombToDraw.planted || bombToDraw.isExploded) return;
        const rect = {id: 'bomb', x: bombToDraw.x - 10, y: bombToDraw.y - 5, w: 20, h: 10};
        if (isObjectVisible(rect, cameraTarget)) {
            const isFlashing = Math.floor(performance.now() / 500) % 2 === 0;
            drawBomb(bombToDraw.x, bombToDraw.y, true, isFlashing, g);
        }
    }
    function drawDesertBackground(g = ctx) { if(!mapWidth || !mapHeight) return; const baseGradient = g.createRadialGradient(mapCenter.x, mapCenter.y, mapHeight * 0.1, mapCenter.x, mapCenter.y, mapHeight); baseGradient.addColorStop(0, '#E7D3A1'); baseGradient.addColorStop(1, '#CDBA96'); g.fillStyle = baseGradient; g.fillRect(0,0,mapWidth, mapHeight); dunes.forEach(dune => { g.save(); g.translate(dune.x + 8, dune.y + 6); g.rotate(dune.rotation); g.scale(dune.radiusX, dune.radiusY); g.beginPath(); g.arc(0, 0, 1, 0, Math.PI * 2); g.fillStyle = dune.shadowColor; g.fill(); g.restore(); }); dunes.forEach(dune => { g.save(); g.beginPath(); g.translate(dune.x, dune.y); g.rotate(dune.rotation); g.scale(dune.radiusX, dune.radiusY); g.arc(0, 0, 1, 0, Math.PI * 2); g.fillStyle = dune.color; g.fill(); g.restore(); }); sandSpecks.forEach(s => { if (s.type === 'circle') { drawCircle(s.x, s.y, s.r, s.c, g) } else { g.beginPath(); g.moveTo(s.x, s.y); g.lineTo(s.x + 1 + Math.random() * 2, s.y); g.strokeStyle = s.c; g.stroke(); } }); const lightGradient = g.createRadialGradient(mapCenter.x, mapCenter.y, mapHeight * 0.2, mapCenter.x, mapCenter.y, mapHeight * 1.5); lightGradient.addColorStop(0, 'rgba(255, 245, 230, 0.02)'); lightGradient.addColorStop(1, 'rgba(0, 0, 0, 0.05)'); g.fillStyle = lightGradient; g.fillRect(0, 0, mapWidth, mapHeight); }
    
    function drawGame(timestamp, frameState = null) {
        const currentState = {
            characters: frameState ? frameState.characters : allCharacters,
            bullets: frameState ? frameState.bullets : bullets,
            bomb: frameState ? frameState.bomb : bomb,
            bombItem: frameState ? frameState.bombItem : bombItem,
            particles: frameState ? frameState.particles : particles,
            obstacles: frameState ? frameState.obstacles : obstacles
        };
        
        let cameraTarget;
        if (isDetonationSequenceActive) {
            cameraTarget = detonationCameraTarget;
        } else if (isKillCamActive) {
            cameraTarget = currentState.characters.find(c => c.id === finalKillerId) || { x: mapCenter.x, y: mapCenter.y };
        } else {
            cameraTarget = currentState.characters.find(c => c.id === spectatingId || (c.id === 'player' && !spectatingId)) || { x: mapCenter.x, y: mapCenter.y };
        }

        if (!cameraTarget) { // Fallback if camera target becomes null
            cameraTarget = { x: mapCenter.x, y: mapCenter.y };
        }
        
        const player = currentState.characters.find(c => c.id === 'player');
        
        const allSegments = losSegments.concat([
            { p1: {x:0, y:0}, p2: {x:mapWidth, y:0} }, { p1: {x:mapWidth, y:0}, p2: {x:mapWidth, y:mapHeight} },
            { p1: {x:mapWidth, y:mapHeight}, p2: {x:0, y:mapHeight} }, { p1: {x:0, y:mapHeight}, p2: {x:0, y:0} }
        ]);
        const visibilityPolygon = calculateVisibility(cameraTarget, allSegments);
        
        ctx.save();
        ctx.clearRect(0, 0, gameCanvas.width, gameCanvas.height);
        
        if (screenShake.intensity > 0) {
            ctx.translate(
                Math.random() * screenShake.intensity - screenShake.intensity / 2,
                Math.random() * screenShake.intensity - screenShake.intensity / 2
            );
        }

        ctx.translate(gameCanvas.width / 2, gameCanvas.height / 2);
        ctx.scale(cameraZoom, cameraZoom);
        ctx.translate(-cameraTarget.x, -cameraTarget.y);
        
        drawDesertBackground(ctx);
        drawFloors(ctx);
        drawWalls(ctx, currentState.obstacles);
        drawBombSites(ctx);
        currentState.obstacles.forEach(obs => { if (obs.type === 'crate') drawCrate(obs, ctx); });
        drawBombItem(ctx, visibilityPolygon, currentState.bombItem, cameraTarget);
        drawBombObject(ctx, visibilityPolygon, currentState.bomb, cameraTarget);
        
        currentState.characters.forEach(char => drawCharacter(char, ctx, cameraTarget, player));
        currentState.bullets.forEach(b => drawCircle(b.x, b.y, bulletRadius, b.color, ctx));
        currentState.particles.forEach(p => { ctx.globalAlpha = p.alpha; drawCircle(p.x, p.y, p.radius, p.color, ctx); ctx.globalAlpha = 1; });
        ctx.restore();

        // --- FOG OF WAR ---
        fogCtx.clearRect(0, 0, fogCanvas.width, fogCanvas.height);
        fogCtx.fillStyle = 'rgba(26,26,26,0.9)'; // Use body background color for fog
        fogCtx.fillRect(0, 0, fogCanvas.width, fogCanvas.height);
        
        fogCtx.save();
        fogCtx.translate(fogCanvas.width / 2, fogCanvas.height / 2);
        fogCtx.scale(cameraZoom, cameraZoom);
        fogCtx.translate(-cameraTarget.x, -cameraTarget.y);
        fogCtx.globalCompositeOperation = 'destination-out';

        if (visibilityPolygon.length > 0) {
            fogCtx.beginPath();
            fogCtx.moveTo(visibilityPolygon[0].x, visibilityPolygon[0].y);
            for (let i = 1; i < visibilityPolygon.length; i++) fogCtx.lineTo(visibilityPolygon[i].x, visibilityPolygon[i].y);
            fogCtx.closePath();
            fogCtx.fillStyle = 'white'; fogCtx.fill();
        }
        
        currentState.obstacles.forEach(obs => {
            if (isObjectVisible(obs, cameraTarget)) {
                fogCtx.fillRect(obs.x, obs.y, obs.w, obs.h);
            }
        });

        fogCtx.restore();
        ctx.drawImage(fogCanvas, 0, 0);
        // --- END FOG OF WAR ---

        if (!isKillCamActive) {
            if (gameSettings.useJoysticks) { 
                if (movementJoystick && movementJoystick.isActive) movementJoystick.draw(ctx);
                if (shootingJoystick && shootingJoystick.isActive) shootingJoystick.draw(ctx);
            }
            if(!inRoundTransition) updateUI(currentState);
            drawMinimap(currentState);
        } else {
             gameUiElement.style.display = 'none';
        }
    }
    
    function updateUI(currentState) {
        const player = currentState.characters.find(c => c.id === 'player');
        if (player) {
            ammoCounterElement.textContent = `${player.isReloading ? 'Reloading...' : player.ammo + ' / ' + player.clipSize}`;
            playerNameDisplay.textContent = player.name;
            const hpPercent = Math.max(0, player.hp / initialHitPoints) * 100;
            playerHealthBar.style.width = `${hpPercent}%`;
        }
        
        tdmUiContainer.style.display = (gameMode === '3v3' || gameMode === '2v2' || gameMode === '1v1') ? 'flex' : 'none';
        if (plantBombButton) plantBombButton.style.display = 'none';

        if (gameMode === '3v3' || gameMode === '2v2' || gameMode === '1v1') {
            updateTeamStatusUI(currentState.characters);

            if (currentState.bomb.planted) {
                gameTimerBar.style.color = '#FF4747';
                const timeLeft = BOMB_TIMER_DURATION - currentState.bomb.timer;
                gameTimerBar.textContent = Math.max(0, Math.ceil(timeLeft));
            } else {
                gameTimerBar.style.color = '#FFF8DC';
                const minutes = Math.floor(Math.max(0, gameState.gameTimer) / 60);
                const seconds = Math.floor(Math.max(0, gameState.gameTimer) % 60);
                gameTimerBar.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
            }
            
            if (roundStartTextTimer > 0 && player) {
                gameEventText.style.display = 'block';
                gameEventText.style.color = '#FFF8DC';
                gameEventText.textContent = player.team === roundState.attackingTeam ? 'Destroy The Objectives' : 'Defend The Objectives';
            } else if (bombPlantedTextTimer > 0) {
                gameEventText.style.display = 'block';
                gameEventText.style.color = '#FF4747';
                gameEventText.textContent = 'Bomb Planted';
            } else gameEventText.style.display = 'none';

            blueScoreDisplay.textContent = roundState.blueScore;
            redScoreDisplay.textContent = roundState.redScore;
            teamRoleDisplay.textContent = roundState.attackingTeam === player?.team ? 'ATTACKER' : 'DEFENDER';
            
            if(player?.hasBomb) {
                if(bombIconContainer) bombIconContainer.style.display = 'block';
                const site = nearActiveBombSite(player);
                if (site) {
                    if(plantBombButton) plantBombButton.style.display = 'block';
                    if (player.isPlanting) {
                        const plantProgress = (player.plantTimer / BOMB_PLANT_TIME) * 100;
                        plantBombButton.style.background = `linear-gradient(to right, #6c757d ${plantProgress}%, #4a4a4a ${plantProgress}%)`;
                        plantBombButton.textContent = 'Planting...';
                    } else {
                        plantBombButton.style.background = '#4a4a4a';
                        plantBombButton.textContent = 'Hold to Plant';
                    }
                }
            } else {
                if (bombIconContainer) bombIconContainer.style.display = 'none';
            }
        }
        spectateControls.style.display = spectatingId ? 'flex' : 'none';
    }

    function initializeCharacters() {
        allCharacters = [];
        let aiCounter = 1;
        const team1Colors = ['#4682B4', '#6495ED', '#87CEEB'];
        const team2Colors = ['#DC143C', '#B22222', '#8B0000'];
        
        const leftSpawns = tdmSpawnPoints.filter(p => p.x < mapCenter.x);
        const rightSpawns = tdmSpawnPoints.filter(p => p.x > mapCenter.x);
        
        const getUniqueSpawn = (spawnList) => spawnList.length === 0 ? { x: mapCenter.x, y: mapCenter.y } : spawnList.splice(Math.floor(Math.random() * spawnList.length), 1)[0];

        const team1IsAttacker = roundState.attackingTeam === 1;
        const team1SpawnList = [...(team1IsAttacker ? leftSpawns : rightSpawns)];
        const team2SpawnList = [...(team1IsAttacker ? rightSpawns : leftSpawns)];
        
        if (gameMode === '1v1') {
            allCharacters.push(createCharacter({id:'player', name:'You', team:1, color:team1Colors[0], ...getUniqueSpawn(team1SpawnList)}));
            allCharacters.push(createCharacter({id:'enemy1', name: `AI ${aiCounter++}`, team:2, color:team2Colors[0], ...getUniqueSpawn(team2SpawnList)}));
        } else if(gameMode === '2v2') {
            allCharacters.push(createCharacter({id:'player', name:'You', team:1, color:team1Colors[0], ...getUniqueSpawn(team1SpawnList)}));
            allCharacters.push(createCharacter({id:'ally1',  name:`AI ${aiCounter++}`, team:1, color:team1Colors[1], ...getUniqueSpawn(team1SpawnList)}));
            allCharacters.push(createCharacter({id:'enemy1', name:`AI ${aiCounter++}`, team:2, color:team2Colors[0], ...getUniqueSpawn(team2SpawnList)}));
            allCharacters.push(createCharacter({id:'enemy2', name:`AI ${aiCounter++}`, team:2, color:team2Colors[1], ...getUniqueSpawn(team2SpawnList)}));
        } else {
            allCharacters.push(createCharacter({id:'player', name:'You', team:1, color:team1Colors[0], ...getUniqueSpawn(team1SpawnList)}));
            allCharacters.push(createCharacter({id:'ally1',  name:`AI ${aiCounter++}`, team:1, color:team1Colors[1], ...getUniqueSpawn(team1SpawnList)}));
            allCharacters.push(createCharacter({id:'ally2',  name:`AI ${aiCounter++}`, team:1, color:team1Colors[2], ...getUniqueSpawn(team1SpawnList)}));
            allCharacters.push(createCharacter({id:'enemy1', name:`AI ${aiCounter++}`, team:2, color:team2Colors[0], ...getUniqueSpawn(team2SpawnList)}));
            allCharacters.push(createCharacter({id:'enemy2', name:`AI ${aiCounter++}`, team:2, color:team2Colors[1], ...getUniqueSpawn(team2SpawnList)}));
            allCharacters.push(createCharacter({id:'enemy3', name:`AI ${aiCounter++}`, team:2, color:team2Colors[2], ...getUniqueSpawn(team2SpawnList)}));
        }
    }
    
    function startRound() {
        inRoundTransition = false;
        spectatingId = null; spectatablePlayers = []; isRoundActive = false; isKillCamActive = false;
        bullets = []; floatingTexts = []; particles = []; historyBuffer = []; lastKillInfo = null;
        bomb = { active: false, planted: false, isExploded: false, timer: 0, siteId: null, plantedByTeam: null, plantedById: null };
        bombItem.isCarried = false; bombPlantedTextTimer = 0; roundStartTextTimer = 5; 
        if (gameState) gameState.gameTimer = 120; 

        roundState.roundNumber++; roundState.attackingTeam = (roundState.roundNumber % 2 === 1) ? 1 : 2; 
        const playerStats = allCharacters.map(p => ({ id: p.id, kills: p.kills, assists: p.assists, plants: p.plants, defuses: p.defuses, score: p.score }));
        initializeCharacters();

        allCharacters.forEach(p => {
            const stats = playerStats.find(s => s.id === p.id);
            if (stats) { p.kills = stats.kills; p.assists = stats.assists; p.plants = p.plants; p.defuses = p.defuses; p.score = stats.score; }
        });
        
        const attackers = allCharacters.filter(p => p.team === roundState.attackingTeam);
        if(attackers.length > 0) {
            const attackerSpawnX = attackers.reduce((sum, p) => sum + p.x, 0) / attackers.length;
            const attackerSpawnY = attackers.reduce((sum, p) => sum + p.y, 0) / attackers.length;
            const offset = (attackerSpawnX < mapCenter.x) ? 120 : -120;
            bombItem.x = attackerSpawnX + offset; bombItem.y = attackerSpawnY;
        }
        
        if (roundState.roundNumber === 1) displayMatchupScreen(); else displayRoundCountdown();
    }

    function displayMatchupScreen() {
        showScreen('matchup-screen');
        const matchupBgCtx = matchupBgCanvas.getContext('2d');
        matchupBgCanvas.width = window.innerWidth; matchupBgCanvas.height = window.innerHeight;
        matchupBgCtx.drawImage(offscreenMinimapCanvas, 0, 0, matchupBgCanvas.width, matchupBgCanvas.height);
        matchupBlueTeamContainer.innerHTML = ''; matchupRedTeamContainer.innerHTML = '';

        const createPlayerCard = (character) => {
            const card = document.createElement('div'); card.className = 'matchup-player-card';
            const portraitCanvas = document.createElement('canvas');
            portraitCanvas.width = 60; portraitCanvas.height = 60;
            drawPlayerPortrait(portraitCanvas, character);
            const nameDiv = document.createElement('div');
            nameDiv.className = 'player-name'; nameDiv.textContent = character.name;
            card.appendChild(portraitCanvas); card.appendChild(nameDiv);
            return card;
        };

        allCharacters.forEach(char => {
            if (char.team === 1) matchupBlueTeamContainer.appendChild(createPlayerCard(char));
            else matchupRedTeamContainer.appendChild(createPlayerCard(char));
        });
        setTimeout(() => displayRoundCountdown(), 4000); 
    }
    
    function displayRoundCountdown() {
        showScreen('game'); 
        let count = 2;
        roundCountdownElement.style.display = 'block'; roundCountdownElement.textContent = count;
        
        const countdownInterval = setInterval(() => {
            count--;
            if (count > 0) roundCountdownElement.textContent = count;
            else {
                clearInterval(countdownInterval);
                roundCountdownElement.style.display = 'none';
                isRoundActive = true;
                lastTimestamp = performance.now();
            }
        }, 1000);
        
        lastTimestamp = performance.now();
        if (animationFrameId) cancelAnimationFrame(animationFrameId);
        animationFrameId = requestAnimationFrame(gameLoop);
    }

    function drawFullMapToOffscreenCanvas() {
        if (!mapWidth || !mapHeight) return;
        offscreenMinimapCanvas = document.createElement('canvas');
        offscreenMinimapCanvas.width = mapWidth; offscreenMinimapCanvas.height = mapHeight;
        offscreenMinimapCtx = offscreenMinimapCanvas.getContext('2d');
        drawDesertBackground(offscreenMinimapCtx);
        drawFloors(offscreenMinimapCtx);
        drawWalls(offscreenMinimapCtx, obstacles);
        obstacles.forEach(obs => { if (obs.type === 'crate') drawCrate(obs, offscreenMinimapCtx); });
        drawBombSites(offscreenMinimapCtx);
    }

    function startGame(mode) {
        isGameOver = false; gameMode = mode;
        generateMapLayout(); generateSandPattern(); drawFullMapToOffscreenCanvas(); 
        roundState = { blueScore: 0, redScore: 0, roundNumber: 0 };
        gameState = { gameMode: mode, gameTimer: 120, currentRadius: Infinity };
        startRound();
    }
    
    function endGame(winner) {
        if (isGameOver) return;
        isGameOver = true;
        finalWinnerTitleElement.textContent = `${winner} Wins!`;
        const finalScoreContainer = document.getElementById('final-match-score');
        finalScoreContainer.innerHTML = ''; finalScoreContainer.style.display = 'flex';
        const roundsToWin = gameMode === '1v1' ? 3 : 3;

        for(let i=1; i<=roundsToWin; i++){
            const scoreBox = document.createElement('div');
            scoreBox.className = roundState.blueScore >= i ? 'score-box blue-win' : 'score-box';
            finalScoreContainer.appendChild(scoreBox);
        }
        const vs = document.createElement('span');
        vs.className = 'vs-text'; vs.textContent = 'VS';
        finalScoreContainer.appendChild(vs);
        for(let i=1; i<=roundsToWin; i++){
            const scoreBox = document.createElement('div');
            scoreBox.className = roundState.redScore >= i ? 'score-box red-win' : 'score-box';
            finalScoreContainer.appendChild(scoreBox);
        }
        showScreen('game-over');
    }
    
    function leaveMatch() {
        isGameOver = true; isPaused = false; inGameMenuElement.style.display = 'none';
        if (animationFrameId) { cancelAnimationFrame(animationFrameId); animationFrameId = null; }
        showScreen('welcome-screen');
        mainMenuView.style.display = 'block'; singlePlayerMenuView.style.display = 'none';
    }
    
    const allScreenElements = {
        'welcome-screen': welcomeScreenElement, 'settings-menu': settingsMenuElement, 'in-game-menu': inGameMenuElement,
        'scoreboard-overlay': scoreboardOverlay, 'game-over': gameOverElement, 'game': gameUiElement, 'matchup-screen': matchupScreenElement
    };

    function showScreen(screenId) {
        if(screenId === 'scoreboard-overlay' || screenId === 'in-game-menu'){
            allScreenElements[screenId].style.display = 'flex';
            if (screenId === 'in-game-menu') isPaused = true;
            return;
        }
        Object.values(allScreenElements).forEach(el => { if(el) el.style.display = 'none'; });
        gameCanvas.style.display = 'none';
        stopWelcomeAnimation();
        
        if (screenId === 'game') { gameUiElement.style.display = 'block'; gameCanvas.style.display = 'block';
        } else if (allScreenElements[screenId]) {
            allScreenElements[screenId].style.display = 'flex';
             if (screenId === 'welcome-screen') {
                 startWelcomeAnimation();
             }
        }
    }
    
    function updateScreenShake(deltaTime) {
        if (screenShake.duration > 0) {
            screenShake.duration -= deltaTime;
            screenShake.intensity = Math.max(0, screenShake.intensity * 0.95);
        } else {
            screenShake.intensity = 0;
        }
    }

    function gameLoop(timestamp) {
        if (isGameOver || isPaused) {
             if (!isGameOver) requestAnimationFrame(gameLoop);
             return;
        }
        
        const now = performance.now();
        const deltaTime = now - (lastTimestamp || now);
        lastTimestamp = now;

        if (isDetonationSequenceActive) {
            const dtSeconds = deltaTime / 1000;
            updateScreenShake(dtSeconds);
            drawGame(now);
            animationFrameId = requestAnimationFrame(gameLoop);
            return;
        }
        
        if (inRoundTransition && !isKillCamActive) {
            drawGame(timestamp);
            animationFrameId = requestAnimationFrame(gameLoop);
            return;
        }
        
        if (isKillCamActive) {
            if (killCamReplayBuffer.length === 0) {
                 isKillCamActive = false;
                 proceedToScoreboard(postKillCamWinningTeam, postKillCamReason); // Fallback
                 return;
            }

            const killTimeInReplay = lastKillInfo.timestamp - killCamReplayBuffer[0].timestamp;
            const slowMoStartTime = killTimeInReplay - 1500;
            const slowMoEndTime = killTimeInReplay;
            
            let playbackSpeed = 1.0;
            if(killCamReplayClock > slowMoStartTime && killCamReplayClock < slowMoEndTime) {
                playbackSpeed = 0.3;
            }
            killCamReplayClock += deltaTime * playbackSpeed;

            const replayDuration = killCamReplayBuffer[killCamReplayBuffer.length - 1].timestamp - killCamReplayBuffer[0].timestamp;
            if (killCamReplayClock >= replayDuration) {
                isKillCamActive = false;
                proceedToScoreboard(postKillCamWinningTeam, postKillCamReason);
            } else {
                const targetTimestamp = killCamReplayBuffer[0].timestamp + killCamReplayClock;
                let frameIndex = 0;
                for (let i = 0; i < killCamReplayBuffer.length; i++) {
                    if (killCamReplayBuffer[i].timestamp >= targetTimestamp) { frameIndex = i; break; }
                    frameIndex = i;
                }
                const currentFrame = killCamReplayBuffer[frameIndex];
                drawGame(timestamp, currentFrame);
            }

        } else {
            const dtSeconds = deltaTime / 1000;
            
            if (isRoundActive) {
                const charactersForSnapshot = allCharacters.map(c => {
                    const { target, ...safeChar } = c;
                    return safeChar;
                });
                const snapshot = {
                    characters: JSON.parse(JSON.stringify(charactersForSnapshot)),
                    bullets: JSON.parse(JSON.stringify(bullets)),
                    bomb: JSON.parse(JSON.stringify(bomb)),
                    bombItem: JSON.parse(JSON.stringify(bombItem)),
                    particles: JSON.parse(JSON.stringify(particles)),
                    obstacles: JSON.parse(JSON.stringify(obstacles)),
                    timestamp: performance.now()
                };
                historyBuffer.push(snapshot);
                if (historyBuffer.length > MAX_HISTORY_FRAMES) historyBuffer.shift();

                updateCharacters(dtSeconds);
                updateBullets(dtSeconds);
                updateGameTimers(dtSeconds);
                checkWinCondition();
            }
            
            updateScreenShake(dtSeconds);
            updateParticles(dtSeconds);
            drawGame(timestamp);
        }
        
        if (!isGameOver) {
            animationFrameId = requestAnimationFrame(gameLoop);
        }
    }

    function updateBullets(deltaTime) {
        const cameraTarget = allCharacters.find(c => c.id === spectatingId || (c.id === 'player' && !spectatingId)) || { x: mapCenter.x, y: mapCenter.y };

        for (let i = bullets.length - 1; i >= 0; i--) {
            const b = bullets[i];
            b.x += b.dx; b.y += b.dy;
            let hit = false;

            if (distSq(cameraTarget.x, cameraTarget.y, b.x, b.y) > lightRadius * lightRadius) { bullets.splice(i, 1); continue; }

            for(const obs of obstacles) {
                if(b.x > obs.x && b.x < obs.x + obs.w && b.y > obs.y && b.y < obs.y + obs.h) {
                    hit = true;
                    createParticles(b.x, b.y, 5, '#888');
                    obs.hp -= bulletDamage;
                    if (obs.hp <= 0) {
                        obstacles = obstacles.filter(o => o.id !== obs.id);
                        losSegments = losSegments.filter(w => w.ownerId !== obs.id);
                        createPathfindingGrid(); // Regenerate grid if an obstacle is destroyed
                    }
                    break;
                }
            }
            if(hit) { bullets.splice(i, 1); continue; }

            for (const target of allCharacters) {
                if (target.hp > 0 && target.team !== b.team && distSq(b.x, b.y, target.x, target.y) < playerRadius * playerRadius) {
                    const shooter = allCharacters.find(c => c.id === b.owner);
                    applyDamageAndHandleKill(target, shooter, bulletDamage);
                    hit = true; break;
                }
            }
            if (hit || b.x < 0 || b.x > mapWidth || b.y < 0 || b.y > mapHeight) bullets.splice(i, 1);
        }
    }

    function updateParticles(deltaTime) { for (let i = particles.length - 1; i >= 0; i--) { const p = particles[i]; p.x += p.dx; p.y += p.dy; p.lifetime--; p.alpha = p.lifetime / 40; if (p.lifetime <= 0) particles.splice(i, 1); } }
    
    function resolveMovementWithCollision(character, dx, dy) {
        character.x += dx;
        obstacles.forEach(obs => {
            if (character.x + character.radius > obs.x && character.x - character.radius < obs.x + obs.w &&
                character.y + character.radius > obs.y && character.y - character.radius < obs.y + obs.h) {
                if (dx > 0) character.x = obs.x - character.radius; else if (dx < 0) character.x = obs.x + obs.w + character.radius;
            }
        });
        character.y += dy;
        obstacles.forEach(obs => {
            if (character.x + character.radius > obs.x && character.x - character.radius < obs.x + obs.w &&
                character.y + character.radius > obs.y && character.y - character.radius < obs.y + obs.h) {
                if (dy > 0) character.y = obs.y - character.radius; else if (dy < 0) character.y = obs.y + obs.h + character.radius;
            }
        });
        character.x = Math.max(character.radius, Math.min(mapWidth - character.radius, character.x));
        character.y = Math.max(character.radius, Math.min(mapHeight - character.radius, character.y));
    }
    
    function drawCrate(crate, g = ctx) {
        const x = crate.x, y = crate.y, w = crate.w, h = crate.h;
        const baseColor = '#9A6A42', shadowColor = '#6F4E2F', highlightColor = '#B58A5F';
        g.fillStyle = baseColor; g.fillRect(x, y, w, h);
        g.fillStyle = shadowColor;
        g.beginPath(); g.moveTo(x, y + h); g.lineTo(x + 5, y + h - 5); g.lineTo(x + w, y + h - 5); g.lineTo(x + w, y + h); g.closePath(); g.fill();
        g.beginPath(); g.moveTo(x + w, y); g.lineTo(x + w - 5, y + 5); g.lineTo(x + w - 5, y + h); g.lineTo(x + w, y + h); g.closePath(); g.fill();
        g.strokeStyle = shadowColor; g.lineWidth = 2; g.beginPath(); g.moveTo(x, y + h / 2); g.lineTo(x + w, y + h / 2); g.stroke();
        g.strokeStyle = highlightColor; g.lineWidth = 1; g.beginPath(); g.moveTo(x, y + 1); g.lineTo(x + w, y + 1); g.stroke();
    }
    
    function drawWalls(g = ctx, wallsToDraw){wallsToDraw.forEach(obs=>{if(obs.type==='wall'){g.fillStyle='black';g.fillRect(obs.x,obs.y,obs.w,obs.h);if(!obs.isEnclosed){g.strokeStyle='black';g.lineWidth=wallThickness;g.beginPath();if(obs.borders.top)g.moveTo(obs.x,obs.y),g.lineTo(obs.x+obs.w,obs.y);if(obs.borders.bottom)g.moveTo(obs.x,obs.y+obs.h),g.lineTo(obs.x+obs.w,obs.y+obs.h);if(obs.borders.left)g.moveTo(obs.x,obs.y),g.lineTo(obs.x,obs.y+obs.h);if(obs.borders.right)g.moveTo(obs.x+obs.w,obs.y),g.lineTo(obs.x+obs.w,obs.y+obs.h);g.stroke();g.strokeStyle=wallColor;g.lineWidth=wallThickness-4;g.beginPath();if(obs.borders.top)g.moveTo(obs.x,obs.y),g.lineTo(obs.x+obs.w,obs.y);if(obs.borders.bottom)g.moveTo(obs.x,obs.y+obs.h),g.lineTo(obs.x+obs.w,obs.y+obs.h);if(obs.borders.left)g.moveTo(obs.x,obs.y),g.lineTo(obs.x,obs.y+obs.h);if(obs.borders.right)g.moveTo(obs.x+obs.w,obs.y),g.lineTo(obs.x+obs.w,obs.y+obs.h);g.stroke();}}});}

    function drawFloors(g = ctx){if(floorTiles.length===0)return;g.fillStyle=floorColor;floorTiles.forEach(tile=>g.fillRect(tile.x,tile.y,tile.w,tile.h));}
    
    function drawCharacter(character, g = ctx, cameraTarget, player) {
        const charHp = character.hp !== undefined ? character.hp : 0;
        if (charHp <= 0) return;

        let isVisible = false;
        if (distSq(cameraTarget.x, cameraTarget.y, character.x, character.y) <= lightRadius * lightRadius) {
            if (hasLineOfSight(cameraTarget, character)) isVisible = true;
        }
        if(isVisible){
            drawCircle(character.x+3,character.y+3,character.radius,'rgba(0,0,0,0.2)', g);
            g.save(); g.translate(character.x,character.y); g.rotate(character.aimAngle);
            g.fillStyle='#222'; g.fillRect(character.radius, -3, 8, 6); g.restore();
            drawCircle(character.x,character.y,character.radius,character.color, g);
            if (player && character.id !== player.id && character.team === player.team) drawHPBar(character.x,character.y,charHp,initialHitPoints,character.radius,'#4CAF50', g);
            g.fillStyle = 'white'; g.textAlign = 'center'; g.font = '12px Courier New';
            g.fillText(character.name, character.x, character.y + character.radius + 12);
        }
    }

    function drawHPBar(x, y, currentHP, maxHP, radius, color, g = ctx) { const barWidth = radius*2; const barHeight = 5; const barX = x - radius; const barY = y - radius - barHeight - 5; g.fillStyle = '#555'; g.fillRect(barX, barY, barWidth, barHeight); const hpRatio = Math.max(0, currentHP/maxHP); g.fillStyle = color; g.fillRect(barX, barY, barWidth*hpRatio, barHeight);}
    function drawCircle(x, y, radius, color, g = ctx) { g.fillStyle = color; g.beginPath(); g.arc(x, y, radius, 0, Math.PI * 2); g.fill(); }
    
    function initialize() {
        threeVThreeButton.onclick = () => startGame('3v3');
        twoVTwoButton.onclick = () => startGame('2v2');
        oneVOneButton.onclick = () => startGame('1v1');
        mainMenuSettingsButton.onclick = () => { previousView = 'welcome-screen'; showScreen('settings-menu'); };
        showSpMenuButton.onclick = () => { mainMenuView.style.display = 'none'; singlePlayerMenuView.style.display = 'block'; };
        spBackButton.onclick = () => { singlePlayerMenuView.style.display = 'none'; mainMenuView.style.display = 'block'; };
        backButton.onclick = () => { 
            settingsMenuElement.style.display = 'none';
            if (previousView === 'in-game-menu') inGameMenuElement.style.display = 'flex';
            else { showScreen('welcome-screen'); mainMenuView.style.display = 'block'; singlePlayerMenuView.style.display = 'none'; }
        };
        joystickToggle.onchange = () => { gameSettings.useJoysticks = joystickToggle.checked; };
        playAgainButton.onclick = () => { showScreen('welcome-screen'); };
        inGameMenuButton.onclick = () => {
            isPaused = !isPaused;
            inGameMenuElement.style.display = isPaused ? 'flex' : 'none';
        };
        resumeButton.onclick = () => {
             isPaused = false;
             inGameMenuElement.style.display = 'none';
             lastTimestamp = performance.now(); // Prevents a time jump
             requestAnimationFrame(gameLoop);
        };
        leaveMatchButton.onclick = leaveMatch;
        spectatePrevButton.onclick = () => cycleSpectator(-1);
        spectateNextButton.onclick = () => cycleSpectator(1);
        tdmUiContainer.onclick = () => { if(isRoundActive && !inRoundTransition){ scoreboardOverlay.style.display = 'flex'; showRoundScoreboard("Scoreboard"); } };
        scoreboardOverlay.onclick = (e) => { if(e.target === scoreboardOverlay && !inRoundTransition) scoreboardOverlay.style.display = 'none'; };

        const reloadWeapon = () => {
            const player = allCharacters.find(c => c.id === 'player');
            if (player && !player.isReloading && player.ammo < player.clipSize) {
                player.isReloading = true;
                player.reloadTimer = player.reloadTime;
            }
        };

        ammoCounterElement.addEventListener('click', reloadWeapon);
        ammoCounterElement.addEventListener('touchstart', (e) => {
            e.preventDefault();
            reloadWeapon();
        });


        document.addEventListener('keydown', (event) => { const key=event.key.toLowerCase(); if(key in keysDown) keysDown[key]=true; if(key===' ') event.preventDefault(); if(key === 'escape' && !isGameOver && gameCanvas.style.display === 'block') { isPaused = !isPaused; inGameMenuElement.style.display = isPaused ? 'flex' : 'none'; if (!isPaused) { lastTimestamp = performance.now(); requestAnimationFrame(gameLoop); } } });
        document.addEventListener('keyup', (event) => { const key=event.key.toLowerCase(); if(key in keysDown)keysDown[key]=false; });
        gameCanvas.addEventListener('mousedown', (e) => handlePointerDown(e));
        document.addEventListener('mousemove', (e) => handlePointerMove(e));
        document.addEventListener('mouseup', (e) => handlePointerUp(e));
        gameCanvas.addEventListener('touchstart', (e) => handlePointerDown(e));
        gameCanvas.addEventListener('touchmove', (e) => handlePointerMove(e));
        gameCanvas.addEventListener('touchend', (e) => handlePointerUp(e));
        gameCanvas.addEventListener('touchcancel', (e) => handlePointerUp(e));
        
        if (plantBombButton) {
            plantBombButton.addEventListener('mousedown', () => isPlantingButtonHeld = true);
            plantBombButton.addEventListener('mouseup', () => isPlantingButtonHeld = false);
            plantBombButton.addEventListener('mouseleave', () => isPlantingButtonHeld = false);
            plantBombButton.addEventListener('touchstart', (e) => { e.preventDefault(); isPlantingButtonHeld = true; });
            plantBombButton.addEventListener('touchend', (e) => { e.preventDefault(); isPlantingButtonHeld = false; });
        }
        
        gameCanvas.width = 800; gameCanvas.height = 600; 
        minimapCanvas.width = 150; minimapCanvas.height = 150;
        fogCanvas = document.createElement('canvas');
        fogCanvas.width = gameCanvas.width; fogCanvas.height = gameCanvas.height;
        fogCtx = fogCanvas.getContext('2d');
        window.addEventListener('resize', resizeCanvas);
        
        setTimeout(() => {
            window.scrollTo(0, 1);
        }, 0);

        resizeCanvas();
        showScreen('welcome-screen');
    }

    function handlePointerDown(e) { if (!gameSettings.useJoysticks) return; e.preventDefault(); const touches = e.changedTouches || [e]; const rect = gameCanvas.getBoundingClientRect(); for(let i=0; i<touches.length; i++) { const touch = touches[i]; const touchX = touch.clientX - rect.left; const touchY = touch.clientY - rect.top; if (touchX < canvasWidth / 2) { if(!movementJoystick) movementJoystick = new Joystick(touchX, touchY, 50, 25); movementJoystick.baseX = touchX; movementJoystick.baseY = touchY; movementJoystick.isActive = true; movementJoystick.touchId = touch.identifier; movementJoystick.update(touchX, touchY); } else { if(!shootingJoystick) shootingJoystick = new Joystick(touchX, touchY, 50, 25); shootingJoystick.baseX = touchX; shootingJoystick.baseY = touchY; shootingJoystick.isActive = true; shootingJoystick.touchId = touch.identifier; shootingJoystick.update(touchX, touchY); } } }
    function handlePointerMove(e) { e.preventDefault(); const rect = gameCanvas.getBoundingClientRect(); const touches = e.changedTouches || [e]; if (touches.length > 0) { mousePos.x = touches[0].clientX - rect.left; mousePos.y = touches[0].clientY - rect.top; } if (!gameSettings.useJoysticks) return; for(let i=0; i<touches.length; i++) { const touch = touches[i]; const touchX = touch.clientX - rect.left; const touchY = touch.clientY - rect.top; if (movementJoystick && movementJoystick.isActive && movementJoystick.touchId === touch.identifier) movementJoystick.update(touchX, touchY); if (shootingJoystick && shootingJoystick.isActive && shootingJoystick.touchId === touch.identifier) shootingJoystick.update(touchX, touchY); } }
    function handlePointerUp(e) { if (!gameSettings.useJoysticks) return; e.preventDefault(); const touches = e.changedTouches || [e]; for(let i=0; i<touches.length; i++) { const touch = touches[i]; if (movementJoystick && movementJoystick.touchId === touch.identifier) movementJoystick.reset(); if (shootingJoystick && shootingJoystick.isActive && shootingJoystick.touchId === touch.identifier) shootingJoystick.reset(); } }
    
    function resizeCanvas() { 
        const containerRect = gameContainer.getBoundingClientRect();
        
        gameCanvas.style.width = `${containerRect.width}px`;
        gameCanvas.style.height = `${containerRect.height}px`;

        gameCanvas.width = containerRect.width;
        gameCanvas.height = containerRect.height;
        
        canvasWidth = containerRect.width;
        canvasHeight = containerRect.height;

        if (fogCanvas) {
            fogCanvas.width = canvasWidth;
            fogCanvas.height = canvasHeight;
        }
        
        if (welcomeBgCanvas && welcomeScreenElement.style.display !== 'none') { 
            const welcomeRect = welcomeScreenElement.getBoundingClientRect(); 
            welcomeBgCanvas.width = welcomeRect.width; 
            welcomeBgCanvas.height = welcomeRect.height; 
        } 
    }
    
    function startWelcomeAnimation() {
        if (welcomeAnimFrameId) return;
        const welcomeRect = welcomeScreenElement.getBoundingClientRect();
        welcomeBgCanvas.width = welcomeRect.width; 
        welcomeBgCanvas.height = welcomeRect.height; 
        bgCircles = [];
        bgCharacters = [];

        const allColors = ['#4682B4', '#6495ED', '#87CEEB', '#DC143C', '#B22222', '#8B0000'];
        for (let i = 0; i < 10; i++) {
            bgCircles.push({ 
                x: Math.random() * welcomeBgCanvas.width, 
                y: Math.random() * welcomeBgCanvas.height, 
                radius: 10 + Math.random() * 10, 
                color: allColors[i % allColors.length], 
                dx: (Math.random() - 0.5) * 2, 
                dy: (Math.random() - 0.5) * 2 
            });
        }
        
        bgCharacters.push({
            x: welcomeBgCanvas.width * 0.25,
            y: welcomeBgCanvas.height * 0.5,
            radius: 50,
            color: '#4682B4', // Blue
            aimAngle: -Math.PI / 4, // 45 degrees up-right
            dx: (Math.random() - 0.5) * 0.5,
            dy: (Math.random() - 0.5) * 0.5
        });

        bgCharacters.push({
            x: welcomeBgCanvas.width * 0.75,
            y: welcomeBgCanvas.height * 0.5,
            radius: 50,
            color: '#DC143C', // Red
            aimAngle: -Math.PI / 4, // 45 degrees up-right
            dx: (Math.random() - 0.5) * 0.5,
            dy: (Math.random() - 0.5) * 0.5
        });

        welcomeAnimationLoop();
    }
    
    function stopWelcomeAnimation() { if (welcomeAnimFrameId) { cancelAnimationFrame(welcomeAnimFrameId); welcomeAnimFrameId = null; } }
    
    function welcomeAnimationLoop() {
        welcomeBgCtx.clearRect(0, 0, welcomeBgCanvas.width, welcomeBgCanvas.height);
        welcomeBgCtx.globalAlpha = 0.5;

        // Draw and update animated circles
        bgCircles.forEach(circle => {
            circle.x += circle.dx; 
            circle.y += circle.dy;
            if (circle.x + circle.radius > welcomeBgCanvas.width || circle.x - circle.radius < 0) circle.dx *= -1;
            if (circle.y + circle.radius > welcomeBgCanvas.height || circle.y - circle.radius < 0) circle.dy *= -1;
            welcomeBgCtx.beginPath(); 
            welcomeBgCtx.arc(circle.x, circle.y, circle.radius, 0, Math.PI * 2);
            welcomeBgCtx.fillStyle = circle.color; 
            welcomeBgCtx.fill();
        });

        // Draw and update animated characters
        bgCharacters.forEach(character => {
             character.x += character.dx;
             character.y += character.dy;
             if (character.x + character.radius > welcomeBgCanvas.width || character.x - character.radius < 0) character.dx *= -1;
             if (character.y + character.radius > welcomeBgCanvas.height || character.y - character.radius < 0) character.dy *= -1;

            // Simple character drawing
            welcomeBgCtx.fillStyle = character.color;
            welcomeBgCtx.beginPath();
            welcomeBgCtx.arc(character.x, character.y, character.radius, 0, Math.PI * 2);
            welcomeBgCtx.fill();

            // Draw barrel
            welcomeBgCtx.save();
            welcomeBgCtx.translate(character.x, character.y);
            welcomeBgCtx.rotate(character.aimAngle);
            welcomeBgCtx.fillStyle = '#222';
            welcomeBgCtx.fillRect(character.radius - 10, -5, 20, 10);
            welcomeBgCtx.restore();
        });


        welcomeBgCtx.globalAlpha = 1;
        welcomeAnimFrameId = requestAnimationFrame(welcomeAnimationLoop);
    }
    
    function intersectsCircle(rect, circle) { const closestX = Math.max(rect.x, Math.min(circle.x, rect.x + rect.w)); const closestY = Math.max(rect.y, Math.min(circle.y, rect.y + rect.h)); return distSq(circle.x, circle.y, closestX, closestY) < (circle.radius * circle.radius); }
    
    
    function getIntersection(ray, segment) {
        const x1 = ray.p1.x, y1 = ray.p1.y, x2 = ray.p2.x, y2 = ray.p2.y;
        const x3 = segment.p1.x, y3 = segment.p1.y, x4 = segment.p2.x, y4 = segment.p2.y;
        const den = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
        if (den === 0) return null;
        const t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / den;
        const u = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / den;
        if (t > 0.00001 && u >= 0 && u <= 1) return { x: x1 + t * (x2 - x1), y: y1 + t * (y2 - y1) };
        return null;
    }

    function calculateVisibility(origin, segments) {
        if (!origin || typeof origin.x !== 'number' || typeof origin.y !== 'number') return [];
        const allPoints = [];
        segments.forEach(seg => allPoints.push(seg.p1, seg.p2));
        const uniquePoints = allPoints.filter((p, i) => allPoints.findIndex(a => a.x === p.x && a.y === p.y) === i);
        let allAngles = [];
        uniquePoints.forEach(point => { const angle = Math.atan2(point.y - origin.y, point.x - origin.x); allAngles.push(angle - 0.00001, angle, angle + 0.00001); });
        for (let i = 0; i < 360; i++) allAngles.push(i * Math.PI / 180);

        const visibilityPolygonPoints = [];
        allAngles.forEach(angle => {
            const ray = { p1: origin, p2: { x: origin.x + Math.cos(angle) * (lightRadius + 10), y: origin.y + Math.sin(angle) * (lightRadius + 10) } };
            let closestIntersection = null, closestDistSq = Infinity;
            for (const segment of segments) {
                const intersection = getIntersection(ray, segment);
                if (intersection) {
                    const distSq = (intersection.x - origin.x)**2 + (intersection.y - origin.y)**2;
                    if (distSq < closestDistSq) { closestDistSq = distSq; closestIntersection = intersection; }
                }
            }
            if (closestIntersection && closestDistSq <= lightRadius * lightRadius) visibilityPolygonPoints.push({x: closestIntersection.x, y: closestIntersection.y, angle: angle});
            else visibilityPolygonPoints.push({ x: origin.x + Math.cos(angle) * lightRadius, y: origin.y + Math.sin(angle) * lightRadius, angle: angle });
        });
        visibilityPolygonPoints.sort((a, b) => a.angle - b.angle);
        return visibilityPolygonPoints;
    }

    function drawMinimap(currentState) {
        const cameraTarget = currentState.characters.find(c => c.id === spectatingId || (c.id === 'player' && !spectatingId)) || null;
        if (!cameraTarget || !offscreenMinimapCanvas) return;

        const mmWidth = minimapCanvas.width, mmHeight = minimapCanvas.height;
        minimapCtx.clearRect(0, 0, mmWidth, mmHeight);
        
        const zoomFactor = 4;
        const sourceViewWidth = mapWidth / zoomFactor, sourceViewHeight = mapHeight / zoomFactor;
        let sx = cameraTarget.x - sourceViewWidth / 2, sy = cameraTarget.y - sourceViewHeight / 2;
        sx = Math.max(0, Math.min(mapWidth - sourceViewWidth, sx));
        sy = Math.max(0, Math.min(mapHeight - sourceViewHeight, sy));
        minimapCtx.drawImage(offscreenMinimapCanvas, sx, sy, sourceViewWidth, sourceViewHeight, 0, 0, mmWidth, mmHeight);

        currentState.characters.forEach(c => {
            if (c.hp <= 0) return;
            const isPlayerOrAlly = c.team === cameraTarget.team;
            const isVisibleEnemy = c.team !== cameraTarget.team && c.showOnMinimapTimer > 0;
            if (isPlayerOrAlly || isVisibleEnemy) {
                if (c.x >= sx && c.x <= sx + sourceViewWidth && c.y >= sy && c.y <= sy + sourceViewHeight) {
                    const drawX = (c.x - sx) * (mmWidth / sourceViewWidth), drawY = (c.y - sy) * (mmHeight / sourceViewHeight);
                    minimapCtx.fillStyle = c.id === 'player' ? 'lime' : (c.team === cameraTarget.team ? 'cyan' : 'red');
                    minimapCtx.beginPath(); minimapCtx.arc(drawX, drawY, 4, 0, 2 * Math.PI); minimapCtx.fill();
                }
            }
        });
    }

    function showFullscreenMap() { if (isPaused || inRoundTransition || isGameOver || !offscreenMinimapCanvas) return; fullscreenMapOverlay.style.display = 'flex'; drawFullscreenMap(); }
    function hideFullscreenMap() { fullscreenMapOverlay.style.display = 'none'; }
    function drawFullscreenMap() {
        if (!offscreenMinimapCanvas) return;
        const fullMapCtx = fullscreenMapCanvas.getContext('2d');
        const mapAspectRatio = mapWidth / mapHeight;
        let newWidth = window.innerWidth * 0.9, newHeight = newWidth / mapAspectRatio;
        if (newHeight > window.innerHeight * 0.9) { newHeight = window.innerHeight * 0.9; newWidth = newHeight * mapAspectRatio; }
        fullscreenMapCanvas.width = newWidth; fullscreenMapCanvas.height = newHeight;
        fullMapCtx.drawImage(offscreenMinimapCanvas, 0, 0, newWidth, newHeight);
        const scaleX = newWidth / mapWidth, scaleY = newHeight / mapHeight;
        allCharacters.forEach(c => {
            if (c.hp <= 0) return;
            fullMapCtx.fillStyle = c.id === 'player' ? 'lime' : (c.team === 1 ? 'cyan' : 'red');
            fullMapCtx.beginPath(); fullMapCtx.arc(c.x * scaleX, c.y * scaleY, 5, 0, 2 * Math.PI); fullMapCtx.fill();
        });
    }

    function updateTeamStatusUI(characters) {
        const player = characters.find(c => c.id === 'player');
        if (!player) return;
        const blueTeam = characters.filter(c => c.team === 1).sort((a,b) => a.id.localeCompare(b.id));
        const redTeam = characters.filter(c => c.team === 2).sort((a,b) => a.id.localeCompare(b.id));
        const playerIsOnAttackingTeam = player.team === roundState.attackingTeam;
        
        blueTeamIconsContainer.innerHTML = ''; redTeamIconsContainer.innerHTML = '';
        
        const createPortraitElement = (character, container, showBomb) => {
            if (!character) return;
            const wrapper = document.createElement('div'); wrapper.className = 'player-portrait-wrapper';
            const canvas = document.createElement('canvas'); const portraitSize = 40;
            canvas.width = portraitSize; canvas.height = portraitSize;
            canvas.style.width = `${portraitSize}px`; canvas.style.height = `${portraitSize}px`;
            const bombText = document.createElement('div');
            bombText.style.cssText = 'color: orange; font-size: 8px; font-weight: bold; height: 10px;';
            if (showBomb && character.hasBomb) bombText.textContent = 'BOMB';
            drawPlayerPortrait(canvas, character);
            wrapper.appendChild(canvas); wrapper.appendChild(bombText);
            container.appendChild(wrapper);
        };
        blueTeam.forEach(char => createPortraitElement(char, blueTeamIconsContainer, player.team === 1 && playerIsOnAttackingTeam));
        redTeam.forEach(char => createPortraitElement(char, redTeamIconsContainer, player.team === 2 && playerIsOnAttackingTeam));
    }
    
    function drawPlayerPortrait(canvas, player) {
        if (!canvas) return;
        const g = canvas.getContext('2d');
        g.clearRect(0, 0, canvas.width, canvas.height);
        
        if (!player) return;
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;
        const radius = canvas.width / 3;

        // Draw shadow
        g.fillStyle = 'rgba(0,0,0,0.2)';
        g.beginPath();
        g.arc(centerX + 3, centerY + 3, radius, 0, Math.PI * 2);
        g.fill();

        // Draw Body
        g.fillStyle = player.color;
        g.beginPath();
        g.arc(centerX, centerY, radius, 0, Math.PI * 2);
        g.fill();
        
        // Draw Barrel (like in-game)
        g.save();
        g.translate(centerX, centerY);
        g.rotate(0); // Always face right
        g.fillStyle='#222';
        g.fillRect(radius, -3, 8, 6);
        g.restore();

        // Overlay for dead players
        if (player.hp <= 0) {
            g.fillStyle = 'rgba(0,0,0,0.7)';
            g.fillRect(0,0,canvas.width,canvas.height);
        }
    }
   
    function updateSpectateList(player) {
        spectatablePlayers = [];
        const attackersAlive = allCharacters.some(c => c.team === roundState.attackingTeam && c.hp > 0);
        if (player.team === roundState.attackingTeam && !attackersAlive && bomb.planted) {
            spectatablePlayers = allCharacters.filter(c => c.team !== roundState.attackingTeam && c.hp > 0);
        } else {
            spectatablePlayers = allCharacters.filter(c => c.team === player.team && c.hp > 0);
        }
        if (spectatablePlayers.length > 0) spectatingId = spectatablePlayers[0].id;
        else spectatingId = null;
    }

    function cycleSpectator(direction) {
        if (!spectatingId || spectatablePlayers.length <= 1) return;
        const currentIndex = spectatablePlayers.findIndex(p => p.id === spectatingId);
        if (currentIndex === -1) return;
        let nextIndex = (currentIndex + direction + spectatablePlayers.length) % spectatablePlayers.length;
        spectatingId = spectatablePlayers[nextIndex].id;
    }
    initialize();
    
    });
</script>
</body>
</html>
