<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Circle Combat</title>
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Circle Combat">

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Russo+One&display=swap" rel="stylesheet">
    <style>
        /* General page styling */
        html, body {
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #1a1a1a;
            font-family: 'Russo One', sans-serif;
        }
        /* Container for the game canvas */
        #game-container { 
            position: relative; 
            width: 100%; 
            height: 100%;
        }
        /* General canvas styling */
        canvas { 
            display: none; 
            background-color: #CDBA96; 
            max-width: 100vw;
            max-height: 100vh;
            cursor: crosshair;
        }
        /* Styling for the main game canvas. Uses absolute positioning and transform for perfect centering. */
        #gameCanvas {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 1;
        }
        /* In-game UI overlay */
        #game-ui { position: absolute; top: 10px; left: 10px; right: 10px; bottom: 10px; display: none; pointer-events: none; z-index: 2; font-family: 'Courier New', Courier, monospace;}
        #minimap-container { position: absolute; top: 10px; left: 0; pointer-events: auto; }
        #minimap { width: 150px; height: 150px; border: 2px solid #D2B48C; background-color: rgba(42, 33, 28, 0.5); display: block; cursor: pointer; }
        
        #bottom-center-hud {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            align-items: center;
            gap: 20px;
        }
        
        #ammo-counter-button {
            background: none;
            border: none;
            padding: 10px; 
            cursor: pointer;
            pointer-events: auto;
            border-radius: 8px;
            font-family: 'Russo One', sans-serif;
        }
        #ammo-counter {
            color: #FFF8DC;
            font-size: 28px;
            font-weight: bold;
            text-shadow: 2px 2px 4px #000;
            pointer-events: none; 
        }

        #bomb-icon-container {
            display: none;
            pointer-events: auto;
        }
        
        #plant-bomb-button, #defuse-bomb-button {
            position: absolute;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            padding: 10px 20px;
            border-radius: 8px;
            font-size: 20px;
            font-weight: bold;
            text-shadow: 1px 1px 2px #000;
            display: none;
            pointer-events: auto;
            border: 2px solid #3a3a3a;
            background-color: #4a4a4a;
            color: #FFF8DC;
            cursor: pointer;
            transition: background 0.1s;
            box-sizing: border-box;
        }
        #plant-bomb-button:hover, #defuse-bomb-button:hover {
            background-color: #5a5a5a;
        }

        .top-ui-container {
            position: absolute;
            top: 10px;
            left: 160px; 
            right: 160px;
            display: flex;
            flex-direction: row;
            align-items: center;
            justify-content: center; /* Center the middle block */
            pointer-events: auto;
            background-color: rgba(80, 70, 60, 0.8);
            border: 2px solid #D2B48C;
            border-radius: 8px;
            height: 65px;
            padding: 0 10px;
            cursor: pointer;
        }
        .team-icon-group {
            display: flex;
            gap: 10px;
            padding: 5px;
            text-align: center;
            align-items: center;
            height: 100%;
            flex: 1; /* Allow groups to take up space */
        }
        .player-portrait-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 100%;
            justify-content: center;
        }
        #blue-team-icons {
            justify-content: flex-end; /* Align to the right of the container */
            margin-right: 15px; /* Space from center */
        }
        #red-team-icons {
             justify-content: flex-start; /* Align to the left of the container */
             margin-left: 15px; /* Space from center */
        }
        #center-info-block {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2px;
            padding: 5px 10px;
            flex-shrink: 0; /* Prevent this block from shrinking */
        }
        #game-timer-bar {
            font-size: 18px; 
            font-weight: bold;
            color: #FFF8DC;
            text-align: center;
            white-space: nowrap;
        }
        #game-event-text {
            position: absolute;
            top: 85px; /* Below the top UI bar */
            left: 50%;
            transform: translateX(-50%);
            color: #FF4747;
            font-size: 16px;
            font-weight: bold;
            text-shadow: 1px 1px 2px #000;
            display: none; /* Hidden by default */
        }
        #team-role-display {
            font-size: 11px;
            color: #FFF8DC;
        }
        #team-score-bar {
            display: flex;
            width: 100%;
            justify-content: space-between;
        }
        .score-display {
            width: 50%;
            padding: 5px;
            font-size: 24px;
            font-weight: bold;
            text-align: center;
        }
        #blue-score-display {
            color: #E0EFFF;
        }
        #red-score-display {
            color: #FFD0D0;
        }
        .top-ui-container canvas {
            display: block;
            border-radius: 5px;
        }

        .menu-screen { 
            position: absolute; 
            top: 50%; 
            left: 50%; 
            transform: translate(-50%, -50%); 
            color: #FFF8DC; 
            text-align: center; 
            padding: 30px; 
            z-index: 10; 
            width: 80%; 
            max-width: 600px;
            overflow: hidden; 
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            box-sizing: border-box;
        }
        #welcome-screen {
            width: 100%;
            height: 100%;
            max-width: none;
            top: 0;
            left: 0;
            transform: none;
            border-radius: 0;
            padding: 0;
            background-color: #2a211c; 
            border: none;
            box-shadow: none;
        }
        #welcome-screen-content {
             width: 90%;
             max-width: 500px;
        }

        #round-scoreboard, #in-game-menu, #settings-menu, #matchup-screen, #multiplayer-menu, #multiplayer-name-menu {
             background-color: rgba(42, 33, 28, 0.95);
             border: 2px solid #D2B48C;
             border-radius: 15px;
             height: auto;
             width: auto;
             padding: 20px 40px;
        }
        #round-scoreboard {
            position: relative; /* Needed for positioning the leave button */
        }
        
        #matchup-screen {
            width: 100%;
            max-width: none;
            height: 100%;
            border-radius: 0;
            background-color: rgba(0,0,0,0.5);
        }

        #in-game-menu {
             max-width: 300px;
             pointer-events: auto;
        }
        .menu-screen h1, .menu-screen .menu-button {
            position: relative;
            z-index: 1; /* Ensure text/buttons are above background animations */
        }
        .menu-screen h1 { 
            font-family: 'Russo One', sans-serif;
            font-size: 56px; 
            margin-top: 0; 
            margin-bottom: 20px;
            color: #FFF8DC;
            text-shadow: 0 0 10px #D2B48C, 0 0 20px #D2B48C, 3px 3px 5px rgba(0,0,0,0.5);
        }
        #welcome-screen h1, #welcome-screen .menu-button, .credits-text {
             opacity: 0;
            animation: fadeInUp 0.8s forwards;
        }
        #welcome-screen h1 { animation-delay: 0.2s; }
        
        @keyframes fadeInUp {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .menu-button { 
            background-color: #4a4a4a;
            border: 2px solid #3a3a3a;
            color: #FFF8DC; 
            padding: 15px 30px; 
            font-size: 20px; 
            cursor: pointer; 
            display: block; 
            width: 100%; 
            margin-bottom: 15px; 
            text-transform: uppercase;
            transition: all 0.2s ease-out;
            border-radius: 8px;
            font-family: 'Russo One', sans-serif;
        }
        #welcome-screen .menu-button:nth-of-type(1) { animation-delay: 0.4s; }
        #welcome-screen .menu-button:nth-of-type(2) { animation-delay: 0.6s; }
        #welcome-screen .menu-button:nth-of-type(3) { animation-delay: 0.8s; }

        .menu-button:hover:not(:disabled) { 
            transform: scale(1.05); 
            box-shadow: 0 0 15px rgba(210, 180, 140, 0.6);
            background-color: #5a5a5a;
        }
        .menu-button:disabled { 
            background-color: #3a3a3a; 
            color: #6c757d; 
            cursor: not-allowed; 
            border-color: #2a2a2a;
        }
        .menu-button:disabled span {
            color: #888;
        }
        
        .credits-text {
            margin-top: 25px;
            font-size: 14px;
            color: #a0a0a0;
            letter-spacing: 1px;
            animation-delay: 1s;
        }

        #dune-bg {
            position: absolute;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            z-index: -1;
            border-radius: 15px;
            overflow: hidden;
        }
        #dune-bg::before, #dune-bg::after {
            content: '';
            position: absolute;
            bottom: 0;
            width: 200%;
            height: 200px;
            background: linear-gradient(to top, rgba(160, 130, 90, 0.4), transparent);
            border-radius: 50%;
        }
        #dune-bg::before {
            left: -50%;
            animation: parallax-dunes 25s linear infinite;
        }
        #dune-bg::after {
            left: 0;
            animation: parallax-dunes 40s linear infinite reverse;
            background: linear-gradient(to top, rgba(193, 154, 107, 0.3), transparent);
        }
        @keyframes parallax-dunes {
            from { transform: translateX(-25%); }
            to { transform: translateX(25%); }
        }
        
        #in-game-menu-button {
            position: absolute;
            top: 10px;
            right: 0;
            pointer-events: auto;
            width: 150px;
            padding: 10px 15px;
            font-size: 16px;
            z-index: 5;
            box-sizing: border-box;
        }
        
        .icon-button {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 44px;
            height: 44px;
            padding: 0;
            margin: 0;
            background-color: rgba(74, 74, 74, 0.5);
            border: 2px solid #3a3a3a;
            border-radius: 8px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            transition: all 0.2s ease-out;
            z-index: 10;
        }
        .icon-button:hover {
            background-color: #5a5a5a;
            transform: scale(1.1);
        }
        .icon-button svg {
            width: 24px;
            height: 24px;
            stroke: #FFF8DC;
        }
        
        #fullscreen-map-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 20; 
            display: none; 
            justify-content: center;
            align-items: center;
            cursor: pointer;
        }
        #fullscreen-map-canvas {
            background-color: #CDBA96;
            border: 2px solid #D2B48C;
        }

        #round-winner-text {
             font-size: 32px; 
             font-family: 'Russo One', sans-serif;
             animation: none;
             opacity: 1;
        }
        .match-score { display: flex; justify-content: center; align-items: center; margin: 20px 0; gap: 5px; }
        .vs-text { font-size: 20px; font-weight: bold; margin: 0 10px; color: #FFF8DC; }
        .score-box {
            width: 20px;
            height: 20px;
            border: 2px solid #D2B48C;
            background-color: rgba(0,0,0,0.3);
            border-radius: 4px;
        }
        .score-box.blue-win {
            background-color: #a0c4ff;
        }
        .score-box.red-win {
            background-color: #ffadad;
        }
        #scoreboard-teams-container { 
            display: flex; 
            justify-content: space-around; 
            gap: 20px;
            width: 100%;
            flex-wrap: nowrap;
        }
        .scoreboard-team { 
            flex: 1; 
            max-width: 48%;
        }
        .scoreboard-team h2 { margin-top: 0; font-size: 24px; }
        .scoreboard-team.blue { color: #a0c4ff; }
        .scoreboard-team.red { color: #ffadad; }
        .scoreboard-header, .scoreboard-player-row { 
            display: grid; 
            grid-template-columns: 2.5fr 1fr 1fr 1fr 1fr 1.5fr; 
            gap: 5px; 
            padding: 5px; 
            text-align: left; 
            align-items: center;
            font-family: 'Courier New', Courier, monospace;
        }
        .scoreboard-header { 
            font-weight: bold; 
            border-bottom: 1px solid #D2B48C; 
            font-size: 10px; 
        }
        
        .scoreboard-player-row { 
            background-color: rgba(255,255,255,0.05); 
            border-radius: 4px; 
            margin-bottom: 5px; 
            font-size: 14px;
        }

        .player-name-cell {
            display: flex;
            align-items: center;
        }
        
        .mvp-sticker {
            display: inline-block;
            background-color: #FFD700; /* Gold color */
            color: #333;
            padding: 2px 6px;
            font-size: 10px;
            font-weight: bold;
            border-radius: 4px;
            transform: rotate(-15deg);
            margin-left: 10px;
            text-shadow: none;
            line-height: 1;
        }
        #scoreboard-leave-match-button {
            position: absolute;
            bottom: 15px;
            right: 15px;
            width: auto;
            margin: 0;
            padding: 10px 20px;
        }

        #player-info-container {
            position: absolute;
            bottom: 20px;
            left: 20px;
            display: flex;
            flex-direction: column;
            gap: 5px;
            pointer-events: none;
        }
        #player-name-display {
            color: #FFF8DC;
            font-size: 16px;
            font-weight: bold;
            text-shadow: 1px 1px 2px #000;
        }
        #player-health-bar-container {
            width: 150px;
            height: 15px;
            border: 1px solid #D2B48C;
            border-radius: 3px;
        }
        #player-health-bar {
            width: 100%;
            height: 100%;
            background-color: #4CAF50; /* Green */
            border-radius: 2px;
            transition: width 0.2s linear;
        }
        #matchup-screen {
            width: 100%;
            max-width: none;
            height: 100%;
            top: 0;
            left: 0;
            transform: none;
            border-radius: 0;
            background-color: rgba(0,0,0,0.5);
        }
        #matchup-bg-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            display: block;
        }
        #matchup-content {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 80%;
            max-width: 1000px;
            color: #FFF8DC;
        }
        .matchup-team {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        #matchup-blue-team {
            align-items: flex-end;
            padding-right: 20px;
        }
        #matchup-red-team {
            align-items: flex-start;
            padding-left: 20px;
        }
        .matchup-player-card {
            display: flex;
            align-items: center;
            gap: 15px;
            background-color: rgba(0,0,0,0.6);
            padding: 10px;
            border-radius: 8px;
            border: 1px solid #D2B48C;
            width: 250px; /* Give cards a fixed width */
        }
        #matchup-red-team .matchup-player-card {
            flex-direction: row-reverse;
        }
        .matchup-player-card canvas {
            width: 60px;
            height: 60px;
            display: block;
            border-radius: 5px;
        }
        .matchup-player-card .player-name {
            font-size: 22px;
            font-weight: bold;
            flex-grow: 1;
            text-align: center;
        }
        .vs-text-large {
            font-family: 'Russo One', sans-serif;
            font-size: 80px;
            margin: 0 40px;
            text-shadow: 0 0 15px #D2B48C;
        }
        #round-countdown {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-family: 'Russo One', sans-serif;
            font-size: 100px;
            color: #FFF8DC;
            text-shadow: 0 0 20px #000;
            z-index: 100;
            display: none;
            pointer-events: none;
        }
        #spectate-controls {
            position: absolute;
            bottom: 20px;
            right: 20px;
            display: none;
            gap: 10px;
            pointer-events: auto;
        }
        .spectate-arrow {
            font-size: 30px;
            color: white;
            cursor: pointer;
            text-shadow: 1px 1px 3px black;
            user-select: none;
        }
        .spectate-arrow:hover {
            color: #D2B48C;
        }
        .setting-row, .mp-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            padding: 10px 0;
            font-size: 18px;
            text-transform: uppercase;
        }
        .mp-input {
            background-color: #3a3a3a;
            border: 1px solid #2a2a2a;
            color: #FFF8DC;
            padding: 10px;
            border-radius: 4px;
            font-size: 16px;
            text-align: center;
            width: 150px;
        }

        .custom-checkbox {
            position: relative;
            cursor: pointer;
            width: 28px;
            height: 28px;
            background-color: #4a4a4a;
            border: 2px solid #3a3a3a;
            border-radius: 4px;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .custom-checkbox .checkmark {
            display: none;
            width: 8px;
            height: 14px;
            border: solid #4CAF50;
            border-width: 0 4px 4px 0;
            transform: rotate(45deg);
        }

        #joystick-toggle:checked ~ .custom-checkbox .checkmark {
            display: block;
        }
        #scoreboard-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.7);
            z-index: 15;
            display: none;
            justify-content: center;
            align-items: center;
            pointer-events: auto; /* Allow clicking on the overlay to close it */
        }
        #scoreboard-overlay > .menu-screen {
             position: relative; /* Override absolute positioning */
             top: auto;
             left: auto;
             transform: none;
             pointer-events: auto;
             max-width: 800px;
        }
        #kill-feed {
            position: absolute;
            top: 80px; /* Adjust as needed */
            right: 20px;
            width: 300px;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 5px;
            pointer-events: none;
        }
        .kill-feed-item {
            background-color: rgba(0, 0, 0, 0.5);
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 14px;
            animation: fadeOut 5s forwards;
            white-space: nowrap;
        }
        .kill-feed-item .blue-team { color: #a0c4ff; }
        .kill-feed-item .red-team { color: #ffadad; }
        .kill-feed-item .weapon { color: #FFF8DC; }
        @keyframes fadeOut {
            0% { opacity: 1; }
            80% { opacity: 1; }
            100% { opacity: 0; }
        }

        /* Kill Cam UI styles */
        #kill-cam-overlay {
            position: absolute;
            top: 20px;
            left: 20px;
            transform: none;
            z-index: 101; 
            color: #FFF8DC;
            text-align: left;
            display: none;
            flex-direction: row;
            align-items: center;
            gap: 15px;
            pointer-events: none;
            background-color: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 8px;
        }
        #kill-cam-overlay .kill-cam-info {
            display: flex;
            flex-direction: column;
        }
        #kill-cam-overlay .kill-cam-info span {
            font-size: 12px;
            font-weight: bold;
            color: #FF4747; /* Red "spectating" text */
            text-transform: uppercase;
        }
        /* Styling for the kill cam portrait canvas */
        #kill-cam-portrait {
            width: 50px;
            height: 50px;
            border-radius: 8px;
            display: block;
        }
        #kill-cam-killer-name {
            font-size: 18px;
            font-weight: bold;
            text-shadow: 1px 1px 2px #000;
        }

        /* Custom Modal for alerts */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: none; /* Hidden by default */
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .modal-content {
            background-color: rgba(42, 33, 28, 0.95);
            border: 2px solid #D2B48C;
            border-radius: 15px;
            padding: 30px;
            color: #FFF8DC;
            text-align: center;
            max-width: 400px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
        }

        .modal-content h2 {
            margin-top: 0;
            font-size: 24px;
            color: #FFF8DC;
        }

        .modal-content p {
            margin-bottom: 20px;
            font-size: 18px;
        }

        .modal-content button {
            background-color: #4a4a4a;
            border: 2px solid #3a3a3a;
            color: #FFF8DC;
            padding: 10px 20px;
            font-size: 18px;
            cursor: pointer;
            border-radius: 8px;
            transition: all 0.2s ease-out;
        }

        .modal-content button:hover {
            transform: scale(1.05);
            box-shadow: 0 0 10px rgba(210, 180, 140, 0.6);
            background-color: #5a5a5a;
        }
        
        /* Mobile adjustments */
        @media (max-width: 768px), (max-height: 500px) {
            .menu-screen {
                width: 90%;
                padding: 15px;
            }
            #welcome-screen {
                width: 100%;
                height: 100%;
                border-radius: 0;
            }
             .menu-screen h1 {
                font-size: 36px; /* Smaller title on mobile */
            }
            .menu-button {
                padding: 10px 18px;
                font-size: 16px;
            }

            #minimap {
                width: 80px;
                height: 80px;
            }
             #in-game-menu-button {
                width: 80px;
                padding: 10px 5px;
            }
            #ammo-counter {
                font-size: 20px;
            }
            .top-ui-container {
                left: 90px;
                right: 90px;
                height: 50px;
                padding: 2px 5px;
                gap: 5px;
            }
             .score-display {
                font-size: 18px;
            }
            #game-timer-bar {
                font-size: 14px;
            }
            .team-icon-group {
                gap: 2px;
            }
             #blue-team-icons {
                margin-right: 5px;
            }
            #red-team-icons {
                margin-left: 5px;
            }
            .player-portrait-wrapper canvas {
                width: 30px;
                height: 30px;
            }
             .scoreboard-team h2 {
                font-size: 16px; /* Shrink team title */
            }

            #scoreboard-teams-container {
                gap: 5px; /* Reduce gap between teams */
            }

            .scoreboard-header, .scoreboard-player-row {
                grid-template-columns: 2fr 0.8fr 0.8fr 0.8fr 0.8fr 1.2fr; /* Give more space to name */
                font-size: 9px; /* Shrink font */
                padding: 2px;
                gap: 2px;
                align-items: center;
            }
            .scoreboard-header {
                grid-template-columns: 2fr repeat(5, 1fr);
            }
            .mvp-sticker {
                font-size: 8px;
                padding: 1px 3px;
                margin-left: 4px;
            }
            #plant-bomb-button {
                padding: 8px 15px;
                font-size: 14px;
                bottom: 60px;
            }
            .matchup-player-card {
                width: 180px;
                padding: 5px;
                gap: 8px;
            }
            .matchup-player-card canvas {
                width: 40px;
                height: 40px;
            }
            .matchup-player-card .player-name {
                font-size: 16px;
            }
            .vs-text-large {
                font-size: 40px;
                margin: 0 20px;
            }
        }

    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>

    <div id="game-ui">
        <div class="top-ui-container" id="tdm-ui">
            <div class="team-icon-group" id="blue-team-icons">
            </div>
            <div id="center-info-block">
                 <div id="game-timer-bar">2:00</div>
                 <div id="team-role-display"></div>
                 <div id="team-score-bar">
                    <div id="blue-score-display">0</div>
                    <div id="red-score-display">0</div>
                 </div>
            </div>
            <div class="team-icon-group" id="red-team-icons">
            </div>
        </div>
        <div id="game-event-text"></div>
        <div id="kill-feed"></div>
        <button class="menu-button" id="in-game-menu-button">Menu</button>
        <div id="minimap-container">
            <canvas id="minimap"></canvas>
        </div>
        
        <div id="bottom-center-hud">
            <div id="bomb-icon-container">
                <svg width="50" height="50" viewBox="0 0 100 100">
                    <rect x="20" y="35" width="60" height="30" fill="#333" stroke="black" stroke-width="2"/>
                    <rect x="45" y="25" width="10" height="10" fill="#555"/>
                    <line x1="50" y1="25" x2="50" y2="15" stroke="red" stroke-width="4"/>
                </svg>
            </div>
            <button id="ammo-counter-button">
                <span id="ammo-counter">30 / ∞</span>
            </button>
        </div>
        
        <button id="plant-bomb-button" style="display:none;">Hold to Plant</button>
        <button id="defuse-bomb-button" style="display:none;">Hold to Defuse</button>
        
        <div id="player-info-container">
            <div id="player-name-display"></div>
            <div id="player-health-bar-container">
                <div id="player-health-bar"></div>
            </div>
        </div>

        <div id="spectate-controls">
            <div class="spectate-arrow" id="spectate-prev">&larr;</div>
            <div class="spectate-arrow" id="spectate-next">&rarr;</div>
        </div>
    </div>
    
    <div id="welcome-screen" class="menu-screen">
        <canvas id="welcome-bg-canvas"></canvas>
        <div id="dune-bg"></div>
        <div id="welcome-screen-content">
            <h1>Circle Combat</h1>
            <div id="main-menu-view">
                <button class="menu-button" id="show-sp-menu-button">Single Player</button>
                <button class="menu-button" id="show-mp-menu-button">Multiplayer</button>
                <button class="menu-button" id="main-menu-settings-button">Settings</button>
                <p class="credits-text">Created By Ryder Haddock</p>
            </div>
            <div id="single-player-menu-view" style="display: none; width: 100%;">
                 <button class="menu-button" id="3v3-button">3v3</button>
                 <button class="menu-button" id="2v2-button">2v2</button>
                 <button class="menu-button" id="1v1-button">1v1</button>
                 <button class="menu-button" id="sp-back-button">Back</button>
            </div>
        </div>
    </div>

    <div id="multiplayer-name-menu" class="menu-screen">
        <h1>Enter Your Name</h1>
        <div class="mp-row">
             <input type="text" id="player-name-input" class="mp-input" placeholder="Your Name" maxlength="12">
        </div>
        <button class="menu-button" id="confirm-name-button">Confirm</button>
        <button class="menu-button" id="mp-name-back-button">Back</button>
    </div>
    
    <div id="multiplayer-menu" class="menu-screen">
        <h1>Select a Mode</h1>
        <button class="menu-button" id="mp-1v1-button" disabled>1 vs 1</button>
        <button class="menu-button" id="mp-2v2-button" disabled>2 vs 2</button>
        <button class="menu-button" id="mp-3v3-button" disabled>3 vs 3</button>
        <div id="queue-status-text" style="margin-top: 15px; font-size: 18px;">Connecting...</div>
        <button class="menu-button" id="mp-back-button">Back</button>
    </div>

    <div id="matchup-screen" class="menu-screen">
        <canvas id="matchup-bg-canvas"></canvas>
        <div id="matchup-content">
            <div id="matchup-blue-team" class="matchup-team">
                </div>
            <div class="vs-text-large">VS</div>
            <div id="matchup-red-team" class="matchup-team">
                </div>
        </div>
    </div>

    <div id="in-game-menu" class="menu-screen">
        <button class="menu-button" id="resume-button">Resume</button>
        <button class="menu-button" id="leave-match-button">Leave Match</button>
    </div>

    <div id="settings-menu" class="menu-screen">
        <h1>Settings</h1>
        <div class="setting-row">
            <label for="joystick-toggle">Enable Joysticks</label>
            <input type="checkbox" id="joystick-toggle" checked style="display: none;">
            <label for="joystick-toggle" class="custom-checkbox">
                <div class="checkmark"></div>
            </label>
        </div>
        <button class="menu-button" id="back-button">Back</button>
    </div>

    <div id="scoreboard-overlay">
        <div id="round-scoreboard" class="menu-screen">
            <h1 id="round-winner-text"></h1>
            <div class="match-score" id="round-end-match-score">
                </div>
            <div id="scoreboard-teams-container">
                <div class="scoreboard-team blue">
                    <h2>Blue Team</h2>
                    <div class="scoreboard-header">
                        <div>Player</div>
                        <div class="col-stat">Kills</div>
                        <div class="col-stat">Assists</div>
                        <div class="col-stat">Plants</div>
                        <div class="col-stat">Defuses</div>
                        <div class="col-stat">Score</div>
                    </div>
                    <div id="scoreboard-blue-team"></div>
                </div>
                <div class="scoreboard-team red">
                    <h2>Red Team</h2>
                     <div class="scoreboard-header">
                        <div>Player</div>
                        <div class="col-stat">Kills</div>
                        <div class="col-stat">Assists</div>
                        <div class="col-stat">Plants</div>
                        <div class="col-stat">Defuses</div>
                        <div class="col-stat">Score</div>
                    </div>
                    <div id="scoreboard-red-team"></div>
                </div>
            </div>
            <button class="menu-button" id="scoreboard-leave-match-button" style="display: none;">Leave Match</button>
        </div>
    </div>

    <div id="fullscreen-map-overlay"><canvas id="fullscreen-map-canvas"></canvas></div>
    <div id="round-countdown"></div>
    <div id="kill-cam-overlay">
        <canvas id="kill-cam-portrait"></canvas>
        <div class="kill-cam-info">
            <span>Spectating</span>
            <div id="kill-cam-killer-name"></div>
        </div>
    </div>
    <div id="message-modal" class="modal-overlay">
        <div class="modal-content">
            <h2 id="modal-title"></h2>
            <p id="modal-message"></p>
            <button id="modal-close-button">OK</button>
        </div>
    </div>
</div>

<script type="module">
    import { io } from 'https://cdn.socket.io/4.7.5/socket.io.esm.min.js';
    
    document.addEventListener('DOMContentLoaded', () => {
    'use strict';
    
    // --- Multiplayer State ---
    let socket;
    let localPlayerId = null;
    let localPlayerName = "Player";
    let currentMatchId = null; // Null means single player, has ID for multiplayer
    let isHost = false; // True if this client is the host of the multiplayer game
    let gameStateSnapshot = null; // Stores the latest game state received from the server (for non-hosts)

    // Get DOM elements
    const gameContainer = document.getElementById('game-container');
    const gameCanvas = document.getElementById('gameCanvas');
    const ctx = gameCanvas.getContext('2d');
    const minimapCanvas = document.getElementById('minimap');
    const minimapCtx = minimapCanvas.getContext('2d');
    const welcomeScreenElement = document.getElementById('welcome-screen');
    const welcomeBgCanvas = document.getElementById('welcome-bg-canvas');
    let welcomeBgCtx = welcomeBgCanvas.getContext('2d');
    const settingsMenuElement = document.getElementById('settings-menu');
    const inGameMenuElement = document.getElementById('in-game-menu');
    const multiplayerNameMenuElement = document.getElementById('multiplayer-name-menu');
    const multiplayerMenuElement = document.getElementById('multiplayer-menu');
    const queueStatusText = document.getElementById('queue-status-text');
    const playerNameInput = document.getElementById('player-name-input');
    const scoreboardOverlay = document.getElementById('scoreboard-overlay');
    const roundScoreboardElement = document.getElementById('round-scoreboard');
    const matchupScreenElement = document.getElementById('matchup-screen');
    const matchupBgCanvas = document.getElementById('matchup-bg-canvas');
    const matchupBlueTeamContainer = document.getElementById('matchup-blue-team');
    const matchupRedTeamContainer = document.getElementById('matchup-red-team');
    const gameUiElement = document.getElementById('game-ui');
    const roundWinnerTextElement = document.getElementById('round-winner-text');
    const scoreboardBlueTeam = document.getElementById('scoreboard-blue-team');
    const scoreboardRedTeam = document.getElementById('scoreboard-red-team');
    const plantBombButton = document.getElementById('plant-bomb-button');
    const defuseBombButton = document.getElementById('defuse-bomb-button');
    const bombIconContainer = document.getElementById('bomb-icon-container');
    const tdmUiContainer = document.getElementById('tdm-ui');
    const gameTimerBar = document.getElementById('game-timer-bar');
    const gameEventText = document.getElementById('game-event-text');
    const killFeed = document.getElementById('kill-feed');
    const teamRoleDisplay = document.getElementById('team-role-display');
    const blueScoreDisplay = document.getElementById('blue-score-display');
    const redScoreDisplay = document.getElementById('red-score-display');
    const blueTeamIconsContainer = document.getElementById('blue-team-icons');
    const redTeamIconsContainer = document.getElementById('red-team-icons');
    const fullscreenMapOverlay = document.getElementById('fullscreen-map-overlay');
    const fullscreenMapCanvas = document.getElementById('fullscreen-map-canvas');
    const playerInfoContainer = document.getElementById('player-info-container');
    const playerNameDisplay = document.getElementById('player-name-display');
    const playerHealthBar = document.getElementById('player-health-bar');
    const mainMenuView = document.getElementById('main-menu-view');
    const singlePlayerMenuView = document.getElementById('single-player-menu-view');
    const roundCountdownElement = document.getElementById('round-countdown');
    const spectateControls = document.getElementById('spectate-controls');
    const killCamOverlay = document.getElementById('kill-cam-overlay');
    const killCamPortraitCanvas = document.getElementById('kill-cam-portrait');
    const killCamKillerName = document.getElementById('kill-cam-killer-name');
    const scoreboardLeaveMatchButton = document.getElementById('scoreboard-leave-match-button');
    const ammoCounterButton = document.getElementById('ammo-counter-button');
    const ammoCounterElement = document.getElementById('ammo-counter');

    // Custom Modal Elements
    const messageModal = document.getElementById('message-modal');
    const modalTitle = document.getElementById('modal-title');
    const modalMessage = document.getElementById('modal-message');
    const modalCloseButton = document.getElementById('modal-close-button');

    // Menu Buttons
    const showSpMenuButton = document.getElementById('show-sp-menu-button');
    const showMpMenuButton = document.getElementById('show-mp-menu-button');
    const spBackButton = document.getElementById('sp-back-button');
    const mpBackButton = document.getElementById('mp-back-button');
    const mpNameBackButton = document.getElementById('mp-name-back-button');
    const mainMenuSettingsButton = document.getElementById('main-menu-settings-button');
    const backButton = document.getElementById('back-button');
    const joystickToggle = document.getElementById('joystick-toggle');
    const threeVThreeButton = document.getElementById('3v3-button');
    const twoVTwoButton = document.getElementById('2v2-button');
    const oneVOneButton = document.getElementById('1v1-button');
    const mpThreeVThreeButton = document.getElementById('mp-3v3-button');
    const mpTwoVTwoButton = document.getElementById('mp-2v2-button');
    const mpOneVOneButton = document.getElementById('mp-1v1-button');
    const confirmNameButton = document.getElementById('confirm-name-button');
    const inGameMenuButton = document.getElementById('in-game-menu-button');
    const resumeButton = document.getElementById('resume-button');
    const leaveMatchButton = document.getElementById('leave-match-button');
    const spectatePrevButton = document.getElementById('spectate-prev');
    const spectateNextButton = document.getElementById('spectate-next');

    
    // Game constants and variables
    let canvasWidth = 800;
    let canvasHeight = 600;
    const playerRadius = 17;
    const moveSpeed = 220; 
    const initialHitPoints = 100;
    const bulletRadius = 6;
    const bulletSpeed = 10.0; 
    const defaultBulletColor = '#FFD700';
    const bulletDamage = 20;
    const lightRadius = 275; 
    let cameraZoom = 1.0; 
    const BOMB_PLANT_TIME = 5;
    const BOMB_DEFUSE_TIME = 5;
    const BOMB_TIMER_DURATION = 45;
    const ASSIST_TIMER_DURATION = 5000;
    const BURST_COUNT = 3;
    const BURST_FIRE_RATE = 5; 
    const BURST_COOLDOWN_TIME = 25;
    const wallColor = '#654321'; 
    const floorColor = '#6c757d'; 
    const wallThickness = 8; 

    // AI Stats
    const aiMoveSpeed = 220; // Same as player
    const aiFireRateModifier = 1.0; // Same as player
    const aiBulletSpeed = 10.0; // Same as player

    // Game state arrays
    let allCharacters = [];
    let bullets = [];
    let sandSpecks = [];
    let dunes = [];
    let floatingTexts = [];
    let particles = [];
    let powerUps = [];
    let obstacles = [];
    let floorTiles = [];
    let tdmSpawnPoints = [];
    let bombSites = [];
    let losSegments = []; 

    // Kill Cam & History Recording
    let historyBuffer = [];
    const KILL_CAM_HISTORY_SECONDS = 5;
    const KILL_CAM_AFTERMATH_SECONDS = 4;
    const MAX_HISTORY_FRAMES = 60 * (KILL_CAM_HISTORY_SECONDS + KILL_CAM_AFTERMATH_SECONDS);
    let lastKillInfo = null;
    let isKillCamActive = false;
    let killCamReplayStartTime = 0;
    let killCamReplayClock = 0;
    let killCamReplayBuffer = [];
    let killCamFinalObstacles = [];
    let finalKillerId = null;
    let postKillCamReason = ''; 
    let postKillCamWinningTeam = 0;
    let postKillCamPlayerStats = null;

    // Game effects
    let screenShake = { intensity: 0, duration: 0 };

    // Game state flags and timers
    let isGameOver = false;
    let inRoundTransition = false;
    let isRoundActive = false;
    let isPaused = false;
    let animationFrameId = null;
    let mapCenter;
    let gameState = {};
    let lastTimestamp = 0;
    let gameMode = '3v3'; 
    let spectatingId = null;
    let spectatablePlayers = [];
    let roundState = { blueScore: 0, redScore: 0, roundNumber: 0, attackingTeam: 1 };
    let gameSettings = { useJoysticks: true };
    let mousePos = { x: 0, y: 0 };
    let bomb = {};
    let bombItem = { x: 0, y: 0, radius: 10, isCarried: false };
    let bombPlantedTextTimer = 0;
    let roundStartTextTimer = 0;
    let bombDefusedTextTimer = 0;
    let isPlantingButtonHeld = false;
    let isDefusingButtonHeld = false;
    let previousView = 'welcome-screen';
    let isDetonationSequenceActive = false;
    let detonationCameraTarget = null;
    // Local state for aiming to ensure responsive input for clients
    let isLocalPlayerAiming = false;
    let localPlayerAimAngle = 0;

    // Minimap and rendering state
    let isMinimapExpanded = false;
    let offscreenMinimapCanvas = null;
    let offscreenMinimapCtx = null;
    let fogCanvas = null;
    let fogCtx = null;
    
    // Welcome screen animation
    let welcomeAnimFrameId = null;
    let bgCircles = [];
    let bgCharacters = [];

    // Input state
    const keysDown = { w: false, a: false, s: false, d: false, " ": false, r: false, e: false };


    // Joystick state
    let movementJoystick = null;
    let shootingJoystick = null;

    let mapWidth, mapHeight;
    let pathfindingGrid = [];
    const GRID_SCALE = 30; // 1 node per 30 pixels

    // --- Multiplayer Connection ---
    function connectToServer() {
        // This code automatically detects if you are running the game locally or on your live server.
        const isLocal = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
        
        // IMPORTANT: Replace with your actual Render.com URL
        const productionUrl = 'https://game1-0-dy1f.onrender.com'; 
        
        const serverUrl = isLocal ? 'http://localhost:3000' : productionUrl;

        console.log(`Connecting to server at ${serverUrl}`);
        socket = io(serverUrl); 
        setupSocketListeners();
    }

    function setupSocketListeners() {
        socket.on('connect', () => {
            localPlayerId = socket.id;
            console.log("✅ Connected to server with ID:", localPlayerId);
            queueStatusText.textContent = "Connected. Select a mode.";
            mpOneVOneButton.disabled = false;
            mpTwoVTwoButton.disabled = false;
            mpThreeVThreeButton.disabled = false;
        });

        socket.on('disconnect', () => {
            displayMessageModal("Disconnected from server.", "Connection Lost");
            leaveMatch(); // Force leave match on disconnect
        });

        socket.on('queueJoined', (message) => {
            queueStatusText.textContent = message;
        });

        socket.on('matchFound', (data) => {
            console.log(`[Client] Match found! Room: ${data.roomId}, Host: ${data.hostId}`);
            isHost = data.hostId === localPlayerId;
            startGame(data.gameMode, data.players, data.roomId);
        });
        
        socket.on('newHost', (newHostId) => {
            isHost = newHostId === localPlayerId;
            console.log(`[Client] Host changed. New host: ${newHostId}. Am I the host? ${isHost}`);
            if(isHost) displayMessageModal("The host disconnected. You are the new host!", "Host Migration");
        });

        socket.on('playerListUpdate', (players) => {
            console.log("[Client] A player disconnected. Remaining players:", players);
            allCharacters = allCharacters.filter(c => players.some(p => c.id === p.id));
        });

        // Non-host receives authoritative state from the host
        socket.on('gameStateSync', (data) => {
            if (isHost) return;
            gameStateSnapshot = data;
            historyBuffer.push(JSON.parse(JSON.stringify(data))); // Deep copy for history
            if (historyBuffer.length > MAX_HISTORY_FRAMES) {
                historyBuffer.shift();
            }
        });
        
        // Host receives input from other players
        socket.on('playerStateUpdate', (data) => {
            if (!isHost) return;
            const character = allCharacters.find(c => c.id === data.id);
            if (character) {
                // Store the received input state to be processed in the host's game loop
                character.networkInput = data;
            }
        });
        
        // Host receives fire requests from clients
        socket.on('fireRequest', (data) => {
            if (!isHost) return;
            const character = allCharacters.find(c => c.id === data.id);
            if (character && !character.isBursting && character.burstCooldown <= 0 && !character.isReloading && character.ammo > 0) {
                character.burstAimAngle = data.aimAngle;
                character.isBursting = true;
                character.burstsLeft = Math.min(BURST_COUNT, character.ammo);
                character.fireCooldown = 0;
            }
        });

        socket.on('reloadRequestFromClient', (data) => {
            if (!isHost) return;
            const character = allCharacters.find(c => c.id === data.clientId);
            if (character && !character.isReloading && character.ammo < character.clipSize) {
                character.isReloading = true;
                character.reloadTimer = character.reloadTime;
            }
        });

        socket.on('startKillCam', (data) => {
            // Client now directly uses the replay buffer and final obstacle state from the host
            startKillCam(data.winningTeam, data.reason, data.lastKillInfo, data.replayBuffer, data.finalObstacles, data.playerStats);
        });

        socket.on('bombPlanted', (data) => {
            if (isHost) return;
            handleBombPlanted(data);
        });
        
        socket.on('bombDefused', (data) => {
            if (isHost) return;
            handleBombDefused(data.defusedBy);
        });

        socket.on('bombExploded', (data) => {
            if (isHost) return;
            handleBombExplosion(data.explodedAt);
        });
        
        socket.on('killFeedEvent', (data) => {
            const killer = { name: data.killerName, team: data.killerTeam };
            const victim = { name: data.victimName, team: data.victimTeam };
            addKillFeedEntry(killer, victim);
        });
        
        socket.on('roundOver', (data) => {
            // All clients receive this event now
            proceedToScoreboard(data.winnerTeam, data.reason, data.playerStats);
        });
        
        socket.on('gameOver', (data) => {
            if(isHost) return; // Host handles its own game over
            roundState = data.finalRoundState;
            endGame();
        });
    }


    // Joystick class for mobile controls
    class Joystick {
        constructor(x, y, radius, handleRadius) {
            this.baseX = x; this.baseY = y;
            this.handleX = x; this.handleY = y;
            this.radius = radius;
            this.handleRadius = handleRadius;
            this.isActive = false;
            this.touchId = null;
            this.vector = { x: 0, y: 0 };
        }
        draw(g) {
            g.beginPath();
            g.arc(this.baseX, this.baseY, this.radius, 0, Math.PI * 2);
            g.fillStyle = 'rgba(128, 128, 128, 0.4)';
            g.fill();
            g.beginPath();
            g.arc(this.handleX, this.handleY, this.handleRadius, 0, Math.PI * 2);
            g.fillStyle = 'rgba(100, 100, 100, 0.6)';
            g.fill();
        }
        update(x, y) {
            const dx = x - this.baseX;
            const dy = y - this.baseY;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance < this.radius) {
                this.handleX = x;
                this.handleY = y;
            } else {
                this.handleX = this.baseX + (dx / distance) * this.radius;
                this.handleY = this.baseY + (dy / distance) * this.radius;
            }
            const totalDist = this.radius;
            this.vector.x = (this.handleX - this.baseX) / totalDist;
            this.vector.y = (this.handleY - this.baseY) / totalDist;
        }
        reset() {
            this.isActive = false;
            this.touchId = null;
            this.vector = { x: 0, y: 0 };
            this.handleX = this.baseX;
            this.handleY = this.baseY;
        }
    }
    
    function generateMapLayout() {
        obstacles = []; floorTiles = []; tdmSpawnPoints = []; powerUps = []; bombSites = []; losSegments = [];

        const color_grid = [
            "WWWWWWWWWBBBBBBBBBBBBWWWWWWWWW", "WWWWWWWWBBGGGGGGGGGGBBWWWWWWWW", "WWWWWWWWWGGGGBBBBGGGGWWWWWWWWW",
            "WWWWWWBWWGGGGGGGGGGGGWWBWWWWWW", "WWWWWWWWWBGCBBGGBBCGBWWWWWWWWW", "WWWWWWWWWBBBGGGGGGBBBWWWWWWWWW",
            "BBBBWWBWWWWBGGGGGGBWWWWBWWBBBB", "BRRWWWBWWWWWGGGGGGWWWWWBWWWRRB", "BRRWWWBWWWWWGGGGGGWWWWWBWWWRRB",
            "BBBBWWBWWWWBGGGGGGBWWWWBWWBBBB", "WWWWWWWWWBBBGGGGGGBBBWWWWWWWWW", "WWWWWWWWWBGCBBGGBBCGBWWWWWWWWW",
            "WWWWWWBWWGGGGGGGGGGGGWWBWWWWWW", "WWWWWWWWWGGGGBBBBGGGGWWWWWWWWW", "WWWWWWWWBBGGGGGGGGGGBBWWWWWWWW",
            "WWWWWWWWWBBBBBBBBBBBBWWWWWWWWW",
        ];
        
        const tileSize = 120;
        const crateSize = 25;
        mapHeight = color_grid.length * tileSize;
        mapWidth = color_grid[0].length * tileSize;
        mapCenter = { x: mapWidth / 2, y: mapHeight / 2 };

        bombSites.push({ id: 'A', x: mapCenter.x, y: mapCenter.y, radius: 60 });
        bombSites.push({ id: 'B', x: 22 * tileSize, y: 12 * tileSize, radius: 60 });

        const wallCoordSet = new Set();
        color_grid.forEach((row, y) => { for (let x = 0; x < row.length; x++) { if (row[x] === 'B') wallCoordSet.add(`${x},${y}`); } });

        const gridCenterY = Math.floor(color_grid.length / 2);
        const gridCenterX = Math.floor(color_grid[0].length / 2);

        const addObstacleWithLOS = (obs) => {
            obstacles.push(obs);
            const p1 = { x: obs.x, y: obs.y };
            const p2 = { x: obs.x + obs.w, y: obs.y };
            const p3 = { x: obs.x + obs.w, y: obs.y + obs.h };
            const p4 = { x: obs.x, y: obs.y + obs.h };
            losSegments.push({ p1, p2, ownerId: obs.id });
            losSegments.push({ p1: p2, p2: p3, ownerId: obs.id });
            losSegments.push({ p1: p3, p2: p4, ownerId: obs.id });
            losSegments.push({ p1: p4, p2: p1, ownerId: obs.id });
        };

        color_grid.forEach((row, y) => {
            for (let x = 0; x < row.length; x++) {
                const char = row[x]; const worldX = x * tileSize; const worldY = y * tileSize;
                if (char === 'B') {
                    const isEnclosed = wallCoordSet.has(`${x-1},${y}`) && wallCoordSet.has(`${x+1},${y}`) && wallCoordSet.has(`${x},${y-1}`) && wallCoordSet.has(`${x},${y+1}`);
                    const wall = { id: `wall_${x}_${y}`, type: 'wall', x: worldX, y: worldY, w: tileSize, h: tileSize, hp: Infinity, isEnclosed, borders: { top: !wallCoordSet.has(`${x},${y-1}`), bottom: !wallCoordSet.has(`${x},${y+1}`), left: !wallCoordSet.has(`${x-1},${y}`), right: !wallCoordSet.has(`${x+1},${y}`) } };
                    addObstacleWithLOS(wall);
                } else if (char === 'G') { floorTiles.push({x: worldX, y: worldY, w: tileSize, h: tileSize });
                } else if (char === 'R') { floorTiles.push({x: worldX, y: worldY, w: tileSize, h: tileSize }); tdmSpawnPoints.push({ x: worldX + tileSize / 2, y: worldY + tileSize / 2 });
                } else if (char === 'O') { floorTiles.push({x: worldX, y: worldY, w: tileSize, h: tileSize }); powerUps.push({ x: worldX + tileSize / 2, y: worldY + tileSize / 2, active: true, type: 'shotgun', radius: 10 });
                } else if (char === 'C') {
                    floorTiles.push({ x: worldX, y: worldY, w: tileSize, h: tileSize });
                    const gap = 5; const formationWidth = crateSize*2+gap; const formationHeight = crateSize*2+gap;
                    const tileStartX = worldX + (tileSize - formationWidth)/2; const tileStartY = worldY + (tileSize - formationHeight)/2;
                    const corners = { topLeft: {x:tileStartX, y:tileStartY}, topRight: {x:tileStartX+crateSize+gap, y:tileStartY}, bottomLeft: {x:tileStartX, y:tileStartY+crateSize+gap}, bottomRight: {x:tileStartX+crateSize+gap, y:tileStartY+crateSize+gap} };
                    let positions = [];
                    if (y < gridCenterY && x < gridCenterX) positions = [corners.topRight, corners.bottomLeft, corners.bottomRight];
                    else if (y < gridCenterY && x > gridCenterX) positions = [corners.topLeft, corners.bottomLeft, corners.bottomRight];
                    else if (y > gridCenterY && x < gridCenterX) positions = [corners.topLeft, corners.topRight, corners.bottomRight];
                    else if (y > gridCenterY && x > gridCenterX) positions = [corners.topLeft, corners.topRight, corners.bottomLeft];
                    positions.forEach((pos, i) => { 
                        const crate = {id:`crate_${x}_${y}_${i}`,type:'crate',x:pos.x,y:pos.y,w:crateSize,h:crateSize,hp:100};
                        addObstacleWithLOS(crate);
                    });
                }
            }
        });
        
        // Restore original Bomb Site A crates
        const siteA = bombSites.find(s => s.id === 'A');
        if (siteA) {
            const siteCrateSize = 25;
            const siteCrateHP = 150;
            const LformationsA = [
                { x_offset: -200, y_offset: -180, shape: [[0,0],[1,0],[0,1]] },
                { x_offset: -300, y_offset: -120, shape: [[0,0],[0,1],[-1,1]] },
                { x_offset: -200, y_offset: 155, shape: [[0,0],[1,0],[0,-1]] },
                { x_offset: -300, y_offset: 170, shape: [[0,0],[0,-1],[-1,-1]] }
            ];
            LformationsA.forEach((formation, i) => {
                formation.shape.forEach((pos, j) => {
                     const crate = { id: `extra_A_L_${i}_${j}`, type: 'crate', x: siteA.x + formation.x_offset + pos[0] * siteCrateSize, y: siteA.y + formation.y_offset + pos[1] * siteCrateSize, w: siteCrateSize, h: siteCrateSize, hp: siteCrateHP };
                     addObstacleWithLOS(crate);
                });
                formation.shape.forEach((pos, j) => {
                     const mirroredX = siteA.x - (formation.x_offset + (pos[0] * siteCrateSize)) - siteCrateSize;
                     const mirroredY = siteA.y + formation.y_offset + pos[1] * siteCrateSize;
                     const crate = { id: `extra_A_R_${i}_${j}`, type: 'crate', x: mirroredX, y: mirroredY, w: crateSize, h: siteCrateSize, hp: siteCrateHP };
                     addObstacleWithLOS(crate);
                });
            });
        }
        createPathfindingGrid();
    }

    function createPathfindingGrid() {
        const gridW = Math.ceil(mapWidth / GRID_SCALE);
        const gridH = Math.ceil(mapHeight / GRID_SCALE);
        pathfindingGrid = [];
        for (let y = 0; y < gridH; y++) {
            const row = [];
            for (let x = 0; x < gridW; x++) {
                const worldX = x * GRID_SCALE + GRID_SCALE / 2;
                const worldY = y * GRID_SCALE + GRID_SCALE / 2;
                let isWall = false;
                for (const obs of obstacles) {
                    if (worldX > obs.x && worldX < obs.x + obs.w && worldY > obs.y && worldY < obs.y + obs.h) {
                        isWall = true;
                        break;
                    }
                }
                row.push(isWall ? 1 : 0); // 1 is wall, 0 is walkable
            }
            pathfindingGrid.push(row);
        }
    }

    function findPath(startPos, endPos) {
        const gridW = pathfindingGrid[0].length;
        const gridH = pathfindingGrid.length;

        const startNode = {
            x: Math.floor(startPos.x / GRID_SCALE),
            y: Math.floor(startPos.y / GRID_SCALE),
            g: 0, h: 0, f: 0, parent: null
        };
        const endNode = {
            x: Math.floor(endPos.x / GRID_SCALE),
            y: Math.floor(endPos.y / GRID_SCALE)
        };
        
        if (startNode.x === endNode.x && startNode.y === endNode.y) return [];
        if (endNode.x < 0 || endNode.x >= gridW || endNode.y < 0 || endNode.y >= gridH || pathfindingGrid[endNode.y][endNode.x] === 1) {
             return []; // end position is not valid
        }


        const openList = [startNode];
        const closedList = new Set();

        while (openList.length > 0) {
            let lowestIndex = 0;
            for (let i = 1; i < openList.length; i++) {
                if (openList[i].f < openList[lowestIndex].f) {
                    lowestIndex = i;
                }
            }

            let currentNode = openList[lowestIndex];
            openList.splice(lowestIndex, 1);
            closedList.add(`${currentNode.x},${currentNode.y}`);

            if (currentNode.x === endNode.x && currentNode.y === endNode.y) {
                let path = [];
                let curr = currentNode;
                while (curr.parent) {
                    path.push({ x: curr.x * GRID_SCALE + GRID_SCALE / 2, y: curr.y * GRID_SCALE + GRID_SCALE / 2 });
                    curr = curr.parent;
                }
                return path.reverse();
            }

            const neighbors = [];
            const { x, y } = currentNode;
            if (y > 0) neighbors.push({ x, y: y - 1 });
            if (y < gridH - 1) neighbors.push({ x, y: y + 1 });
            if (x > 0) neighbors.push({ x: x - 1, y });
            if (x < gridW - 1) neighbors.push({ x: x + 1, y });

            for (const neighbor of neighbors) {
                if (closedList.has(`${neighbor.x},${neighbor.y}`) || pathfindingGrid[neighbor.y][neighbor.x] === 1) {
                    continue;
                }

                const gScore = currentNode.g + 1;
                let gScoreIsBest = false;

                const neighborNodeInOpen = openList.find(n => n.x === neighbor.x && n.y === neighbor.y);
                if (!neighborNodeInOpen) {
                    gScoreIsBest = true;
                    neighbor.h = Math.abs(neighbor.x - endNode.x) + Math.abs(neighbor.y - endNode.y);
                    openList.push({ ...neighbor, g: gScore, f: gScore + neighbor.h, parent: currentNode });
                } else if (gScore < neighborNodeInOpen.g) {
                    gScoreIsBest = true;
                }

                if (gScoreIsBest) {
                    if(neighborNodeInOpen){
                       neighborNodeInOpen.parent = currentNode;
                       neighborNodeInOpen.g = gScore;
                       neighborNodeInOpen.f = gScore + neighborNodeInOpen.h;
                    }
                }
            }
        }
        return []; // No path found
    }

    function generateSandPattern() { if(!mapWidth || !mapHeight) return; sandSpecks = []; dunes = []; const speckColors = ['rgba(193, 154, 107, 0.1)', 'rgba(160, 130, 90, 0.15)', 'rgba(240, 220, 170, 0.05)']; for (let i=0; i<1500; i++) { sandSpecks.push({ x:Math.random()*mapWidth, y:Math.random()*mapHeight, r:1+Math.random()*2, c: speckColors[Math.floor(Math.random() * speckColors.length)], type: Math.random() > 0.1 ? 'circle' : 'line' }); } for(let i = 0; i < 60; i++) { dunes.push({ x: Math.random() * mapWidth, y: Math.random() * mapHeight, radiusX: 100 + Math.random() * 200, radiusY: 20 + Math.random() * 40, rotation: Math.random() * Math.PI, color: `rgba(210, 180, 140, ${0.05 + Math.random() * 0.15})`, shadowColor: `rgba(139, 115, 85, ${0.04 + Math.random() * 0.1})` }); } }
    
    function createCharacter(details) { 
        const base = { 
            hp: initialHitPoints, fireCooldown: 0, radius: playerRadius, score: 0, powerUp: null, powerUpDuration: 0,
            showOnMinimapTimer: 0, aimAngle: 0, burstAimAngle: 0, hasBomb: false, isPlanting: false, plantTimer: 0, isDefusing: false,
            defuseTimer: 0, target: null, isBursting: false, burstsLeft: 0, burstCooldown: 0, kills: 0, assists: 0,
            plants: 0, defuses: 0, damageDealtTo: {}, isAvoiding: false, avoidAngle: 0, avoidTimer: 0, stuckTimer: 0,
            lastPosition: {x:0, y:0}, clipSize: 22, ammo: 22, isReloading: false, reloadTime: 2, reloadTimer: 0,
            isStrafing: false, strafeDirection: 1, strafeTimer: 0, strafeDecisionTimer: 0,
            path: [], pathfindingCooldown: 0, objectiveSite: null, isAiming: false,
            aiWantsToPlant: false, aiWantsToDefuse: false,
            networkInput: null // For host to store client inputs
        }; 
        const newChar = {...base, ...details}; 
        newChar.lastPosition = {x: newChar.x, y: newChar.y};
        return newChar; 
    }
    
    function createParticles(x, y, count, color) { for (let i = 0; i < count; i++) { const angle = Math.random() * Math.PI * 2; const speed = 2 + Math.random() * 3; particles.push({ x, y, dx: Math.cos(angle) * speed, dy: Math.sin(angle) * speed, radius: 1 + Math.random() * 2, color: color, lifetime: 20 + Math.random() * 20, alpha: 1 }); } }
    
    function createBullet(x, y, targetX, targetY, ownerId, ownerTeam, ownerIsAI = false) {
        const shooter = allCharacters.find(c => c.id === ownerId);
        if (!shooter) return;
        
        const color = shooter.color;
        const baseAngle = Math.atan2(targetY - y, targetX - x);
        const speed = ownerIsAI ? aiBulletSpeed : bulletSpeed;

        const dx = Math.cos(baseAngle) * speed;
        const dy = Math.sin(baseAngle) * speed;
        bullets.push({ x, y, dx, dy, owner: ownerId, team: ownerTeam, color: color });
        
        shooter.showOnMinimapTimer = 90;
    }
    
    function distSq(x1, y1, x2, y2) { const dx = x1 - x2; const dy = y1 - y2; return dx * dx + dy * dy; }
    function nearActiveBombSite(character) { return bombSites.find(site => distSq(character.x, character.y, site.x, site.y) < site.radius * site.radius); }
    function nearBomb(character) { return bomb.planted && distSq(character.x, character.y, bomb.x, bomb.y) < 100 * 100; }
    
    // This function is now only called by the host
    function plantBomb(character, site) {
        const plantData = {
            x: character.x,
            y: character.y,
            plantedBy: character.id,
            siteId: site.id,
            plantedByTeam: character.team
        };
        handleBombPlanted(plantData); // Update local state immediately

        character.hasBomb = false;
        character.isPlanting = false;
        character.plantTimer = 0;
        character.plants++;
        character.score += 100;

        if (isHost && socket && socket.connected) {
            socket.emit('bombPlanted', { roomId: currentMatchId, ...plantData });
        }
    }

    // Central handler for bomb plant logic (for host and clients)
    function handleBombPlanted(data) {
        bomb.x = data.x;
        bomb.y = data.y;
        bomb.planted = true;
        bomb.active = true;
        bomb.plantedByTeam = data.plantedByTeam;
        bomb.plantedById = data.plantedBy;
        bomb.timer = 0;
        bomb.siteId = data.siteId;
        bombPlantedTextTimer = 3;
        console.log(`💣 Bomb planted by player ${data.plantedBy}`);
    }
    
    function handleBombDefused(defusedById) {
        const defuser = allCharacters.find(c => c.id === defusedById);
        if (defuser) {
            defuser.isDefusing = false;
            if (bomb.active) { // only give points if it wasn't already defused this frame
                 defuser.defuses++;
                 defuser.score += 100;
            }
        }
        bomb.active = false; 
        bombDefusedTextTimer = 3.0;
    }

    function defuseBomb(character) {
        if (isHost || !currentMatchId) {
            handleBombDefused(character.id); // Host handles it instantly
            
            if(socket && socket.connected) { // Notify clients
                 socket.emit('bombDefused', { roomId: currentMatchId, defusedBy: character.id });
            }

            // Delay declaring the round winner
            setTimeout(() => {
                declareRoundWinner(character.team, "Bomb Defused"); 
            }, 2000); 
        }
    }
    
    function declareRoundWinner(winningTeam, reason) {
        if (inRoundTransition) return;
        inRoundTransition = true;
        
        const finalPlayerStats = allCharacters.map(p => ({
            id: p.id, name: p.name, team: p.team,
            kills: p.kills, assists: p.assists, plants: p.plants, defuses: p.defuses, score: p.score
        }));

        const shouldShowKillCam = !!lastKillInfo;

        if (isHost && socket && socket.connected) {
            if (shouldShowKillCam) { 
                const killTimestamp = lastKillInfo.timestamp;
                const startTime = killTimestamp - (KILL_CAM_HISTORY_SECONDS * 1000);
                const endTime = killTimestamp + (KILL_CAM_AFTERMATH_SECONDS * 1000);
                const replayBuffer = historyBuffer.filter(frame => frame.timestamp >= startTime && frame.timestamp <= endTime);

                socket.emit('startKillCam', {
                    roomId: currentMatchId,
                    winningTeam: winningTeam,
                    reason: reason,
                    lastKillInfo: lastKillInfo,
                    replayBuffer: replayBuffer,
                    finalObstacles: obstacles.map(o => ({...o})),
                    playerStats: finalPlayerStats 
                });
            } else {
                 socket.emit('roundOver', { 
                     roomId: currentMatchId, 
                     winnerTeam: winningTeam, 
                     reason: reason,
                     playerStats: finalPlayerStats 
                 });
            }
        } else if (!currentMatchId) {
            // Single player logic
             if (shouldShowKillCam) {
                const killTimestamp = lastKillInfo.timestamp;
                const startTime = killTimestamp - (KILL_CAM_HISTORY_SECONDS * 1000);
                const endTime = killTimestamp + (KILL_CAM_AFTERMATH_SECONDS * 1000);
                const replayBuffer = historyBuffer.filter(frame => frame.timestamp >= startTime && frame.timestamp <= endTime);
                startKillCam(winningTeam, reason, lastKillInfo, replayBuffer, obstacles.map(o => ({...o})), finalPlayerStats);
            } else {
                proceedToScoreboard(winningTeam, reason, finalPlayerStats);
            }
        }
    }
    
    function startKillCam(winningTeam, reason, killInfo, replayBuffer, finalObstacles, playerStats) {
        isKillCamActive = true;
        postKillCamReason = reason;
        postKillCamWinningTeam = winningTeam;
        postKillCamPlayerStats = playerStats;
        lastKillInfo = killInfo;
        finalKillerId = killInfo.killerId;
        
        killCamReplayBuffer = replayBuffer;
        killCamFinalObstacles = finalObstacles || obstacles;
        
        if (killCamReplayBuffer.length > 0) {
            const killTimeRelativeToBufferStart = lastKillInfo.timestamp - killCamReplayBuffer[0].timestamp;
            killCamOverlay.slowMoStartTime = killTimeRelativeToBufferStart - 1500;
            killCamOverlay.slowMoEndTime = killTimeRelativeToBufferStart;

            killCamReplayClock = 0; // Start replay clock from 0
            killCamOverlay.style.display = 'flex';
            const killer = killInfo.killer;
            if (killer) {
                killCamKillerName.textContent = killer.name;
                killCamPortraitCanvas.width = killCamPortraitCanvas.offsetWidth;
                killCamPortraitCanvas.height = killCamPortraitCanvas.offsetHeight;
                drawPlayerPortrait(killCamPortraitCanvas, killer, true);
            }
        } else {
            console.warn("Kill cam started with empty replay buffer. Skipping.");
            isKillCamActive = false;
            proceedToScoreboard(winningTeam, reason, playerStats);
        }
    }

    function proceedToScoreboard(winningTeam, reason, playerStats = null) {
        isRoundActive = false;
        killCamOverlay.style.display = 'none';
        
        let roundWinnerText = '';
        const winnerTeamName = winningTeam === 1 ? 'Blue Team' : 'Red Team';
        
        switch(reason) {
            case "Bomb Detonated": roundWinnerText = "Target Destroyed"; break;
            case "Bomb Defused": roundWinnerText = "Bomb Defused"; break;
            default: roundWinnerText = `${winnerTeamName} Won`; break;
        }
        
        // Let all clients predictively update their score for the scoreboard
        if (winningTeam === 1) roundState.blueScore++; else roundState.redScore++;
        
        const roundsToWin = parseInt(gameMode.charAt(0)) === 1 ? 3 : 3;
        const isMatchOver = roundState.blueScore >= roundsToWin || roundState.redScore >= roundsToWin;
        
        let mvpPlayerId = null;
        if (isMatchOver) {
             const winnerTeamNum = roundState.blueScore > roundState.redScore ? 1 : 2;
             const players = playerStats || allCharacters;
             const winningPlayers = players.filter(p => p.team === winnerTeamNum);
             if(winningPlayers.length > 0) {
                mvpPlayerId = winningPlayers.sort((a, b) => b.score - a.score)[0].id;
             }
             if (isHost && socket && socket.connected) {
                 socket.emit('gameOver', { roomId: currentMatchId, finalRoundState: roundState });
             }
             endGame();
        } else {
            const showScoreboard = () => {
                isDetonationSequenceActive = false;
                detonationCameraTarget = null;
                showRoundScoreboard(roundWinnerText, mvpPlayerId, false, playerStats);
                setTimeout(() => {
                    scoreboardOverlay.style.display = 'none';
                    if (isHost || !currentMatchId) {
                        startRound(allCharacters.map(p => ({id: p.id, name: p.name})));
                    } else {
                        // FIX: Client also needs to reset local state before countdown
                        resetClientStateForNewRound();
                        displayRoundCountdown();
                    }
                }, 5000);
            };

            if (reason === "Bomb Detonated") {
                setTimeout(showScoreboard, 3000); // Wait for detonation view
            } else {
                showScoreboard();
            }
        }
    }
    
    function hasLineOfSight(p1, p2, ignoreOwnerId = null) {
        const ray = { p1, p2 };
        const distToTargetSq = distSq(p1.x, p1.y, p2.x, p2.y);

        for (const segment of losSegments) {
            if (ignoreOwnerId && segment.ownerId === ignoreOwnerId) {
                continue; 
            }
            
            const intersection = getIntersection(ray, segment);
            if (intersection) {
                const distToIntersectionSq = distSq(p1.x, p1.y, intersection.x, intersection.y);
                if (distToIntersectionSq < distToTargetSq - 0.01) { 
                    return false;
                }
            }
        }
        return true;
    }

    function addKillFeedEntry(killer, victim) {
        const item = document.createElement('div');
        item.className = 'kill-feed-item';
        const killerSpan = `<span class="${killer.team === 1 ? 'blue-team' : 'red-team'}">${killer.name}</span>`;
        const victimSpan = `<span class="${victim.team === 1 ? 'blue-team' : 'red-team'}">${victim.name}</span>`;
        item.innerHTML = `${killerSpan} <span class="weapon">eliminated</span> ${victimSpan}`;
        killFeed.appendChild(item);
        setTimeout(() => {
            if (killFeed.contains(item)) {
                killFeed.removeChild(item);
            }
        }, 5000);
    }
    
    // Only called by host
    function applyDamageAndHandleKill(target, shooter, damage) {
        if (!isHost && currentMatchId) return;

        target.hp -= damage;
        if (shooter) target.damageDealtTo[shooter.id] = Date.now();
        createParticles(target.x, target.y, 8, 'red');

        if (target.hp <= 0) {
            target.hp = 0; // Prevent negative HP
            if (shooter) {
                shooter.kills++;
                shooter.score += 100;
                lastKillInfo = { killerId: shooter.id, victimId: target.id, timestamp: performance.now(), killer: {name: shooter.name, color: shooter.color, x: shooter.x, y: shooter.y} };
                
                if (socket && socket.connected) {
                    socket.emit('killFeedEvent', { 
                        roomId: currentMatchId,
                        killerName: shooter.name,
                        killerTeam: shooter.team,
                        victimName: target.name,
                        victimTeam: target.team
                    });
                }
            }

            const now = Date.now();
            for (const damagerId in target.damageDealtTo) {
                if (damagerId !== shooter?.id && (now - target.damageDealtTo[damagerId] < ASSIST_TIMER_DURATION)) {
                    const assister = allCharacters.find(c => c.id === damagerId);
                    if (assister) { assister.assists++; assister.score += 25; }
                }
            }

            if (target.hasBomb) {
                target.hasBomb = false;
                bombItem.isCarried = false;
                bombItem.x = target.x;
                bombItem.y = target.y;
            }
        }
    }

    function playerFire() {
        if (isDetonationSequenceActive || inRoundTransition) return; 
        const player = allCharacters.find(c => c.id === localPlayerId);
        if (!player || player.hp <= 0) return;

        const canFire = !player.isBursting && player.burstCooldown <= 0 && !player.isReloading && player.ammo > 0;

        if (canFire) {
            if (currentMatchId) {
                if (isHost) {
                    player.burstAimAngle = player.aimAngle;
                    player.isBursting = true;
                    player.burstsLeft = Math.min(BURST_COUNT, player.ammo);
                    player.fireCooldown = 0;
                } else {
                    // Client sends a request to fire using its locally-set aim angle
                    socket.emit('fireRequest', { aimAngle: localPlayerAimAngle });
                }
            } else {
                // Single player logic
                player.burstAimAngle = player.aimAngle;
                player.isBursting = true;
                player.burstsLeft = Math.min(BURST_COUNT, player.ammo);
                player.fireCooldown = 0;
            }
        }
    }

    function updateCharacters(deltaTime) {
        if (!isRoundActive && !inRoundTransition) return;
        
        const player = allCharacters.find(c => c.id === localPlayerId);
        
        if (player && player.hp <= 0 && !spectatingId) updateSpectateList(player);
        else if(spectatingId){
            const currentSpectateTarget = allCharacters.find(c => c.id === spectatingId);
            if(!currentSpectateTarget || currentSpectateTarget.hp <= 0) updateSpectateList(player);
        }
        
        allCharacters.forEach(character => {
            if (character.hp <= 0) return;
            
            if (character.showOnMinimapTimer > 0) character.showOnMinimapTimer--;
            if (character.pathfindingCooldown > 0) character.pathfindingCooldown -= deltaTime;
            if (character.avoidTimer > 0) character.avoidTimer -= deltaTime;
            
            let dx = 0, dy = 0; 
            const isAI = !character.id.includes('localPlayer');
            
            // --- Determine Input Source ---
            if (character.id === localPlayerId) {
                // It's me. Get local input.
                if(!character.isPlanting && !character.isDefusing && !isDetonationSequenceActive && !inRoundTransition) {
                    if (gameSettings.useJoysticks && movementJoystick?.isActive) { dx += movementJoystick.vector.x; dy += movementJoystick.vector.y; }
                    if (keysDown.a) dx -= 1; if (keysDown.d) dx += 1;
                    if (keysDown.w) dy -= 1; if (keysDown.s) dy += 1;
                }
                
                const isShootingJoystickActive = gameSettings.useJoysticks && shootingJoystick?.isActive && (shootingJoystick.vector.x !== 0 || shootingJoystick.vector.y !== 0);
                if (isLocalPlayerAiming) {
                    if (isShootingJoystickActive) {
                        localPlayerAimAngle = Math.atan2(shootingJoystick.vector.y, shootingJoystick.vector.x);
                    } else {
                        const worldX = (mousePos.x - canvasWidth / 2) / cameraZoom + character.x;
                        const worldY = (mousePos.y - canvasHeight / 2) / cameraZoom + character.y;
                        localPlayerAimAngle = Math.atan2(worldY - character.y, worldX - character.x);
                    }
                } else if (!character.isBursting) {
                    const mag = Math.sqrt(dx * dx + dy * dy);
                    if (mag > 0) {
                        localPlayerAimAngle = Math.atan2(dy, dx);
                    }
                }
                // Immediately update the local player's aim angle for responsive rendering.
                character.aimAngle = localPlayerAimAngle;

            } else if (currentMatchId && isHost) {
                // I am the HOST, this is a REMOTE player. Use their network input.
                if (character.networkInput) {
                    const input = character.networkInput;
                    dx = input.dx;
                    dy = input.dy;
                    character.aimAngle = input.aimAngle;
                    character.isAiming = input.isAiming;
                }
            } else if (isAI && (!currentMatchId || isHost)) {
                // --- AI LOGIC (only runs in single player or on host) ---
                let hasObjective = false;
                character.aiWantsToPlant = false;
                character.aiWantsToDefuse = false;
                character.isStrafing = false;
                
                // Unstuck logic
                character.stuckTimer += deltaTime;
                if(character.stuckTimer > 1) { // Check every second
                    if(distSq(character.x, character.y, character.lastPosition.x, character.lastPosition.y) < 5*5) {
                        character.path = []; // Clear path to force re-evaluation
                        character.avoidTimer = 0.5; // Avoid for a short period

                        // New logic: move perpendicular to the direction the AI is facing
                        const intendedAngle = character.aimAngle;
                        // Alternate the perpendicular direction to avoid getting stuck in loops
                        character.strafeDirection = (character.strafeDirection === 1) ? -1 : 1; 
                        character.avoidAngle = intendedAngle + (Math.PI / 2) * character.strafeDirection;
                    }
                    character.lastPosition = {x: character.x, y: character.y};
                    character.stuckTimer = 0;
                }

                if(character.avoidTimer > 0) {
                    dx = Math.cos(character.avoidAngle);
                    dy = Math.sin(character.avoidAngle);
                } else {
                    // 1. Objective Logic
                    if (character.team === roundState.attackingTeam && character.hasBomb) {
                        hasObjective = true;
                        if (!character.objectiveSite || character.objectiveSite.id === bomb.siteId) {
                            let closestSite = null;
                            let minDistSq = Infinity;
                            bombSites.forEach(site => {
                                const dSq = distSq(character.x, character.y, site.x, site.y);
                                if (dSq < minDistSq) {
                                    minDistSq = dSq;
                                    closestSite = site;
                                }
                            });
                            character.objectiveSite = closestSite;
                            character.path = []; 
                        }
                    } else if (character.team !== roundState.attackingTeam && bomb.planted) {
                        hasObjective = true;
                        character.objectiveSite = { x: bomb.x, y: bomb.y };
                    }

                    if (hasObjective) {
                        const targetPos = character.objectiveSite;
                        const distToTargetSq = distSq(character.x, character.y, targetPos.x, targetPos.y);
                        
                        if (character.path.length === 0 && character.pathfindingCooldown <= 0) {
                            character.path = findPath(character, targetPos);
                            character.pathfindingCooldown = 1.0; 
                        }

                        if (character.path.length > 0) {
                            const nextPoint = character.path[0];
                            const angleToNextPoint = Math.atan2(nextPoint.y - character.y, nextPoint.x - character.x);
                            dx = Math.cos(angleToNextPoint);
                            dy = Math.sin(angleToNextPoint);
                            character.aimAngle = angleToNextPoint;
                            if (distSq(character.x, character.y, nextPoint.x, nextPoint.y) < 50*50) {
                                character.path.shift();
                            }
                        }

                        if (character.team === roundState.attackingTeam && distToTargetSq < character.objectiveSite.radius * character.objectiveSite.radius) {
                            character.aiWantsToPlant = true; 
                        }
                        if (character.team !== roundState.attackingTeam && distToTargetSq < 100 * 100) {
                             character.aiWantsToDefuse = true;
                        }
                    }

                    // 2. Combat Logic (Overrides other movement if enemy is visible)
                    let closestEnemy = null;
                    let min_dist_sq = Infinity;
                    allCharacters.forEach(other => {
                        if (other.hp > 0 && other.team !== character.team && hasLineOfSight(character, other)) {
                            const d_sq = distSq(character.x, character.y, other.x, other.y);
                            if (d_sq < min_dist_sq) {
                                min_dist_sq = d_sq;
                                closestEnemy = other;
                            }
                        }
                    });

                    if(closestEnemy) {
                        const angleToEnemy = Math.atan2(closestEnemy.y - character.y, closestEnemy.x - character.x);
                        character.aimAngle = angleToEnemy;
                        character.isStrafing = true; // Always strafe when enemy is visible

                        // Attempt to shoot
                        if (!character.isBursting && character.burstCooldown <= 0 && !character.isReloading && character.ammo > 0) {
                            character.burstAimAngle = character.aimAngle;
                            character.isBursting = true;
                            character.burstsLeft = Math.min(BURST_COUNT, character.ammo);
                            character.fireCooldown = 0;
                        }
                    }

                    // If not moving towards objective, default to hunting non-visible enemies
                    if (!hasObjective && !closestEnemy) {
                        // Find any enemy, even without LOS
                        let fallbackTarget = allCharacters.find(c => c.team !== character.team && c.hp > 0);
                        if (fallbackTarget) {
                            if (character.path.length === 0 && character.pathfindingCooldown <= 0) {
                                character.path = findPath(character, fallbackTarget);
                                character.pathfindingCooldown = 1.0; 
                            }
                             if (character.path.length > 0) {
                                const nextPoint = character.path[0];
                                const angleToNextPoint = Math.atan2(nextPoint.y - character.y, nextPoint.x - character.x);
                                dx = Math.cos(angleToNextPoint);
                                dy = Math.sin(angleToNextPoint);
                                character.aimAngle = angleToNextPoint;
                                if (distSq(character.x, character.y, nextPoint.x, nextPoint.y) < 50*50) {
                                    character.path.shift();
                                }
                            }
                        }
                    }

                    // Strafing movement
                    if(character.isStrafing) {
                        character.strafeTimer -= deltaTime;
                        if(character.strafeTimer <= 0) {
                            character.strafeDirection *= -1;
                            character.strafeTimer = 1 + Math.random() * 2; // Strafe for 1-3 seconds
                        }
                        const strafeAngle = character.aimAngle + (Math.PI / 2) * character.strafeDirection;
                        dx = Math.cos(strafeAngle);
                        dy = Math.sin(strafeAngle);
                    }
                }
            }

            // --- Apply Movement & Logic (only for host or in single player) ---
            if (!currentMatchId || isHost) {
                const speed = isAI ? aiMoveSpeed : moveSpeed;
                const mag = Math.sqrt(dx * dx + dy * dy);
                if (mag > 0) resolveMovementWithCollision(character, dx / mag * speed * deltaTime, dy / mag * speed * deltaTime);

                if(character.fireCooldown > 0) character.fireCooldown--;
                if(character.burstCooldown > 0) character.burstCooldown--;
                
                if (character.isReloading) {
                    character.reloadTimer -= deltaTime;
                    if (character.reloadTimer <= 0) {
                        character.isReloading = false;
                        character.ammo = character.clipSize;
                    }
                } else if (isAI && character.ammo <= 0) { // AI auto-reload
                    character.isReloading = true; 
                    character.reloadTimer = character.reloadTime;
                }

                if (character.isBursting && character.fireCooldown <= 0 && character.burstsLeft > 0) {
                    const targetX = character.x + Math.cos(character.burstAimAngle) * 100;
                    const targetY = character.y + Math.sin(character.burstAimAngle) * 100;
                    
                    createBullet(character.x, character.y, targetX, targetY, character.id, character.team, isAI);

                    character.fireCooldown = BURST_FIRE_RATE;
                    character.burstsLeft--;
                    character.ammo--;
                    if (character.burstsLeft === 0) {
                        character.isBursting = false;
                        character.burstCooldown = BURST_COOLDOWN_TIME * (isAI ? aiFireRateModifier : 1);
                    }
                } 
                
                if (gameMode.includes('v')) {
                    if (!bombItem.isCarried && character.team === roundState.attackingTeam && distSq(character.x, character.y, bombItem.x, bombItem.y) < (character.radius + bombItem.radius)**2) {
                        bombItem.isCarried = true; character.hasBomb = true;
                    }
                    
                    if (character.hasBomb && !bomb.planted && !inRoundTransition) {
                        const site = nearActiveBombSite(character);
                        const isPlantingInput = (character.id === localPlayerId) ? (isPlantingButtonHeld || keysDown['e']) : (character.networkInput?.isPlantingButtonHeld || character.aiWantsToPlant);
                        if (site && isPlantingInput) {
                            character.isPlanting = true; character.plantTimer += deltaTime;
                            if (character.plantTimer >= BOMB_PLANT_TIME) plantBomb(character, site);
                        } else {
                            character.isPlanting = false; character.plantTimer = 0;
                        }
                    }

                    if (bomb.planted && bomb.active && character.team !== roundState.attackingTeam && !inRoundTransition) {
                        const isNearBomb = nearBomb(character);
                        const isDefusingInput = (character.id === localPlayerId) ? (isDefusingButtonHeld || (keysDown['e'] && isNearBomb)) : (character.networkInput?.isDefusingButtonHeld || character.aiWantsToDefuse);

                        if (isNearBomb && isDefusingInput) {
                            character.isDefusing = true;
                            character.defuseTimer += deltaTime;
                            if (character.defuseTimer >= BOMB_DEFUSE_TIME) {
                                defuseBomb(character);
                            }
                        } else {
                            character.isDefusing = false;
                            character.defuseTimer = 0;
                        }
                    }
                }
            }
        });
    }
    
    function updateGameTimers(deltaTime) {
        if (!isHost && currentMatchId) return;

        if (bombDefusedTextTimer > 0) bombDefusedTextTimer -= deltaTime;
        if (bombPlantedTextTimer > 0) bombPlantedTextTimer -= deltaTime;

        if (gameMode.includes('v')) {
            if (!inRoundTransition && isRoundActive && !bomb.planted) {
                if (gameState.gameTimer > 0) gameState.gameTimer -= deltaTime;
                else {
                    const defendingTeam = roundState.attackingTeam === 1 ? 2 : 1;
                    declareRoundWinner(defendingTeam, "Time Expired");
                    return;
                }
            }
            if (bomb.planted && bomb.active) { 
                bomb.timer += deltaTime; 
                if (bomb.timer >= BOMB_TIMER_DURATION) { 
                    handleBombExplosion(Date.now());
                    if (isHost && socket && socket.connected) {
                        socket.emit('bombExploded', { roomId: currentMatchId, explodedAt: Date.now(), x: bomb.x, y: bomb.y });
                    }
                } 
            }
            
            if (roundStartTextTimer > 0) roundStartTextTimer -= deltaTime;
        }
    }

    function handleBombExplosion(timestamp) {
        if (isDetonationSequenceActive) return;

        bomb.active = false;
        bomb.isExploded = true; 
        gameTimerBar.textContent = '0';
        isDetonationSequenceActive = true;
        detonationCameraTarget = { x: bomb.x, y: bomb.y };
        screenShake = { intensity: 20, duration: 3.0 };

        // Host is the authority on round ending and waits before declaring it.
        if (isHost || !currentMatchId) {
            setTimeout(() => {
                declareRoundWinner(bomb.plantedByTeam, "Bomb Detonated");
            }, 3000); // Wait 3 seconds for the explosion view
        }
    }
    
    function checkWinCondition() {
        if (!isHost && currentMatchId) return;
        if (isGameOver || inRoundTransition || !isRoundActive) return;
        if (gameMode.includes('v')) {
            const attackersAlive = allCharacters.some(c => c.team === roundState.attackingTeam && c.hp > 0);
            const defendersAlive = allCharacters.some(c => c.team !== roundState.attackingTeam && c.hp > 0);
            const defendingTeam = roundState.attackingTeam === 1 ? 2 : 1;

            if (!attackersAlive && !defendersAlive) {
                declareRoundWinner(bomb.planted ? roundState.attackingTeam : defendingTeam, "All players eliminated");
                return;
            }

            if (!defendersAlive) {
                declareRoundWinner(roundState.attackingTeam, "Defenders Eliminated");
            } else if (!attackersAlive && !bomb.planted) {
                declareRoundWinner(defendingTeam, "Attackers Eliminated");
            }
        }
    }
    
    function showRoundScoreboard(winnerText, mvpId = null, isFinal = false, playerStats = null) {
        scoreboardOverlay.style.display = 'flex';
        roundScoreboardElement.style.display = 'flex';
        roundWinnerTextElement.textContent = winnerText;
        const roundScoreContainer = document.getElementById('round-end-match-score');
        roundScoreContainer.innerHTML = '';
        
        const roundsToWin = parseInt(gameMode.charAt(0)) === 1 ? 3 : 3;
        for (let i = 1; i <= roundsToWin; i++) {
            const scoreBox = document.createElement('div');
            scoreBox.className = roundState.blueScore >= i ? 'score-box blue-win' : 'score-box';
            roundScoreContainer.appendChild(scoreBox);
        }
        
        const vs = document.createElement('span');
        vs.className = 'vs-text';
        vs.textContent = 'VS';
        roundScoreContainer.appendChild(vs);

        for (let i = 1; i <= roundsToWin; i++) {
            const scoreBox = document.createElement('div');
            scoreBox.className = roundState.redScore >= i ? 'score-box red-win' : 'score-box';
            roundScoreContainer.appendChild(scoreBox);
        }
        
        scoreboardBlueTeam.innerHTML = '';
        scoreboardRedTeam.innerHTML = '';
        const playersToShow = playerStats ? playerStats : [...allCharacters];
        const sortedPlayers = [...playersToShow].sort((a, b) => b.score - a.score);

        sortedPlayers.forEach(p => {
            const playerRow = document.createElement('div');
            playerRow.className = 'scoreboard-player-row';
            
            let nameHTML = `<div class="player-name-cell">${p.id === localPlayerId ? 'You' : p.name}`;
            if (p.id === mvpId) {
                nameHTML += `<span class="mvp-sticker">MVP</span>`;
            }
            nameHTML += `</div>`;

            playerRow.innerHTML = `
                ${nameHTML}
                <div class="col-stat">${p.kills}</div>
                <div class="col-stat">${p.assists}</div>
                <div class="col-stat">${p.plants}</div>
                <div class="col-stat">${p.defuses}</div>
                <div class="col-stat">${p.score}</div>
            `;

            if (p.team === 1) scoreboardBlueTeam.appendChild(playerRow);
            else scoreboardRedTeam.appendChild(playerRow);
        });
        
        if (isFinal) {
            scoreboardLeaveMatchButton.style.display = 'block';
            scoreboardLeaveMatchButton.onclick = leaveMatch;
        } else {
            scoreboardLeaveMatchButton.style.display = 'none';
        }
    }
    
    function drawBombSites(g = ctx) { bombSites.forEach(site => { g.save(); g.beginPath(); g.arc(site.x, site.y, site.radius, 0, Math.PI * 2); g.strokeStyle = bomb.siteId === site.id && bomb.active ? 'rgba(255, 80, 80, 0.9)' : 'rgba(255,255,255,0.4)'; g.lineWidth = 4; g.setLineDash([10, 10]); g.stroke(); g.fillStyle = bomb.siteId === site.id && bomb.active ? 'rgba(255, 80, 80, 0.2)' : 'rgba(255,255,255,0.1)'; g.fill(); g.fillStyle = 'rgba(255,255,255,0.8)'; g.font = 'bold 48px Courier New'; g.textAlign = 'center'; g.textBaseline = 'middle'; g.fillText(site.id, site.x, site.y); g.restore(); }); }
    function drawBomb(x, y, isPlanted, isFlashing, g = ctx) { const color = isPlanted && isFlashing ? 'red' : '#333'; g.fillStyle = color; g.fillRect(x - 10, y - 5, 20, 10); g.fillStyle = '#555'; g.fillRect(x - 2, y - 8, 4, 3); }
    
    function isObjectVisible(rect, cameraTarget) {
        if(!cameraTarget) return false;
        const corners = [{ x: rect.x, y: rect.y }, { x: rect.x + rect.w, y: rect.y }, { x: rect.x, y: rect.y + rect.h }, { x: rect.x + rect.w, y: rect.y + rect.h }];
        for (const corner of corners) {
            if (distSq(cameraTarget.x, cameraTarget.y, corner.x, corner.y) <= lightRadius * lightRadius && hasLineOfSight(cameraTarget, corner, rect.id)) {
                return true;
            }
        }
        return false;
    }
    
    function drawBombItem(g = ctx, visibilityPolygon, itemToDraw, cameraTarget) {
        if (itemToDraw.isCarried || bomb.planted) return;
        const rect = {id: 'bomb', x: itemToDraw.x - 10, y: itemToDraw.y - 5, w: 20, h: 10};
        if (isObjectVisible(rect, cameraTarget)) {
            drawBomb(itemToDraw.x, itemToDraw.y, false, false, g);
        }
    }

    function drawBombObject(g = ctx, visibilityPolygon, bombToDraw, cameraTarget) {
        if (!bombToDraw.planted || bombToDraw.isExploded) return;
        const rect = {id: 'bomb', x: bombToDraw.x - 10, y: bombToDraw.y - 5, w: 20, h: 10};
        if (isObjectVisible(rect, cameraTarget)) {
            const isFlashing = Math.floor(performance.now() / 500) % 2 === 0;
            drawBomb(bombToDraw.x, bombToDraw.y, true, isFlashing, g);
        }
    }
    function drawDesertBackground(g = ctx) { if(!mapWidth || !mapHeight) return; const baseGradient = g.createRadialGradient(mapCenter.x, mapCenter.y, mapHeight * 0.1, mapCenter.x, mapCenter.y, mapHeight); baseGradient.addColorStop(0, '#E7D3A1'); baseGradient.addColorStop(1, '#CDBA96'); g.fillStyle = baseGradient; g.fillRect(0,0,mapWidth, mapHeight); dunes.forEach(dune => { g.save(); g.translate(dune.x + 8, dune.y + 6); g.rotate(dune.rotation); g.scale(dune.radiusX, dune.radiusY); g.beginPath(); g.arc(0, 0, 1, 0, Math.PI * 2); g.fillStyle = dune.shadowColor; g.fill(); g.restore(); }); dunes.forEach(dune => { g.save(); g.beginPath(); g.translate(dune.x, dune.y); g.rotate(dune.rotation); g.scale(dune.radiusX, dune.radiusY); g.arc(0, 0, 1, 0, Math.PI * 2); g.fillStyle = dune.color; g.fill(); g.restore(); }); sandSpecks.forEach(s => { if (s.type === 'circle') { drawCircle(s.x, s.y, s.r, s.c, g) } else { g.beginPath(); g.moveTo(s.x, s.y); g.lineTo(s.x + 1 + Math.random() * 2, s.y); g.strokeStyle = s.c; g.stroke(); } }); const lightGradient = g.createRadialGradient(mapCenter.x, mapCenter.y, mapHeight * 0.2, mapCenter.x, mapCenter.y, mapHeight * 1.5); lightGradient.addColorStop(0, 'rgba(255, 245, 230, 0.02)'); lightGradient.addColorStop(1, 'rgba(0, 0, 0, 0.05)'); g.fillStyle = lightGradient; g.fillRect(0, 0, mapWidth, mapHeight); }
    
    function drawGame(timestamp, frameState = null) {
        let currentState;
        
        if (frameState){ // For kill cam replay
            // frameState is the lean snapshot from the replay buffer
            currentState = {
                ...frameState, // contains characters, bullets, bomb, bombItem, etc.
                obstacles: killCamFinalObstacles, // Add the static obstacles
                particles: [] // No particles for replay
            };
        } else {
            // Normal gameplay, use global state
            currentState = {
                characters: allCharacters,
                bullets: bullets,
                bomb: bomb,
                bombItem: bombItem,
                particles: particles,
                obstacles: obstacles
            };
        }
        
        let cameraTarget;
        if (isDetonationSequenceActive) {
            cameraTarget = detonationCameraTarget;
        } else if (isKillCamActive) {
            cameraTarget = currentState.characters.find(c => c.id === finalKillerId) || { x: mapCenter.x, y: mapCenter.y };
        } else {
            cameraTarget = currentState.characters.find(c => c.id === spectatingId || (c.id === localPlayerId && !spectatingId)) || { x: mapCenter.x, y: mapCenter.y };
        }

        if (!cameraTarget) { // Fallback if camera target becomes null
            cameraTarget = { x: mapCenter.x, y: mapCenter.y };
        }
        
        const player = currentState.characters.find(c => c.id === localPlayerId);
        
        const allSegments = losSegments.concat([
            { p1: {x:0, y:0}, p2: {x:mapWidth, y:0} }, { p1: {x:mapWidth, y:0}, p2: {x:mapWidth, y:mapHeight} },
            { p1: {x:mapWidth, y:mapHeight}, p2: {x:0, y:mapHeight} }, { p1: {x:0, y:mapHeight}, p2: {x:0, y:0} }
        ]);
        const visibilityPolygon = calculateVisibility(cameraTarget, allSegments);
        
        // ##### START MAIN DRAWING ON GAME CANVAS #####
        ctx.save();
        ctx.clearRect(0, 0, gameCanvas.width, gameCanvas.height);
        
        if (screenShake.intensity > 0) {
            ctx.translate(
                Math.random() * screenShake.intensity - screenShake.intensity / 2,
                Math.random() * screenShake.intensity - screenShake.intensity / 2
            );
        }

        ctx.translate(gameCanvas.width / 2, gameCanvas.height / 2);
        ctx.scale(cameraZoom, cameraZoom);
        ctx.translate(-cameraTarget.x, -cameraTarget.y);
        
        drawDesertBackground(ctx);
        drawFloors(ctx);
        drawWalls(ctx, currentState.obstacles);
        drawBombSites(ctx);
        
        currentState.obstacles.forEach(obs => { 
            if (obs.type === 'crate') {
                drawCrate(obs, ctx);
            }
        });

        drawBombItem(ctx, visibilityPolygon, currentState.bombItem, cameraTarget);
        drawBombObject(ctx, visibilityPolygon, currentState.bomb, cameraTarget);
        
        if (player && player.hp > 0 && isLocalPlayerAiming && !isKillCamActive && !inRoundTransition) {
            ctx.save();
            ctx.beginPath();
            ctx.moveTo(player.x, player.y);
            const lineLength = 1000;
            // Use the locally calculated aim angle for immediate visual feedback.
            ctx.lineTo(player.x + Math.cos(localPlayerAimAngle) * lineLength, player.y + Math.sin(localPlayerAimAngle) * lineLength);
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
            ctx.lineWidth = 2;
            ctx.setLineDash([10, 15]);
            ctx.stroke();
            ctx.restore();
        }
        
        currentState.characters.forEach(char => drawCharacter(char, ctx, cameraTarget, player));
        currentState.bullets.forEach(b => drawCircle(b.x, b.y, bulletRadius, b.color, ctx));
        currentState.particles.forEach(p => { ctx.globalAlpha = p.alpha; drawCircle(p.x, p.y, p.radius, p.color, ctx); ctx.globalAlpha = 1; });
        ctx.restore();
        // ##### END MAIN DRAWING ON GAME CANVAS #####


        // ##### START FOG OF WAR DRAWING #####
        fogCtx.clearRect(0, 0, fogCanvas.width, fogCanvas.height);
        fogCtx.fillStyle = 'rgba(26, 26, 26, 0.75)';
        fogCtx.fillRect(0, 0, fogCanvas.width, fogCanvas.height);

        fogCtx.save();
        fogCtx.translate(fogCanvas.width / 2, fogCanvas.height / 2);
        fogCtx.scale(cameraZoom, cameraZoom);
        fogCtx.translate(-cameraTarget.x, -cameraTarget.y);

        fogCtx.globalCompositeOperation = 'destination-out';
        fogCtx.filter = 'blur(16px)';
        if (visibilityPolygon.length > 0) {
            fogCtx.beginPath();
            fogCtx.moveTo(visibilityPolygon[0].x, visibilityPolygon[0].y);
            for (let i = 1; i < visibilityPolygon.length; i++) {
                fogCtx.lineTo(visibilityPolygon[i].x, visibilityPolygon[i].y);
            }
            fogCtx.closePath();
            fogCtx.fillStyle = '#fff';
            fogCtx.fill();
        }

        fogCtx.filter = 'none';
        currentState.obstacles.forEach(obs => {
            if (obs.type === 'crate' && isObjectVisible(obs, cameraTarget)) {
                fogCtx.fillRect(obs.x, obs.y, obs.w, obs.h);
            }
        });

        fogCtx.restore();
        ctx.drawImage(fogCtx.canvas, 0, 0); 
        // ##### END FOG OF WAR DRAWING #####


        if (!isKillCamActive) {
            if (gameSettings.useJoysticks) { 
                if (movementJoystick && movementJoystick.isActive) movementJoystick.draw(ctx);
                if (shootingJoystick && shootingJoystick.isActive) shootingJoystick.draw(ctx);
            }
            if(!inRoundTransition) updateUI(currentState);
            drawMinimap(currentState);
        } else {
             gameUiElement.style.display = 'none';
        }
    }
    
    function updateUI(currentState) {
        const player = currentState.characters.find(c => c.id === localPlayerId);
        if (player) {
            ammoCounterElement.textContent = `${player.isReloading ? 'Reloading...' : player.ammo + ' / ' + player.clipSize}`;
            playerNameDisplay.textContent = player.name;
            const hpPercent = Math.max(0, player.hp / initialHitPoints) * 100;
            playerHealthBar.style.width = `${hpPercent}%`;
        }
        
        tdmUiContainer.style.display = (gameMode.includes('v')) ? 'flex' : 'none';
        plantBombButton.style.display = 'none';
        defuseBombButton.style.display = 'none';

        if (gameMode.includes('v') && player) {
            updateTeamStatusUI(currentState.characters);

            if (currentState.bomb.planted) {
                gameTimerBar.style.color = '#FF4747';
                const timeLeft = BOMB_TIMER_DURATION - currentState.bomb.timer;
                gameTimerBar.textContent = Math.max(0, Math.ceil(timeLeft));
            } else {
                gameTimerBar.style.color = '#FFF8DC';
                const minutes = Math.floor(Math.max(0, gameState.gameTimer) / 60);
                const seconds = Math.floor(Math.max(0, gameState.gameTimer) % 60);
                gameTimerBar.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
            }
            
            if (roundStartTextTimer > 0) {
                gameEventText.style.display = 'block';
                gameEventText.style.color = '#FFF8DC';
                gameEventText.textContent = player.team === roundState.attackingTeam ? 'Destroy The Objectives' : 'Defend The Objectives';
            } else if (bombPlantedTextTimer > 0) {
                gameEventText.style.display = 'block';
                gameEventText.style.color = '#FF4747';
                gameEventText.textContent = 'Bomb Planted';
            } else if (bombDefusedTextTimer > 0) {
                gameEventText.style.display = 'block';
                gameEventText.style.color = '#FFFFFF';
                gameEventText.textContent = 'Bomb Defused';
            }
            else {
                gameEventText.style.display = 'none';
            }

            blueScoreDisplay.textContent = roundState.blueScore;
            redScoreDisplay.textContent = roundState.redScore;
            teamRoleDisplay.textContent = roundState.attackingTeam === player.team ? 'ATTACKER' : 'DEFENDER';
            
            if(player.hasBomb) {
                bombIconContainer.style.display = 'block';
                const site = nearActiveBombSite(player);
                if (site) {
                    plantBombButton.style.display = 'block';
                    if (player.isPlanting) {
                        const plantProgress = (player.plantTimer / BOMB_PLANT_TIME) * 100;
                        plantBombButton.style.background = `linear-gradient(to right, #6c757d ${plantProgress}%, #4a4a4a ${plantProgress}%)`;
                        plantBombButton.textContent = 'Planting...';
                    } else {
                        plantBombButton.style.background = '#4a4a4a';
                        plantBombButton.textContent = 'Hold to Plant';
                    }
                }
            } else {
                bombIconContainer.style.display = 'none';
            }

            if (currentState.bomb.planted && currentState.bomb.active && player.team !== roundState.attackingTeam) {
                const isNearBomb = nearBomb(player);
                if (isNearBomb) {
                    defuseBombButton.style.display = 'block';
                    if (player.isDefusing) {
                        const defuseProgress = (player.defuseTimer / BOMB_DEFUSE_TIME) * 100;
                        defuseBombButton.style.background = `linear-gradient(to right, #6c757d ${defuseProgress}%, #4a4a4a ${defuseProgress}%)`;
                        defuseBombButton.textContent = 'Defusing...';
                    } else {
                        defuseBombButton.style.background = '#4a4a4a';
                        defuseBombButton.textContent = 'Hold to Defuse';
                    }
                }
            }
        }
        spectateControls.style.display = spectatingId ? 'flex' : 'none';
    }

    function initializeCharacters(players = null) {
        allCharacters = [];
        let aiCounter = 1;
        const team1Colors = ['#4682B4', '#6495ED', '#87CEEB'];
        const team2Colors = ['#DC143C', '#B22222', '#8B0000'];
        
        const leftSpawns = tdmSpawnPoints.filter(p => p.x < mapCenter.x);
        const rightSpawns = tdmSpawnPoints.filter(p => p.x > mapCenter.x);
        
        const getUniqueSpawn = (spawnList) => spawnList.length === 0 ? { x: mapCenter.x, y: mapCenter.y } : spawnList.splice(Math.floor(Math.random() * spawnList.length), 1)[0];

        const team1IsAttacker = roundState.attackingTeam === 1;
        const team1SpawnList = [...(team1IsAttacker ? leftSpawns : rightSpawns)];
        const team2SpawnList = [...(team1IsAttacker ? rightSpawns : leftSpawns)];

        if (players && players.length > 0) { // Multiplayer character creation
            const team1 = [], team2 = [];
            players.forEach((p, i) => {
                if (i % 2 === 0) team1.push(p);
                else team2.push(p);
            });

            team1.forEach((p, i) => {
                allCharacters.push(createCharacter({
                    id: p.id, name: p.name, team: 1, color: team1Colors[i % team1Colors.length], ...getUniqueSpawn(team1SpawnList)
                }));
            });
            team2.forEach((p, i) => {
                allCharacters.push(createCharacter({
                    id: p.id, name: p.name, team: 2, color: team2Colors[i % team2Colors.length], ...getUniqueSpawn(team2SpawnList)
                }));
            });

        } else { // Single player character creation
            if (!localPlayerId) localPlayerId = 'localPlayer_' + Math.random().toString(36).substring(2, 9);
            const teamSize = parseInt(gameMode.charAt(0));

            for (let i = 0; i < teamSize; i++) {
                allCharacters.push(createCharacter({id: i === 0 ? localPlayerId : `ally${i}`, name: i === 0 ? 'You' : `AI ${aiCounter++}`, team:1, color:team1Colors[i], ...getUniqueSpawn(team1SpawnList)}));
                allCharacters.push(createCharacter({id:`enemy${i+1}`, name: `AI ${aiCounter++}`, team:2, color:team2Colors[i], ...getUniqueSpawn(team2SpawnList)}));
            }
        }
    }

    function resetClientStateForNewRound() {
        spectatingId = null;
        spectatablePlayers = [];
        bullets = [];
        particles = [];
        killCamOverlay.style.display = 'none';
        isKillCamActive = false;
        lastKillInfo = null;
        bombPlantedTextTimer = 0;
        bombDefusedTextTimer = 0;
    }
    
    function startRound(players) {
        inRoundTransition = false;
        isDetonationSequenceActive = false;
        detonationCameraTarget = null;
        spectatingId = null; 
        spectatablePlayers = []; 
        isRoundActive = false; 
        isKillCamActive = false;
        bullets = []; 
        floatingTexts = []; 
        particles = []; 
        historyBuffer = []; 
        lastKillInfo = null;
        bomb = { active: false, planted: false, isExploded: false, timer: 0, siteId: null, plantedByTeam: null, plantedById: null };
        bombItem.isCarried = false; 
        bombPlantedTextTimer = 0; 
        bombDefusedTextTimer = 0;
        roundStartTextTimer = 5; 
        if (gameState) gameState.gameTimer = 120; 

        // Host is the authority on round state
        if (isHost || !currentMatchId) {
            roundState.roundNumber++; 
            roundState.attackingTeam = (roundState.roundNumber % 2 === 1) ? 1 : 2; 
        }
        
        const playerStats = allCharacters.map(p => ({ id: p.id, kills: p.kills, assists: p.assists, plants: p.plants, defuses: p.defuses, score: p.score }));
        initializeCharacters(players);
        allCharacters.forEach(p => {
            const stats = playerStats.find(s => s.id === p.id);
            if (stats) { Object.assign(p, stats); }
        });
        
        if (isHost || !currentMatchId) {
            const attackers = allCharacters.filter(p => p.team === roundState.attackingTeam);
            if(attackers.length > 0) {
                const attackerSpawnX = attackers.reduce((sum, p) => sum + p.x, 0) / attackers.length;
                const attackerSpawnY = attackers.reduce((sum, p) => sum + p.y, 0) / attackers.length;
                const offset = (attackerSpawnX < mapCenter.x) ? 120 : -120;
                bombItem.x = attackerSpawnX + offset; 
                bombItem.y = attackerSpawnY;
            }
        }
        
        if (roundState.roundNumber === 1 || (currentMatchId && roundState.roundNumber === 0)) {
             if(currentMatchId) roundState.roundNumber = 1; // Sync for clients
             displayMatchupScreen(); 
        } else {
            displayRoundCountdown();
        }
    }

    function displayMatchupScreen() {
        showScreen('matchup-screen');
        const matchupBgCtx = matchupBgCanvas.getContext('2d');
        matchupBgCanvas.width = window.innerWidth; matchupBgCanvas.height = window.innerHeight;
        matchupBgCtx.drawImage(offscreenMinimapCanvas, 0, 0, matchupBgCanvas.width, matchupBgCanvas.height);
        matchupBlueTeamContainer.innerHTML = ''; matchupRedTeamContainer.innerHTML = '';

        const createPlayerCard = (character) => {
            const card = document.createElement('div'); card.className = 'matchup-player-card';
            const portraitCanvas = document.createElement('canvas');
            portraitCanvas.width = 60; portraitCanvas.height = 60;
            drawPlayerPortrait(portraitCanvas, character);
            const nameDiv = document.createElement('div');
            nameDiv.className = 'player-name'; nameDiv.textContent = character.id === localPlayerId ? 'You' : character.name;
            card.appendChild(portraitCanvas); card.appendChild(nameDiv);
            return card;
        };

        allCharacters.forEach(char => {
            if (char.team === 1) matchupBlueTeamContainer.appendChild(createPlayerCard(char));
            else matchupRedTeamContainer.appendChild(createPlayerCard(char));
        });
        setTimeout(() => displayRoundCountdown(), 4000); 
    }
    
    function displayRoundCountdown() {
        showScreen('game'); 
        spectatingId = null; // Reset spectating view for all clients
        bombPlantedTextTimer = 0;
        bombDefusedTextTimer = 0;
        let count = 2;
        roundCountdownElement.style.display = 'block'; roundCountdownElement.textContent = count;
        
        const countdownInterval = setInterval(() => {
            count--;
            if (count > 0) roundCountdownElement.textContent = count;
            else {
                clearInterval(countdownInterval);
                roundCountdownElement.style.display = 'none';
                isRoundActive = true;
                lastTimestamp = performance.now();
            }
        }, 1000);
        
        lastTimestamp = performance.now();
        if (animationFrameId) cancelAnimationFrame(animationFrameId);
        animationFrameId = requestAnimationFrame(gameLoop);
    }

    function drawFullMapToOffscreenCanvas() {
        if (!mapWidth || !mapHeight) return;
        offscreenMinimapCanvas = document.createElement('canvas');
        offscreenMinimapCanvas.width = mapWidth; offscreenMinimapCanvas.height = mapHeight;
        offscreenMinimapCtx = offscreenMinimapCanvas.getContext('2d');
        drawDesertBackground(offscreenMinimapCtx);
        drawFloors(offscreenMinimapCtx);
        drawWalls(offscreenMinimapCtx, obstacles);
        obstacles.forEach(obs => { if (obs.type === 'crate') drawCrate(obs, offscreenMinimapCtx); });
        drawBombSites(offscreenMinimapCtx);
    }

    function startGame(mode, players = null, receivedRoomId = null) {
        isGameOver = false; 
        gameMode = mode;
        currentMatchId = receivedRoomId;
        
        generateMapLayout(); 
        generateSandPattern(); 
        drawFullMapToOffscreenCanvas(); 
        roundState = { blueScore: 0, redScore: 0, roundNumber: 0 };
        gameState = { gameTimer: 120, currentRadius: Infinity };
        
        if (isHost || !currentMatchId) {
            startRound(players);
        } else {
            // Client-side: Create a temporary character list for the matchup screen
            if (players && players.length > 0) {
                allCharacters = [];
                const team1Colors = ['#4682B4', '#6495ED', '#87CEEB'];
                const team2Colors = ['#DC143C', '#B22222', '#8B0000'];
                players.forEach((p, i) => {
                    const team = (i % 2 === 0) ? 1 : 2;
                    allCharacters.push(createCharacter({
                        id: p.id,
                        name: p.name,
                        team: team,
                        color: team === 1 ? team1Colors[Math.floor(i/2) % team1Colors.length] : team2Colors[Math.floor(i/2) % team2Colors.length],
                        x: 0, y: 0 // Position doesn't matter for matchup screen
                    }));
                });
            }
            displayMatchupScreen();
        }
    }
    
    function endGame() {
        if (isGameOver) return;
        isGameOver = true;
        
        const blueWon = roundState.blueScore > roundState.redScore;
        let winnerText = (blueWon ? "Blue Team" : "Red Team") + " Wins!";

        let mvpPlayerId = null;
        const winnerTeamNum = blueWon ? 1 : 2;
        const winningPlayers = allCharacters.filter(p => p.team === winnerTeamNum);
        if (winningPlayers.length > 0) {
            mvpPlayerId = winningPlayers.sort((a, b) => b.score - a.score)[0].id;
        }

        showRoundScoreboard(`Final Score - ${winnerText}`, mvpPlayerId, true, allCharacters);
    }
    
    function leaveMatch() {
        isGameOver = true; isPaused = false;
        if(animationFrameId) cancelAnimationFrame(animationFrameId);
        animationFrameId = null;

        if (socket && socket.connected) {
            socket.disconnect();
        }
        currentMatchId = null;
        isHost = false; 
        localPlayerId = null;
        localPlayerName = "Player";
        allCharacters = [];

        Object.values(allScreenElements).forEach(el => { if(el) el.style.display = 'none'; });
        gameCanvas.style.display = 'none';
        killCamOverlay.style.display = 'none'; // Explicitly hide kill cam on leave
        
        showScreen('welcome-screen');
    }
    
    const allScreenElements = {
        'welcome-screen': welcomeScreenElement, 'settings-menu': settingsMenuElement, 'in-game-menu': inGameMenuElement,
        'scoreboard-overlay': scoreboardOverlay, 'game': gameUiElement, 'matchup-screen': matchupScreenElement, 
        'multiplayer-name-menu': multiplayerNameMenuElement, 'multiplayer-menu': multiplayerMenuElement
    };

    function showScreen(screenId) {
        if(screenId === 'scoreboard-overlay'){
             scoreboardOverlay.style.display = 'flex';
             roundScoreboardElement.style.display = 'flex';
             return;
        }
        if(screenId === 'in-game-menu'){
            inGameMenuElement.style.display = 'flex';
            isPaused = true;
            return;
        }

        Object.values(allScreenElements).forEach(el => { if(el) el.style.display = 'none'; });
        gameCanvas.style.display = 'none';
        stopWelcomeAnimation();
        
        if (screenId === 'game') { 
            gameUiElement.style.display = 'block'; 
            gameCanvas.style.display = 'block';
        } else if (allScreenElements[screenId]) {
            allScreenElements[screenId].style.display = 'flex';
             if (screenId === 'welcome-screen') {
                 startWelcomeAnimation();
             }
        }
    }

    function displayMessageModal(message, title = "Notice") {
        modalTitle.textContent = title;
        modalMessage.textContent = message;
        messageModal.style.display = 'flex';
    }
    
    function updateScreenShake(deltaTime) {
        if (screenShake.duration > 0) {
            screenShake.duration -= deltaTime;
            screenShake.intensity = Math.max(0, screenShake.intensity * 0.95);
        } else {
            screenShake.intensity = 0;
        }
    }

    function gameLoop(timestamp) {
        if (isGameOver || isPaused) {
             return;
        }
        
        const now = performance.now();
        const deltaTime = now - (lastTimestamp || now);
        lastTimestamp = now;
        const dtSeconds = deltaTime / 1000;

        if (isKillCamActive) {
            if (!lastKillInfo || !killCamReplayBuffer || killCamReplayBuffer.length === 0) {
                isKillCamActive = false;
                proceedToScoreboard(postKillCamWinningTeam, postKillCamReason, postKillCamPlayerStats);
                return;
            }

            let playbackSpeed = 1.0;
            if(killCamReplayClock > killCamOverlay.slowMoStartTime && killCamReplayClock < killCamOverlay.slowMoEndTime) {
                playbackSpeed = 0.3;
            }
            
            killCamReplayClock += deltaTime * playbackSpeed;

            const replayDuration = killCamReplayBuffer[killCamReplayBuffer.length - 1].timestamp - killCamReplayBuffer[0].timestamp;

            if (killCamReplayClock >= replayDuration) {
                isKillCamActive = false;
                proceedToScoreboard(postKillCamWinningTeam, postKillCamReason, postKillCamPlayerStats);
            } else {
                let currentFrame = null;
                for (let i = 0; i < killCamReplayBuffer.length; i++) {
                    const frameRelativeTime = killCamReplayBuffer[i].timestamp - killCamReplayBuffer[0].timestamp;
                    if (frameRelativeTime >= killCamReplayClock) {
                        currentFrame = killCamReplayBuffer[i];
                        break;
                    }
                }
                if (!currentFrame) {
                    currentFrame = killCamReplayBuffer[killCamReplayBuffer.length - 1];
                }
                
                drawGame(timestamp, currentFrame);
            }
        } else {
            
            updateGameTimers(dtSeconds);

            // Apply server state if this client is not the host
            if (currentMatchId && !isHost && gameStateSnapshot){
                 const myPlayerBeforeUpdate = allCharacters.find(c => c.id === localPlayerId);
                 
                 allCharacters = gameStateSnapshot.characters;
                 bullets = gameStateSnapshot.bullets;
                 bomb = gameStateSnapshot.bomb;
                 bombItem = gameStateSnapshot.bombItem;
                 if (gameStateSnapshot.particles) particles = gameStateSnapshot.particles;
                 if (gameStateSnapshot.obstacles) obstacles = gameStateSnapshot.obstacles;
                 gameState = gameStateSnapshot.gameState;
                 roundState = gameStateSnapshot.roundState;
                 isRoundActive = gameStateSnapshot.isRoundActive; 
                 inRoundTransition = gameStateSnapshot.inRoundTransition; 
                 isDetonationSequenceActive = gameStateSnapshot.isDetonationSequenceActive;
                 detonationCameraTarget = gameStateSnapshot.detonationCameraTarget;
                 screenShake = gameStateSnapshot.screenShake;
                 
                 const myPlayerAfterUpdate = allCharacters.find(c => c.id === localPlayerId);
                 if (myPlayerBeforeUpdate && myPlayerAfterUpdate) {
                    myPlayerAfterUpdate.aimAngle = myPlayerBeforeUpdate.aimAngle;
                 }

                 gameStateSnapshot = null; // Clear snapshot after applying
            }

            // Host runs the full simulation for all entities
            if (!currentMatchId || isHost) { 
                updateCharacters(dtSeconds); 
                updateBullets(dtSeconds);
                if (!inRoundTransition) { 
                    checkWinCondition();
                }
            } else {
                 // Non-hosts just update their own character's input-driven state for prediction
                 updateCharacters(dtSeconds);
            }
            
            // Send updates to server
            if(currentMatchId && socket && socket.connected) {
                if (isHost) {
                    // Host creates and sends a full snapshot
                    const snapshot = {
                        roomId: currentMatchId,
                        characters: allCharacters.map(c => { const { networkInput, ...rest } = c; return rest; }),
                        bullets: bullets.map(b => ({...b})),
                        bomb: { ...bomb },
                        bombItem: { ...bombItem },
                        gameState: { ...gameState },
                        roundState: { ...roundState },
                        isRoundActive: isRoundActive,
                        inRoundTransition: inRoundTransition,
                        isDetonationSequenceActive: isDetonationSequenceActive,
                        detonationCameraTarget: detonationCameraTarget,
                        screenShake: {...screenShake},
                        timestamp: performance.now()
                    };
                    historyBuffer.push(JSON.parse(JSON.stringify(snapshot)));
                    if (historyBuffer.length > MAX_HISTORY_FRAMES) historyBuffer.shift();
                    socket.emit('gameStateSync', snapshot);
                } else { 
                    // Non-host sends its input
                    const player = allCharacters.find(c => c.id === localPlayerId);
                    if(player){
                        let dx = 0, dy = 0;
                        if(!player.isPlanting && !player.isDefusing && !isDetonationSequenceActive && !inRoundTransition) {
                            if (gameSettings.useJoysticks && movementJoystick?.isActive) { dx += movementJoystick.vector.x; dy += movementJoystick.vector.y; }
                            if (keysDown.a) dx -= 1; if (keysDown.d) dx += 1;
                            if (keysDown.w) dy -= 1; if (keysDown.s) dy += 1;
                        }
                        
                        socket.emit('playerStateUpdate', {
                            dx: dx, dy: dy, 
                            aimAngle: localPlayerAimAngle, 
                            isAiming: isLocalPlayerAiming,
                            isPlantingButtonHeld: isPlantingButtonHeld || (keysDown['e'] && nearActiveBombSite(player)),
                            isDefusingButtonHeld: isDefusingButtonHeld || (keysDown['e'] && nearBomb(player)),
                        });
                    }
                }
            } else if (!currentMatchId) {
                // Single player history buffer
                const snapshot = {
                    characters: allCharacters.map(c => JSON.parse(JSON.stringify(c))),
                    bullets: bullets.map(b => ({...b})),
                    bomb: { ...bomb },
                    bombItem: { ...bombItem },
                    timestamp: performance.now()
                };
                historyBuffer.push(snapshot);
                if (historyBuffer.length > MAX_HISTORY_FRAMES) historyBuffer.shift();
            }
            
            updateScreenShake(dtSeconds);
            updateParticles(dtSeconds);
            drawGame(timestamp);
        }
        
        if (!isGameOver) {
            animationFrameId = requestAnimationFrame(gameLoop);
        }
    }

    function updateBullets(deltaTime) {
        if (!isHost && currentMatchId) return;

        for (let i = bullets.length - 1; i >= 0; i--) {
            const b = bullets[i];
            b.x += b.dx; b.y += b.dy;
            let hit = false;
            
            for(const obs of obstacles) {
                if(b.x > obs.x && b.x < obs.x + obs.w && b.y > obs.y && b.y < obs.y + obs.h) {
                    hit = true;
                    createParticles(b.x, b.y, 5, '#8B4513');
                    obs.hp -= bulletDamage;
                    if (obs.hp <= 0) {
                        obstacles = obstacles.filter(o => o.id !== obs.id);
                        losSegments = losSegments.filter(w => w.ownerId !== obs.id);
                        createPathfindingGrid();
                    }
                    break;
                }
            }
            if(hit) { bullets.splice(i, 1); continue; }

            for (const target of allCharacters) {
                if (target.hp > 0 && target.team !== b.team && distSq(b.x, b.y, target.x, target.y) < playerRadius * playerRadius) {
                    const shooter = allCharacters.find(c => c.id === b.owner);
                    applyDamageAndHandleKill(target, shooter, bulletDamage);
                    hit = true; break;
                }
            }
            if (hit || b.x < 0 || b.x > mapWidth || b.y < 0 || b.y > mapHeight) bullets.splice(i, 1);
        }
    }

    function updateParticles(deltaTime) { for (let i = particles.length - 1; i >= 0; i--) { const p = particles[i]; p.x += p.dx; p.y += p.dy; p.lifetime--; p.alpha = p.lifetime / 40; if (p.lifetime <= 0) particles.splice(i, 1); } }
    
    function resolveMovementWithCollision(character, dx, dy) {
        character.x += dx;
        obstacles.forEach(obs => {
            if (character.x + character.radius > obs.x && character.x - character.radius < obs.x + obs.w &&
                character.y + character.radius > obs.y && character.y - character.radius < obs.y + obs.h) {
                if (dx > 0) character.x = obs.x - character.radius; else if (dx < 0) character.x = obs.x + obs.w + character.radius;
            }
        });
        character.y += dy;
        obstacles.forEach(obs => {
            if (character.x + character.radius > obs.x && character.x - character.radius < obs.x + obs.w &&
                character.y + character.radius > obs.y && character.y - character.radius < obs.y + obs.h) {
                if (dy > 0) character.y = obs.y - character.radius; else if (dy < 0) character.y = obs.y + obs.h + character.radius;
            }
        });
        character.x = Math.max(character.radius, Math.min(mapWidth - character.radius, character.x));
        character.y = Math.max(character.radius, Math.min(mapHeight - character.radius, character.y));
    }
    
    function drawCrate(crate, g = ctx) {
        const x = crate.x, y = crate.y, w = crate.w, h = crate.h;
        const baseColor = '#9A6A42', shadowColor = '#6F4E2F', highlightColor = '#B58A5F';
        g.fillStyle = baseColor; g.fillRect(x, y, w, h);
        g.fillStyle = shadowColor;
        g.beginPath(); g.moveTo(x, y + h); g.lineTo(x + 5, y + h - 5); g.lineTo(x + w, y + h - 5); g.lineTo(x + w, y + h); g.closePath(); g.fill();
        g.beginPath(); g.moveTo(x + w, y); g.lineTo(x + w - 5, y + 5); g.lineTo(x + w - 5, y + h); g.lineTo(x + w, y + h); g.closePath(); g.fill();
        g.strokeStyle = shadowColor; g.lineWidth = 2; g.beginPath(); g.moveTo(x, y + h / 2); g.lineTo(x + w, y + h / 2); g.stroke();
        g.strokeStyle = highlightColor; g.lineWidth = 1; g.beginPath(); g.moveTo(x, y + 1); g.lineTo(x + w, y + 1); g.stroke();
    }
    
    function drawWalls(g = ctx, wallsToDraw){wallsToDraw.forEach(obs=>{if(obs.type==='wall'){g.fillStyle='black';g.fillRect(obs.x,obs.y,obs.w,obs.h);if(!obs.isEnclosed){g.strokeStyle='black';g.lineWidth=wallThickness;g.beginPath();if(obs.borders.top)g.moveTo(obs.x,obs.y),g.lineTo(obs.x+obs.w,obs.y);if(obs.borders.bottom)g.moveTo(obs.x,obs.y+obs.h),g.lineTo(obs.x+obs.w,obs.y+obs.h);if(obs.borders.left)g.moveTo(obs.x,obs.y),g.lineTo(obs.x,obs.y+obs.h);if(obs.borders.right)g.moveTo(obs.x+obs.w,obs.y),g.lineTo(obs.x+obs.w,obs.y+obs.h);g.stroke();g.strokeStyle=wallColor;g.lineWidth=wallThickness-4;g.beginPath();if(obs.borders.top)g.moveTo(obs.x,obs.y),g.lineTo(obs.x+obs.w,obs.y);if(obs.borders.bottom)g.moveTo(obs.x,obs.y+obs.h),g.lineTo(obs.x+obs.w,obs.y+obs.h);if(obs.borders.left)g.moveTo(obs.x,obs.y),g.lineTo(obs.x,obs.y+obs.h);if(obs.borders.right)g.moveTo(obs.x+obs.w,obs.y),g.lineTo(obs.x+obs.w,obs.y+obs.h);g.stroke();}}});}

    function drawFloors(g = ctx){if(floorTiles.length===0)return;g.fillStyle=floorColor;floorTiles.forEach(tile=>g.fillRect(tile.x,tile.y,tile.w,tile.h));}
    
    function drawCharacter(character, g = ctx, cameraTarget, player) {
        const charHp = character.hp !== undefined ? character.hp : 0;
        if (charHp <= 0) return;

        let isVisible = false;
        if (distSq(cameraTarget.x, cameraTarget.y, character.x, character.y) <= lightRadius * lightRadius) {
            if (hasLineOfSight(cameraTarget, character)) isVisible = true;
        }
        if(isVisible){
            drawCircle(character.x+3,character.y+3,character.radius,'rgba(0,0,0,0.2)', g);
            g.save(); g.translate(character.x,character.y); g.rotate(character.aimAngle);
            g.fillStyle='#222'; g.fillRect(character.radius, -3, 8, 6); g.restore();
            drawCircle(character.x,character.y,character.radius,character.color, g);
            if (player && character.id !== player.id && character.team === player.team) drawHPBar(character.x,character.y,charHp,initialHitPoints,character.radius,'#4CAF50', g);
            g.fillStyle = 'white'; g.textAlign = 'center'; g.font = '12px Courier New';
            g.fillText(character.id === localPlayerId ? 'You' : character.name, character.x, character.y + character.radius + 12);
        }
    }

    function drawHPBar(x, y, currentHP, maxHP, radius, color, g = ctx) { const barWidth = radius*2; const barHeight = 5; const barX = x - radius; const barY = y - radius - barHeight - 5; g.fillStyle = '#555'; g.fillRect(barX, barY, barWidth, barHeight); const hpRatio = Math.max(0, currentHP/maxHP); g.fillStyle = color; g.fillRect(barX, barY, barWidth*hpRatio, barHeight);}
    function drawCircle(x, y, radius, color, g = ctx) { g.fillStyle = color; g.beginPath(); g.arc(x, y, radius, 0, Math.PI * 2); g.fill(); }
    
    function initialize() {
        // Single Player Buttons
        threeVThreeButton.onclick = () => startGame('3v3');
        twoVTwoButton.onclick = () => startGame('2v2');
        oneVOneButton.onclick = () => startGame('1v1');
        
        // Main Menu Buttons
        mainMenuSettingsButton.onclick = () => { previousView = 'welcome-screen'; showScreen('settings-menu'); };
        showSpMenuButton.onclick = () => { mainMenuView.style.display = 'none'; singlePlayerMenuView.style.display = 'block'; };
        spBackButton.onclick = () => { 
            singlePlayerMenuView.style.display = 'none';
            mainMenuView.style.display = 'block';
        };
        
        // Multiplayer Menu Buttons
        showMpMenuButton.onclick = () => { showScreen('multiplayer-name-menu'); };
        mpNameBackButton.onclick = () => { showScreen('welcome-screen'); };
        confirmNameButton.onclick = () => {
            const name = playerNameInput.value.trim();
            if (!name) {
                displayMessageModal("Please enter a name.");
                return;
            }
            localPlayerName = name;
            if (!socket || !socket.connected) {
                connectToServer();
            }
            showScreen('multiplayer-menu');
        };

        mpBackButton.onclick = () => { showScreen('multiplayer-name-menu'); };
        
        const joinQueue = (mode) => {
            if (socket && socket.connected) {
                socket.emit('joinQueue', { gameMode: mode, playerName: localPlayerName });
            } else {
                displayMessageModal("Not connected to server. Please try again.");
            }
        };
        mpOneVOneButton.onclick = () => joinQueue('1v1');
        mpTwoVTwoButton.onclick = () => joinQueue('2v2');
        mpThreeVThreeButton.onclick = () => joinQueue('3v3');

        // General UI Buttons
        backButton.onclick = () => { 
            settingsMenuElement.style.display = 'none';
            if (previousView === 'in-game-menu') inGameMenuElement.style.display = 'flex';
            else { showScreen('welcome-screen'); mainMenuView.style.display = 'block'; singlePlayerMenuView.style.display = 'none'; }
        };
        joystickToggle.onchange = () => { gameSettings.useJoysticks = joystickToggle.checked; };
        
        inGameMenuButton.onclick = () => {
            isPaused = !isPaused;
            inGameMenuElement.style.display = isPaused ? 'flex' : 'none';
        };
        resumeButton.onclick = () => {
             isPaused = false;
             inGameMenuElement.style.display = 'none';
             lastTimestamp = performance.now(); // Prevents a time jump
             requestAnimationFrame(gameLoop);
        };
        leaveMatchButton.onclick = leaveMatch;
        spectatePrevButton.onclick = () => cycleSpectator(-1);
        spectateNextButton.onclick = () => cycleSpectator(1);
        tdmUiContainer.onclick = () => { if(isRoundActive && !inRoundTransition){ showRoundScoreboard("Scoreboard", null, isGameOver); } };
        scoreboardOverlay.onclick = (e) => { if(e.target === scoreboardOverlay && !inRoundTransition && !isGameOver) scoreboardOverlay.style.display = 'none'; };
        modalCloseButton.onclick = () => { messageModal.style.display = 'none'; };

        // Reload functionality
        function requestReload() {
            const player = allCharacters.find(c => c.id === localPlayerId);
            if (!player || player.isReloading || player.ammo >= player.clipSize) {
                return;
            }

            // Correctly handle who performs the action
            if (currentMatchId && !isHost) {
                // I am a CLIENT in a multiplayer game. Send an event to the host.
                socket.emit('requestReload');
            } else {
                // I am either in SINGLE-PLAYER or I AM THE HOST of a multiplayer game.
                // In both cases, I have authority to change my own state directly.
                player.isReloading = true;
                player.reloadTimer = player.reloadTime;
            }
        }

        ammoCounterButton.addEventListener('click', requestReload);
        ammoCounterButton.addEventListener('touchstart', (e) => {
            e.preventDefault();
            requestReload();
        });

        document.addEventListener('keydown', (event) => { 
            const key=event.key.toLowerCase(); 
            if(key in keysDown) keysDown[key]=true; 
            if (key === 'r') {
                requestReload(); // Also trigger with 'r' key
            }
            if(key===' ') {
                if (inRoundTransition) return;
                isLocalPlayerAiming = true;
                event.preventDefault(); 
            }
            if(key === 'escape' && !isGameOver && gameCanvas.style.display === 'block') { isPaused = !isPaused; inGameMenuElement.style.display = isPaused ? 'flex' : 'none'; if (!isPaused) { lastTimestamp = performance.now(); requestAnimationFrame(gameLoop); } } 
        });

        document.addEventListener('keyup', (event) => { 
            const key=event.key.toLowerCase(); 
            if(key in keysDown)keysDown[key]=false; 
            if(key === ' ') {
                playerFire();
                isLocalPlayerAiming = false;
            }
        });
        gameCanvas.addEventListener('mousedown', (e) => handlePointerDown(e));
        document.addEventListener('mousemove', (e) => handlePointerMove(e));
        document.addEventListener('mouseup', (e) => handlePointerUp(e));
        gameCanvas.addEventListener('touchstart', (e) => handlePointerDown(e));
        gameCanvas.addEventListener('touchmove', (e) => handlePointerMove(e));
        gameCanvas.addEventListener('touchend', (e) => handlePointerUp(e));
        gameCanvas.addEventListener('touchcancel', (e) => handlePointerUp(e));
        
        if (plantBombButton) {
            plantBombButton.addEventListener('mousedown', () => isPlantingButtonHeld = true);
            plantBombButton.addEventListener('mouseup', () => isPlantingButtonHeld = false);
            plantBombButton.addEventListener('mouseleave', () => isPlantingButtonHeld = false);
            plantBombButton.addEventListener('touchstart', (e) => { e.preventDefault(); isPlantingButtonHeld = true; });
            plantBombButton.addEventListener('touchend', (e) => { e.preventDefault(); isPlantingButtonHeld = false; });
        }
        
        if (defuseBombButton) {
            defuseBombButton.addEventListener('mousedown', () => isDefusingButtonHeld = true);
            defuseBombButton.addEventListener('mouseup', () => isDefusingButtonHeld = false);
            defuseBombButton.addEventListener('mouseleave', () => isDefusingButtonHeld = false);
            defuseBombButton.addEventListener('touchstart', (e) => { e.preventDefault(); isDefusingButtonHeld = true; });
            defuseBombButton.addEventListener('touchend', (e) => { e.preventDefault(); isDefusingButtonHeld = false; });
        }

        gameCanvas.width = 800; gameCanvas.height = 600; 
        minimapCanvas.width = 150; minimapCanvas.height = 150;
        fogCanvas = document.createElement('canvas');
        fogCanvas.width = gameCanvas.width; fogCanvas.height = gameCanvas.height;
        fogCtx = fogCanvas.getContext('2d');
        window.addEventListener('resize', resizeCanvas);
        
        setTimeout(() => {
            window.scrollTo(0, 1);
        }, 100);

        resizeCanvas();
        showScreen('welcome-screen');
    }

    function handlePointerDown(e) { if (!gameSettings.useJoysticks) return; e.preventDefault(); const touches = e.changedTouches || [e]; const rect = gameCanvas.getBoundingClientRect(); for(let i=0; i<touches.length; i++) { const touch = touches[i]; const touchX = touch.clientX - rect.left; const touchY = touch.clientY - rect.top; if (touchX < canvasWidth / 2) { if(!movementJoystick) movementJoystick = new Joystick(touchX, touchY, 70, 35); movementJoystick.baseX = touchX; movementJoystick.baseY = touchY; movementJoystick.isActive = true; movementJoystick.touchId = touch.identifier; movementJoystick.update(touchX, touchY); } else { if(!shootingJoystick) shootingJoystick = new Joystick(touchX, touchY, 70, 35); isLocalPlayerAiming = true; shootingJoystick.baseX = touchX; shootingJoystick.baseY = touchY; shootingJoystick.isActive = true; shootingJoystick.touchId = touch.identifier; shootingJoystick.update(touchX, touchY); } } }
    function handlePointerMove(e) { e.preventDefault(); const rect = gameCanvas.getBoundingClientRect(); const touches = e.changedTouches || [e]; if (touches.length > 0) { mousePos.x = touches[0].clientX - rect.left; mousePos.y = touches[0].clientY - rect.top; } if (!gameSettings.useJoysticks) return; for(let i=0; i<touches.length; i++) { const touch = touches[i]; const touchX = touch.clientX - rect.left; const touchY = touch.clientY - rect.top; if (movementJoystick && movementJoystick.isActive && movementJoystick.touchId === touch.identifier) movementJoystick.update(touchX, touchY); if (shootingJoystick && shootingJoystick.isActive && shootingJoystick.touchId === touch.identifier) shootingJoystick.update(touchX, touchY); } }
    function handlePointerUp(e) { if (!gameSettings.useJoysticks) return; e.preventDefault(); const touches = e.changedTouches || [e]; for(let i=0; i<touches.length; i++) { const touch = touches[i]; if (movementJoystick && movementJoystick.touchId === touch.identifier) movementJoystick.reset(); if (shootingJoystick && shootingJoystick.touchId === touch.identifier) { playerFire(); shootingJoystick.reset(); isLocalPlayerAiming = false; } } }
    
    function resizeCanvas() { 
        const vw = window.innerWidth;
        const vh = window.innerHeight;

        gameContainer.style.width = `${vw}px`;
        gameContainer.style.height = `${vh}px`;
        
        canvasWidth = vw;
        canvasHeight = vh;

        gameCanvas.style.width = `${vw}px`;
        gameCanvas.style.height = `${vh}px`;
        gameCanvas.width = vw;
        gameCanvas.height = vh;

        if (fogCanvas) {
            fogCanvas.width = canvasWidth;
            fogCanvas.height = canvasHeight;
        }
        
        if (welcomeBgCanvas && welcomeScreenElement.style.display !== 'none') { 
            const welcomeRect = welcomeScreenElement.getBoundingClientRect(); 
            welcomeBgCanvas.width = welcomeRect.width; 
            welcomeBgCanvas.height = welcomeRect.height; 
        } 
    }
    
    function startWelcomeAnimation() {
        if (welcomeAnimFrameId) return;
        const welcomeRect = welcomeScreenElement.getBoundingClientRect();
        welcomeBgCanvas.width = welcomeRect.width; 
        welcomeBgCanvas.height = welcomeRect.height; 
        bgCircles = [];
        bgCharacters = [];

        const allColors = ['#4682B4', '#6495ED', '#87CEEB', '#DC143C', '#B22222', '#8B0000'];
        for (let i = 0; i < 10; i++) {
            bgCircles.push({ 
                x: Math.random() * welcomeBgCanvas.width, 
                y: Math.random() * welcomeBgCanvas.height, 
                radius: 10 + Math.random() * 10, 
                color: allColors[i % allColors.length], 
                dx: (Math.random() - 0.5) * 2, 
                dy: (Math.random() - 0.5) * 2 
            });
        }
        
        bgCharacters.push({
            x: welcomeBgCanvas.width * 0.25,
            y: welcomeBgCanvas.height * 0.5,
            radius: 50,
            color: '#4682B4', // Blue
            aimAngle: -Math.PI / 4, // 45 degrees up-right
            dx: (Math.random() - 0.5) * 0.5,
            dy: (Math.random() - 0.5) * 0.5
        });

        bgCharacters.push({
            x: welcomeBgCanvas.width * 0.75,
            y: welcomeBgCanvas.height * 0.5,
            radius: 50,
            color: '#DC143C', // Red
            aimAngle: -Math.PI / 4, // 45 degrees up-right
            dx: (Math.random() - 0.5) * 0.5,
            dy: (Math.random() - 0.5) * 0.5
        });

        welcomeAnimationLoop();
    }
    
    function stopWelcomeAnimation() { if (welcomeAnimFrameId) { cancelAnimationFrame(welcomeAnimFrameId); welcomeAnimFrameId = null; } }
    
    function welcomeAnimationLoop() {
        if (!welcomeBgCtx) return;
        welcomeBgCtx.clearRect(0, 0, welcomeBgCanvas.width, welcomeBgCanvas.height);
        welcomeBgCtx.globalAlpha = 0.5;

        bgCircles.forEach(circle => {
            circle.x += circle.dx; 
            circle.y += circle.dy;
            if (circle.x + circle.radius > welcomeBgCanvas.width || circle.x - circle.radius < 0) circle.dx *= -1;
            if (circle.y + circle.radius > welcomeBgCanvas.height || circle.y - circle.radius < 0) circle.dy *= -1;
            welcomeBgCtx.beginPath(); 
            welcomeBgCtx.arc(circle.x, circle.y, circle.radius, 0, Math.PI * 2);
            welcomeBgCtx.fillStyle = circle.color; 
            welcomeBgCtx.fill();
        });

        bgCharacters.forEach(character => {
             character.x += character.dx;
             character.y += character.dy;
             if (character.x + character.radius > welcomeBgCanvas.width || character.x - character.radius < 0) character.dx *= -1;
             if (character.y + character.radius > welcomeBgCanvas.height || character.y - character.radius < 0) character.dy *= -1;

            welcomeBgCtx.fillStyle = character.color;
            welcomeBgCtx.beginPath();
            welcomeBgCtx.arc(character.x, character.y, character.radius, 0, Math.PI * 2);
            welcomeBgCtx.fill();

            welcomeBgCtx.save();
            welcomeBgCtx.translate(character.x, character.y);
            welcomeBgCtx.rotate(character.aimAngle);
            welcomeBgCtx.fillStyle='#222'; 
            welcomeBgCtx.fillRect(character.radius, -3, 8, 6); 
            welcomeBgCtx.restore();
        });


        welcomeBgCtx.globalAlpha = 1;
        welcomeAnimFrameId = requestAnimationFrame(welcomeAnimationLoop);
    }
    
    function getIntersection(ray, segment) {
        const x1 = ray.p1.x, y1 = ray.p1.y, x2 = ray.p2.x, y2 = ray.p2.y;
        const x3 = segment.p1.x, y3 = segment.p1.y, x4 = segment.p2.x, y4 = segment.p2.y;
        const den = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
        if (den === 0) return null;
        const t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / den;
        const u = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / den;
        if (t > 0 && u >= 0 && u <= 1) {
            return { x: x1 + t * (x2 - x1), y: y1 + t * (y2 - y1) };
        }
        return null;
    }

    function calculateVisibility(origin, segments) {
        if (!origin || typeof origin.x !== 'number' || typeof origin.y !== 'number') return [];
        
        const allPoints = [];
        segments.forEach(seg => {
            allPoints.push(seg.p1, seg.p2);
        });

        const allAngles = [];
        allPoints.forEach(point => {
            const angle = Math.atan2(point.y - origin.y, point.x - origin.x);
            allAngles.push(angle - 0.0001, angle, angle + 0.0001);
        });

        for (let i = 0; i < 360; i += 2) {
             allAngles.push(i * Math.PI / 180);
        }
        
        const uniqueAngles = [...new Set(allAngles)];
        
        const visibilityPolygonPoints = [];
        uniqueAngles.forEach(angle => {
            const nudge = 0.001;
            const nudgedOrigin = {
                x: origin.x + nudge * Math.cos(angle),
                y: origin.y + nudge * Math.sin(angle)
            };

            const ray = {
                p1: nudgedOrigin,
                p2: { x: nudgedOrigin.x + Math.cos(angle) * lightRadius, y: origin.y + Math.sin(angle) * lightRadius }
            };
            
            let closestIntersection = null;
            let closestDistSq = lightRadius * lightRadius;

            for (const segment of segments) {
                const intersection = getIntersection(ray, segment);
                if (intersection) {
                    const distSqVal = distSq(origin.x, origin.y, intersection.x, intersection.y);
                    if (distSqVal < closestDistSq) {
                        closestDistSq = distSqVal;
                        closestIntersection = intersection;
                    }
                }
            }
            
            if (closestIntersection) {
                 visibilityPolygonPoints.push(closestIntersection);
            } else {
                 visibilityPolygonPoints.push({ x: origin.x + Math.cos(angle) * lightRadius, y: origin.y + Math.sin(angle) * lightRadius });
            }
        });
        
        visibilityPolygonPoints.sort((a,b) => Math.atan2(a.y - origin.y, a.x - origin.x) - Math.atan2(b.y - origin.y, b.x - origin.x));

        return visibilityPolygonPoints;
    }

    function drawMinimap(currentState) {
        const cameraTarget = currentState.characters.find(c => c.id === spectatingId || (c.id === localPlayerId && !spectatingId)) || null;
        if (!cameraTarget || !offscreenMinimapCanvas) return;

        const mmWidth = minimapCanvas.width, mmHeight = minimapCanvas.height;
        minimapCtx.clearRect(0, 0, mmWidth, mmHeight);
        
        const zoomFactor = 4;
        const sourceViewWidth = mapWidth / zoomFactor, sourceViewHeight = mapHeight / zoomFactor;
        let sx = cameraTarget.x - sourceViewWidth / 2, sy = cameraTarget.y - sourceViewHeight / 2;
        sx = Math.max(0, Math.min(mapWidth - sourceViewWidth, sx));
        sy = Math.max(0, Math.min(mapHeight - sourceViewHeight, sy));
        minimapCtx.drawImage(offscreenMinimapCanvas, sx, sy, sourceViewWidth, sourceViewHeight, 0, 0, mmWidth, mmHeight);

        currentState.characters.forEach(c => {
            if (c.hp <= 0) return;
            const isPlayerOrAlly = c.team === cameraTarget.team;
            const isVisibleEnemy = c.team !== cameraTarget.team && c.showOnMinimapTimer > 0;
            
            if (isPlayerOrAlly || isVisibleEnemy) {
                if (c.x >= sx && c.x <= sx + sourceViewWidth && c.y >= sy && c.y <= sy + sourceViewHeight) {
                    const drawX = (c.x - sx) * (mmWidth / sourceViewWidth), drawY = (c.y - sy) * (mmHeight / sourceViewHeight);
                    minimapCtx.fillStyle = c.id === localPlayerId ? 'lime' : (c.team === cameraTarget.team ? 'cyan' : 'red');
                    minimapCtx.beginPath(); minimapCtx.arc(drawX, drawY, 4, 0, 2 * Math.PI); minimapCtx.fill();
                }
            }
        });
    }

    function showFullscreenMap() { if (isPaused || inRoundTransition || isGameOver || !offscreenMinimapCanvas) return; fullscreenMapOverlay.style.display = 'flex'; drawFullscreenMap(); }
    function hideFullscreenMap() { fullscreenMapOverlay.style.display = 'none'; }
    function drawFullscreenMap() {
        if (!offscreenMinimapCanvas) return;
        const fullMapCtx = fullscreenMapCanvas.getContext('2d');
        const mapAspectRatio = mapWidth / mapHeight;
        let newWidth = window.innerWidth * 0.9, newHeight = newWidth / mapAspectRatio;
        if (newHeight > window.innerHeight * 0.9) { newHeight = window.innerHeight * 0.9; newWidth = newHeight * mapAspectRatio; }
        fullscreenMapCanvas.width = newWidth; fullscreenMapCanvas.height = newHeight;
        fullMapCtx.drawImage(offscreenMinimapCanvas, 0, 0, newWidth, newHeight);
        const scaleX = newWidth / mapWidth, scaleY = newHeight / mapHeight;
        allCharacters.forEach(c => {
            if (c.hp <= 0) return;
            fullMapCtx.fillStyle = c.id === localPlayerId ? 'lime' : (c.team === 1 ? 'cyan' : 'red');
            fullMapCtx.beginPath(); fullMapCtx.arc(c.x * scaleX, c.y * scaleY, 5, 0, 2 * Math.PI); fullMapCtx.fill();
        });
    }

    function updateTeamStatusUI(characters) {
        const player = characters.find(c => c.id === localPlayerId);
        if (!player) return;
        const blueTeam = characters.filter(c => c.team === 1).sort((a,b) => a.id.localeCompare(b.id));
        const redTeam = characters.filter(c => c.team === 2).sort((a,b) => a.id.localeCompare(b.id));
        const playerIsOnAttackingTeam = player.team === roundState.attackingTeam;
        
        blueTeamIconsContainer.innerHTML = ''; redTeamIconsContainer.innerHTML = '';
        
        const createPortraitElement = (character, container, showBomb) => {
            if (!character) return;
            const wrapper = document.createElement('div'); wrapper.className = 'player-portrait-wrapper';
            const canvas = document.createElement('canvas'); const portraitSize = 40;
            canvas.width = portraitSize; canvas.height = portraitSize;
            canvas.style.width = `${portraitSize}px`; canvas.style.height = `${portraitSize}px`;
            const bombText = document.createElement('div');
            bombText.style.cssText = 'color: orange; font-size: 8px; font-weight: bold; height: 10px;';
            if (showBomb && character.hasBomb) bombText.textContent = 'BOMB';
            drawPlayerPortrait(canvas, character);
            wrapper.appendChild(canvas); wrapper.appendChild(bombText);
            container.appendChild(wrapper);
        };
        blueTeam.forEach(char => createPortraitElement(char, blueTeamIconsContainer, player.team === 1 && playerIsOnAttackingTeam));
        redTeam.forEach(char => createPortraitElement(char, redTeamIconsContainer, player.team === 2 && playerIsOnAttackingTeam));
    }
    
    function drawPlayerPortrait(canvas, player, useStaticAngle = true) {
        if (!canvas) return;
        const g = canvas.getContext('2d');

        g.fillStyle = '#CDBA96';
        g.fillRect(0, 0, canvas.width, canvas.height);
        
        g.strokeStyle = 'rgba(0,0,0,0.2)';
        g.lineWidth = 2;
        g.strokeRect(1, 1, canvas.width - 2, canvas.height - 2);

        if (!player) return;

        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;
        const radius = canvas.width / 3;

        g.fillStyle = 'rgba(0,0,0,0.2)';
        g.beginPath();
        g.arc(centerX + 3, centerY + 3, radius, 0, Math.PI * 2);
        g.fill();

        g.fillStyle = player.color;
        g.beginPath();
        g.arc(centerX, centerY, radius, 0, Math.PI * 2);
        g.fill();
        
        g.save();
        g.translate(centerX, centerY);
        g.rotate(useStaticAngle ? 0 : player.aimAngle); 
        g.fillStyle='#222';
        g.fillRect(radius, -3, 8, 6);
        g.restore();

        if (player.hp <= 0) {
            g.fillStyle = 'rgba(0,0,0,0.7)';
            g.fillRect(0,0,canvas.width,canvas.height);
        }
    }
   
    function updateSpectateList(player) {
        spectatablePlayers = [];
        const attackersAlive = allCharacters.some(c => c.team === roundState.attackingTeam && c.hp > 0);
        if (player.team === roundState.attackingTeam && !attackersAlive && bomb.planted) {
            spectatablePlayers = allCharacters.filter(c => c.team !== roundState.attackingTeam && c.hp > 0);
        } else {
            spectatablePlayers = allCharacters.filter(c => c.team === player.team && c.hp > 0);
        }
        if (spectatablePlayers.length > 0) spectatingId = spectatablePlayers[0].id;
        else spectatingId = null;
    }

    function cycleSpectator(direction) {
        if (!spectatingId || spectatablePlayers.length <= 1) return;
        const currentIndex = spectatablePlayers.findIndex(p => p.id === spectatingId);
        if (currentIndex === -1) return;
        let nextIndex = (currentIndex + direction + spectatablePlayers.length) % spectatablePlayers.length;
        spectatingId = spectatablePlayers[nextIndex].id;
    }
    
    // --- Initial Setup ---
    initialize();
    
    });
</script>
</body>
</html>
